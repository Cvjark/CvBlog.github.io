<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入理解SanitizerCoverage实施"><meta name="keywords" content="源码,libfuzzer系列,fuzzing,LLVM"><meta name="author" content="Victory+"><meta name="copyright" content="Victory+"><title>深入理解SanitizerCoverage实施 | Victory+'s blog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Victory+'s blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="当前文章概览">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo"><span class="toc-number">1.</span> <span class="toc-text">Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%94%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">程序分支分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">插桩分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.</span> <span class="toc-text">插桩结果验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sanitizer-cov-trace-pc-guard"><span class="toc-number">2.1.</span> <span class="toc-text">__sanitizer_cov_trace_pc_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sanitizer-cov-trace-pc-guard-init"><span class="toc-number">2.2.</span> <span class="toc-text">__sanitizer_cov_trace_pc_guard_init</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%891-sanitizer-cov-trace-pc-guard-init"><span class="toc-number">2.2.1.</span> <span class="toc-text">自定义1 __sanitizer_cov_trace_pc_guard_init</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-defined-ver"><span class="toc-number">3.</span> <span class="toc-text">self-defined-ver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">3.1.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">3.2.</span> <span class="toc-text">运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-defined-ver2"><span class="toc-number">4.</span> <span class="toc-text">self-defined-ver2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">源码行为分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PassManager"><span class="toc-number">5.1.</span> <span class="toc-text">PassManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FunctionPass-amp-FunctionPass"><span class="toc-number">5.2.</span> <span class="toc-text">FunctionPass &amp; FunctionPass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ModulePass"><span class="toc-number">5.3.</span> <span class="toc-text">ModulePass</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RunOnModule"><span class="toc-number">5.3.1.</span> <span class="toc-text">RunOnModule</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#getOrInsertFunction"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">getOrInsertFunction</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#runOnFunction"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">runOnFunction</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%85%E8%A1%A5%E5%85%85"><span class="toc-number">6.</span> <span class="toc-text">待补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-number">7.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Victory+</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链(欢迎扩列哟...)</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/lcatro">lcatro</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/mp/wallhaven-mpmoly.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Victory+'s blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a><a class="site-page" href="/todolist/">ToDoList</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">深入理解SanitizerCoverage实施</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/fuzzer/">fuzzer</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/05/20/深入理解SanitizerCoverage实施/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><span>Reading time: 25 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>经过上节阅读Clang文档中实现SanitizerCoverage的内容，对于clang实现SanitizerCoverage有个大概的印象。这节我们深入一些探讨这块内容。出于记录学习的目的，文章中引用了一些网络师傅的博文，链接统一放在文末。</p>
<p>另外本节涉及到的源码部分来自LLVM 9.0.1-rc1 （<a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-9.0.1-rc1">link click</a>）</p>
<br>

<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rand() % <span class="number">2</span>)</span><br><span class="line">        function1(rand() % <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        function2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们学习到，SanitizerCoverage有三种不同粒度的插桩单元，默认为Edge（此外还有BasicBlock、func），这里以默认的Edge进行分析。</p>
<br>

<h4 id="程序分支分析"><a href="#程序分支分析" class="headerlink" title="程序分支分析"></a>程序分支分析</h4><p>从主干，到分支，依次的示意图如下：</p>
<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/1.png" class="">

<br>

<h4 id="插桩分析"><a href="#插桩分析" class="headerlink" title="插桩分析"></a>插桩分析</h4><p>当编译选项为<code>-fsanitize-coverage=trace-pc-guard</code>，会在相应的位置插桩，用以记录代码覆盖率</p>
<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/2.png" class="">

<br>

<h4 id="插桩结果验证"><a href="#插桩结果验证" class="headerlink" title="插桩结果验证"></a>插桩结果验证</h4><p>编译上述的示例代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">clang -fsanitize-coverage=trace-pc-guard ./sancov-demo.c -g -o with-trace-pc-guard</span></span><br></pre></td></tr></table></figure>

<p>这里利用IDA查看经过编译后插桩的效果:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _sanitizer_cov_trace_pc_guard(dword_645BB0);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">rand</span>() % <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _sanitizer_cov_trace_pc_guard(&amp;dword_645BB0[<span class="number">1</span>]);</span><br><span class="line">    v3 = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="built_in">function1</span>(v3 % <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _sanitizer_cov_trace_pc_guard(&amp;dword_645BB0[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">function2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDA查看function 1的状况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/3.png" class="">

<p>行为同样是主干插桩以及各分支插桩</p>
<br>

<p>在演示一个例子，-fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp，会再cmp的指令位置进行插桩，以demo code为例，存在两处，一处是<code>main.if( rand() % 2 ) </code>一处是<code>function 1.if( a==1 ) </code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -fsanitize-coverage=trace-pc-guard,trace-cmp ./sancov-demo.c -g -o ./with-trace-cmp</span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/4.png" class="">

<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/5.png" class="">

<br>

<hr>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="sanitizer-cov-trace-pc-guard"><a href="#sanitizer-cov-trace-pc-guard" class="headerlink" title="__sanitizer_cov_trace_pc_guard"></a>__sanitizer_cov_trace_pc_guard</h4><p>那么主要完成插桩的函数<code>__sanitizer_cov_trace_pc_guard</code>都做了什么？查看文档，发现有这么一句</p>
<blockquote>
<p>The functions _<em>sanitizer_cov_trace_pc</em>* should be defined by the user.，也就是说插桩的具体工作用户应该定义，（尽管llvm会提供内置版本，但用户定义的的好处是更加清晰自己的完成内容）这句话请读者先记着，后面还会有</p>
</blockquote>
<p>llvm内置的原型（在源码位置\compiler-rt\lib\fuzzer\dataflow\DataFlowCallbacks.cpp）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="type">size_t</span> GuardIdx = guard - GuardsBeg;</span><br><span class="line">  <span class="comment">// assert(GuardIdx &lt; __dft.NumGuards);</span></span><br><span class="line">  __dft.BBExecuted[GuardIdx] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// not a function entry.</span></span><br><span class="line">  <span class="type">uint32_t</span> FuncNum = *guard - <span class="number">1</span>;  <span class="comment">// Guards start from 1.</span></span><br><span class="line">  <span class="comment">// assert(FuncNum &lt; __dft.NumFuncs);</span></span><br><span class="line">  CurrentFunc = FuncNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/6.png" class="">

<p>从示意图出发，理解LLVM提供的版本完成的工作是指示当前的程序分支被执行，设置<code>__dft.BBExecuted[GuardIdx] = true;</code> </p>
<p>clang文档中给出了一个用户自定义的example：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>; </span><br><span class="line">    <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// This function is a part of the sanitizer run-time.</span></span><br><span class="line">    <span class="comment">// To use it, link with AddressSanitizer or other sanitizer.</span></span><br><span class="line">    __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="built_in">sizeof</span>(PcDescr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（ps：关于guard的描述是程序中的每一个Edge code会有自己的一个guard变量（类型是uint32_t））</p>
<p>当运行检测工具启用，则会调用<code>__sanitizer_symbolize_pc</code>完善对代码的插桩工作，会将插桩位置记录在<code>__builtin_return_address</code>中，并且传入写当前插桩的一些信息说明到PcDescr</p>
<p>找到在llvm中API <code>__sanitizer_symbolize_pc</code>相应的源码部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">SANITIZER_INTERFACE_ATTRIBUTE</span><br><span class="line"><span class="type">void</span> __sanitizer_symbolize_pc(uptr pc, <span class="type">const</span> <span class="type">char</span> *fmt, <span class="type">char</span> *out_buf, uptr out_buf_size) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!out_buf_size) <span class="keyword">return</span>;</span><br><span class="line">  pc = StackTrace::<span class="built_in">GetPreviousInstructionPc</span>(pc);</span><br><span class="line">  SymbolizedStack *frame = Symbolizer::<span class="built_in">GetOrInit</span>()-&gt;<span class="built_in">SymbolizePC</span>(pc);</span><br><span class="line">  <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">    <span class="built_in">internal_strncpy</span>(out_buf, <span class="string">&quot;&lt;can&#x27;t symbolize&gt;&quot;</span>, out_buf_size);</span><br><span class="line">    out_buf[out_buf_size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">InternalScopedString <span class="title">frame_desc</span><span class="params">(GetPageSizeCached())</span></span>;</span><br><span class="line">  uptr frame_num = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Reserve one byte for the final 0.</span></span><br><span class="line">  <span class="type">char</span> *out_end = out_buf + out_buf_size - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (SymbolizedStack *cur = frame; cur &amp;&amp; out_buf &lt; out_end;</span><br><span class="line">       cur = cur-&gt;next) &#123;</span><br><span class="line">    frame_desc.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">RenderFrame</span>(&amp;frame_desc, fmt, frame_num++, cur-&gt;info,</span><br><span class="line">                <span class="built_in">common_flags</span>()-&gt;symbolize_vs_style,</span><br><span class="line">                <span class="built_in">common_flags</span>()-&gt;strip_path_prefix);</span><br><span class="line">    <span class="keyword">if</span> (!frame_desc.<span class="built_in">length</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// Reserve one byte for the terminating 0.</span></span><br><span class="line">    uptr n = out_end - out_buf - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">internal_strncpy</span>(out_buf, frame_desc.<span class="built_in">data</span>(), n);</span><br><span class="line">    out_buf += __sanitizer::<span class="built_in">Min</span>&lt;uptr&gt;(n, frame_desc.<span class="built_in">length</span>());</span><br><span class="line">    *out_buf++ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK</span>(out_buf &lt;= out_end);</span><br><span class="line">  *out_buf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时插桩的主要工作有上述的API完成</p>
<br>

<h4 id="sanitizer-cov-trace-pc-guard-init"><a href="#sanitizer-cov-trace-pc-guard-init" class="headerlink" title="__sanitizer_cov_trace_pc_guard_init"></a>__sanitizer_cov_trace_pc_guard_init</h4><p>另外还有一个与上述API配套的函数<code>__sanitizer_cov_trace_pc_guard_init</code></p>
<p>上文提到的<code>__sanitizer_cov_trace_pc_*</code>支持用户自定义的API，这里依旧查看下LLVM的源码中的默认版本，定义位置：…&#x2F;compiler-rt\lib\fuzzer\dataflow\DataFlowCallbacks.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(__dft.NumFuncs == <span class="number">0</span> &amp;&amp; <span class="string">&quot;This tool does not support DSOs&quot;</span>);</span><br><span class="line">  <span class="built_in">assert</span>(start &lt; stop &amp;&amp; <span class="string">&quot;The code is not instrumented for coverage&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  GuardsBeg = start;</span><br><span class="line">  GuardsEnd = stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>start</code>记录着插桩起始位置的指针，<code>stop</code>记录着插桩结束位置的指针</p>
<br>

<h5 id="自定义1-sanitizer-cov-trace-pc-guard-init"><a href="#自定义1-sanitizer-cov-trace-pc-guard-init" class="headerlink" title="自定义1 __sanitizer_cov_trace_pc_guard_init"></a>自定义1 __sanitizer_cov_trace_pc_guard_init</h5><p>文档给出了一个自定义版本的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第5行的语句同LLVM提供的默认版本一致的，因此是固定的不好变动</p>
</li>
<li><p>其中多了的功能是第6行位置的for循环则是遍历start~stop将插桩的总数记录在<code>static uint64_t N</code>，<strong>两个指针进行简单运算即可得到当前程序的所有分支数</strong>。</p>
</li>
</ul>
<p>另外结合汤师兄的文章，这里并没有看到初始化start~stop内存区域的代码，但找到了如下的代码，可能是因为LLVM版本的原因吧（个人猜测）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_pcs_init(<span class="type">const</span> <span class="type">uintptr_t</span> *pcs_beg, <span class="type">const</span> <span class="type">uintptr_t</span> *pcs_end) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__dft.NumGuards) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  __dft.NumGuards = GuardsEnd - GuardsBeg;</span><br><span class="line">  __dft.PCsBeg = pcs_beg;</span><br><span class="line">  __dft.PCsEnd = pcs_end;</span><br><span class="line">  <span class="built_in">assert</span>(__dft.NumGuards == (__dft.PCsEnd - __dft.PCsBeg) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; __dft.NumGuards; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">BlockIsEntry</span>(i)) &#123;</span><br><span class="line">      __dft.NumFuncs++;</span><br><span class="line">      GuardsBeg[i] = __dft.NumFuncs;		<span class="comment">//初始化空间，写入插桩的ID</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __dft.BBExecuted = (<span class="type">bool</span>*)<span class="built_in">calloc</span>(__dft.NumGuards, <span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;INFO: %zd instrumented function(s) observed &quot;</span></span><br><span class="line">          <span class="string">&quot;and %zd basic blocks\n&quot;</span>, __dft.NumFuncs, __dft.NumGuards);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="self-defined-ver"><a href="#self-defined-ver" class="headerlink" title="self-defined-ver"></a>self-defined-ver</h3><p>微调整自定义版本，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ud_cb.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sanitizer All Coverage edges: 0x%d \n&quot;</span>, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// This function is a part of the sanitizer run-time.</span></span><br><span class="line">  <span class="comment">// To use it, link with AddressSanitizer or other sanitizer.</span></span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="built_in">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sancov-demo.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	a=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">function1</span>(a % <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">function2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -fsanitize-coverage=trace-pc-guard ./ud_cb.cc ./sancov-demo.cc -g -o ./c.out</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/7.png" class="">

<p>必要的注释在图片已经很好的注明，这里需要提的是，sancov-demo.cc中采取了随机数，因此，两个运行时可能出现执行路径的差异。抛开第一个main主干的插桩位置，function1 和function2中的插桩位置都可以得到相应的触发，并且合乎插桩总数7。</p>
<br>

<h3 id="self-defined-ver2"><a href="#self-defined-ver2" class="headerlink" title="self-defined-ver2"></a>self-defined-ver2</h3><p>添加覆盖率计算，代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> __BeExecuted_path=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> __Record_path=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++__Record_path;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sanitizer All Coverage edges: %d \n&quot;</span>, __Record_path);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// This function is a part of the sanitizer run-time.</span></span><br><span class="line">  <span class="comment">// To use it, link with AddressSanitizer or other sanitizer.</span></span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="built_in">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">  ++__BeExecuted_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	a=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">function1</span>(a % <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">function2</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Coverage Rate:%.2f Percent, (%d/%d)\n&quot;</span>, ((<span class="type">float</span>)__BeExecuted_path/(<span class="type">float</span>)__Record_path)*<span class="number">100</span>, __BeExecuted_path, __Record_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -fsanitize-coverage=trace-pc-guard ./sancov-demo.cc -g -o d.out</span></span><br></pre></td></tr></table></figure>

<p>运行</p>
<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/8.png" class="">

<p>可以看到，当随机出来的数使得程序执行进入function1，则代码覆盖率可以达到57.14%，进入function2 则是达到42.86%</p>
<br>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当启用了<code>-fsanitize-coverage=trace-pc-guard</code>，并且<code>-fsanitize=address</code>（或者其他运行时检测工具），则会相应的将<code>__sanitizer_symbolize_pc</code>插入程序中的所有分支</p>
<p>（ps：不指定限制范围的话 <code>-fsanitize-coverage-allowlist=allowlist.txt</code> and <code>-fsanitize-coverage-ignorelist=blocklist.txt</code>）</p>
<p>并至少调用一次<code>__sanitizer_cov_trace_pc_guard_init</code>完成对所有分支插桩的计数结果。</p>
<p>（ps：<code>-fsanitize-coverage</code>的插桩方式有几种：除上面提到的，还有inline-8bit-counters、inline-bool-flag、trace-pc等方式，具体说明参考文末贴出来的clang文档链接）</p>
<br>

<hr>
<br>

<h3 id="源码行为分析"><a href="#源码行为分析" class="headerlink" title="源码行为分析"></a>源码行为分析</h3><p>相信经过上文的实例分析，读者应该对clang的SanitizerCoverage有了一些理解，这里也想从源码深入解析SanitizerCoverage实施细节，这里参考了汤师兄的帖子：</p>
<blockquote>
<p>在阅读插桩代码之前简短提示下LLVM的Pass(优化模块)运行过程,插桩时一般用到ModulePass和FunctionPass。</p>
<p>如果对<strong>整个代码文件进行处理时</strong>，那就用到ModulePass对象;</p>
<p>如果<strong>对所有函数都处理</strong>，那就用到FunctionPass.  </p>
</blockquote>
<br>

<h4 id="PassManager"><a href="#PassManager" class="headerlink" title="PassManager"></a>PassManager</h4><p><code>PassManager</code>控制所有Pass的执行过程.，<code>PassManager</code>定义位置：..\llvm-project-llvmorg-9.0.1-rc1\llvm\include\llvm\Pass.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Different types of internal pass managers. External pass managers</span></span><br><span class="line"><span class="comment">/// (PassManager and FunctionPassManager) are not represented here.</span></span><br><span class="line"><span class="comment">/// Ordering of pass manager types is important here.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PassManagerType</span> &#123;</span><br><span class="line">  PMT_Unknown = <span class="number">0</span>,</span><br><span class="line">  PMT_ModulePassManager = <span class="number">1</span>, <span class="comment">///&lt; MPPassManager</span></span><br><span class="line">  PMT_CallGraphPassManager,  <span class="comment">///&lt; CGPassManager</span></span><br><span class="line">  PMT_FunctionPassManager,   <span class="comment">///&lt; FPPassManager</span></span><br><span class="line">  PMT_LoopPassManager,       <span class="comment">///&lt; LPPassManager</span></span><br><span class="line">  PMT_RegionPassManager,     <span class="comment">///&lt; RGPassManager</span></span><br><span class="line">  PMT_BasicBlockPassManager, <span class="comment">///&lt; BBPassManager</span></span><br><span class="line">  PMT_Last</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="FunctionPass-amp-FunctionPass"><a href="#FunctionPass-amp-FunctionPass" class="headerlink" title="FunctionPass &amp; FunctionPass"></a>FunctionPass &amp; FunctionPass</h4><p>这里我们分析下初步对比下<code>FunctionPass</code>&amp;<code>FunctionPass</code>，位置都在D:\workspace\source\llvm-project-llvmorg-9.0.1-rc1\llvm\include\llvm\Pass.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// FunctionPass class - This class is used to implement most global</span></span><br><span class="line"><span class="comment">/// optimizations.  Optimizations should subclass this class if they meet the</span></span><br><span class="line"><span class="comment">/// following constraints:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  1. Optimizations are organized globally, i.e., a function at a time</span></span><br><span class="line"><span class="comment">///  2. Optimizing a function does not cause the addition or removal of any</span></span><br><span class="line"><span class="comment">///     functions in the module</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionPass</span> : <span class="keyword">public</span> Pass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FunctionPass</span><span class="params">(<span class="type">char</span> &amp;pid)</span> : Pass(PT_Function, pid) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// createPrinterPass - Get a function printer pass.</span></span><br><span class="line">  <span class="function">Pass *<span class="title">createPrinterPass</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::string &amp;Banner)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// runOnFunction - Virtual method overriden by subclasses to do the</span></span><br><span class="line">  <span class="comment">/// per-function processing of the pass.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">assignPassManager</span><span class="params">(PMStack &amp;PMS, PassManagerType T)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///  Return what kind of Pass Manager can manage this pass.</span></span><br><span class="line">  <span class="function">PassManagerType <span class="title">getPotentialPassManagerType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/// Optional passes call this function to check whether the pass should be</span></span><br><span class="line">  <span class="comment">/// skipped. This is the case when Attribute::OptimizeNone is set or when</span></span><br><span class="line">  <span class="comment">/// optimization bisect is over the limit.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">skipFunction</span><span class="params">(<span class="type">const</span> Function &amp;F)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="ModulePass"><a href="#ModulePass" class="headerlink" title="ModulePass"></a>ModulePass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ModulePass class - This class is used to implement unstructured</span></span><br><span class="line"><span class="comment">/// interprocedural optimizations and analyses.  ModulePasses may do anything</span></span><br><span class="line"><span class="comment">/// they want to the program.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModulePass</span> : <span class="keyword">public</span> Pass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ModulePass</span><span class="params">(<span class="type">char</span> &amp;pid)</span> : Pass(PT_Module, pid) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force out-of-line virtual method.</span></span><br><span class="line">  ~<span class="built_in">ModulePass</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// createPrinterPass - Get a module printer pass.</span></span><br><span class="line">  <span class="function">Pass *<span class="title">createPrinterPass</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::string &amp;Banner)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span></span><br><span class="line">  <span class="comment">/// 子类覆写该方法去处理相应的module</span></span><br><span class="line">  <span class="comment">/// being operated on.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> </span>= <span class="number">0</span>;	</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">assignPassManager</span><span class="params">(PMStack &amp;PMS, PassManagerType T)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///  Return what kind of Pass Manager can manage this pass.</span></span><br><span class="line">  <span class="function">PassManagerType <span class="title">getPotentialPassManagerType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/// Optional passes call this function to check whether the pass should be</span></span><br><span class="line">  <span class="comment">/// skipped. This is the case when optimization bisect is over the limit.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">skipModule</span><span class="params">(Module &amp;M)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合二者的比对内容，加上从注释中不难判断，主体实现是由<code>RunOnModule</code>完成。这里以MoudlePass接着分析</p>
<br>

<h5 id="RunOnModule"><a href="#RunOnModule" class="headerlink" title="RunOnModule"></a>RunOnModule</h5><p>顺藤摸瓜，查找<code>runOnModule</code>方法，结果如下：</p>
<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/9.png" class="">

<p>可以看到，有许多结果，需要明确的一点是，我们讨论的是插桩过程，因此定位源文件路径中的Instrumentation到相关的，这里我们进入到SanitizerCoverage.cpp中，接着看到了有存在上述类的子类，并且也覆写了相应的方法，代码位置在<code>..\\llvm\lib\Transforms\Instrumentation\SanitizerCoverage.cpp</code>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SanitizerCoverageModule::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Options.CoverageType == SanitizerCoverageOptions::SCK_None)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  C = &amp;(M.<span class="built_in">getContext</span>());</span><br><span class="line">  DL = &amp;M.<span class="built_in">getDataLayout</span>();</span><br><span class="line">  CurModule = &amp;M;</span><br><span class="line">  CurModuleUniqueId = <span class="built_in">getUniqueModuleId</span>(CurModule);</span><br><span class="line">  TargetTriple = <span class="built_in">Triple</span>(M.<span class="built_in">getTargetTriple</span>());</span><br><span class="line">  FunctionGuardArray = <span class="literal">nullptr</span>;</span><br><span class="line">  Function8bitCounterArray = <span class="literal">nullptr</span>;</span><br><span class="line">  FunctionPCsArray = <span class="literal">nullptr</span>;</span><br><span class="line">  IntptrTy = Type::<span class="built_in">getIntNTy</span>(*C, DL-&gt;<span class="built_in">getPointerSizeInBits</span>());</span><br><span class="line">  IntptrPtrTy = PointerType::<span class="built_in">getUnqual</span>(IntptrTy);</span><br><span class="line">  Type *VoidTy = Type::<span class="built_in">getVoidTy</span>(*C);</span><br><span class="line">  IRBuilder&lt;&gt; <span class="built_in">IRB</span>(*C);</span><br><span class="line">  Int64PtrTy = PointerType::<span class="built_in">getUnqual</span>(IRB.<span class="built_in">getInt64Ty</span>());</span><br><span class="line">  Int32PtrTy = PointerType::<span class="built_in">getUnqual</span>(IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line">  Int8PtrTy = PointerType::<span class="built_in">getUnqual</span>(IRB.<span class="built_in">getInt8Ty</span>());</span><br><span class="line">  Int64Ty = IRB.<span class="built_in">getInt64Ty</span>();</span><br><span class="line">  Int32Ty = IRB.<span class="built_in">getInt32Ty</span>();</span><br><span class="line">  Int16Ty = IRB.<span class="built_in">getInt16Ty</span>();</span><br><span class="line">  Int8Ty = IRB.<span class="built_in">getInt8Ty</span>();</span><br><span class="line"></span><br><span class="line">  SanCovTracePCIndir =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTracePCIndirName, VoidTy, IntptrTy);</span><br><span class="line">  <span class="comment">// Make sure smaller parameters are zero-extended to i64 as required by the</span></span><br><span class="line">  <span class="comment">// x86_64 ABI.</span></span><br><span class="line">  AttributeList SanCovTraceCmpZeroExtAL;</span><br><span class="line">  <span class="keyword">if</span> (TargetTriple.<span class="built_in">getArch</span>() == Triple::x86_64) &#123;</span><br><span class="line">    SanCovTraceCmpZeroExtAL =</span><br><span class="line">        SanCovTraceCmpZeroExtAL.<span class="built_in">addParamAttribute</span>(*C, <span class="number">0</span>, Attribute::ZExt);</span><br><span class="line">    SanCovTraceCmpZeroExtAL =</span><br><span class="line">        SanCovTraceCmpZeroExtAL.<span class="built_in">addParamAttribute</span>(*C, <span class="number">1</span>, Attribute::ZExt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SanCovTraceCmpFunction[<span class="number">0</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp1, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                            IRB.<span class="built_in">getInt8Ty</span>(), IRB.<span class="built_in">getInt8Ty</span>());</span><br><span class="line">  SanCovTraceCmpFunction[<span class="number">1</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp2, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                            IRB.<span class="built_in">getInt16Ty</span>(), IRB.<span class="built_in">getInt16Ty</span>());</span><br><span class="line">  SanCovTraceCmpFunction[<span class="number">2</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp4, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                            IRB.<span class="built_in">getInt32Ty</span>(), IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line">  SanCovTraceCmpFunction[<span class="number">3</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp8, VoidTy, Int64Ty, Int64Ty);</span><br><span class="line"></span><br><span class="line">  SanCovTraceConstCmpFunction[<span class="number">0</span>] = M.<span class="built_in">getOrInsertFunction</span>(</span><br><span class="line">      SanCovTraceConstCmp1, SanCovTraceCmpZeroExtAL, VoidTy, Int8Ty, Int8Ty);</span><br><span class="line">  SanCovTraceConstCmpFunction[<span class="number">1</span>] = M.<span class="built_in">getOrInsertFunction</span>(</span><br><span class="line">      SanCovTraceConstCmp2, SanCovTraceCmpZeroExtAL, VoidTy, Int16Ty, Int16Ty);</span><br><span class="line">  SanCovTraceConstCmpFunction[<span class="number">2</span>] = M.<span class="built_in">getOrInsertFunction</span>(</span><br><span class="line">      SanCovTraceConstCmp4, SanCovTraceCmpZeroExtAL, VoidTy, Int32Ty, Int32Ty);</span><br><span class="line">  SanCovTraceConstCmpFunction[<span class="number">3</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceConstCmp8, VoidTy, Int64Ty, Int64Ty);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    AttributeList AL;</span><br><span class="line">    <span class="keyword">if</span> (TargetTriple.<span class="built_in">getArch</span>() == Triple::x86_64)</span><br><span class="line">      AL = AL.<span class="built_in">addParamAttribute</span>(*C, <span class="number">0</span>, Attribute::ZExt);</span><br><span class="line">    SanCovTraceDivFunction[<span class="number">0</span>] =</span><br><span class="line">        M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceDiv4, AL, VoidTy, IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  SanCovTraceDivFunction[<span class="number">1</span>] =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceDiv8, VoidTy, Int64Ty);</span><br><span class="line">  SanCovTraceGepFunction =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceGep, VoidTy, IntptrTy);</span><br><span class="line">  SanCovTraceSwitchFunction =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceSwitchName, VoidTy, Int64Ty, Int64PtrTy);</span><br><span class="line"></span><br><span class="line">  Constant *SanCovLowestStackConstant =</span><br><span class="line">      M.<span class="built_in">getOrInsertGlobal</span>(SanCovLowestStackName, IntptrTy);</span><br><span class="line">  SanCovLowestStack = <span class="built_in">dyn_cast</span>&lt;GlobalVariable&gt;(SanCovLowestStackConstant);</span><br><span class="line">  <span class="keyword">if</span> (!SanCovLowestStack) &#123;</span><br><span class="line">    C-&gt;<span class="built_in">emitError</span>(<span class="built_in">StringRef</span>(<span class="string">&quot;&#x27;&quot;</span>) + SanCovLowestStackName +</span><br><span class="line">                 <span class="string">&quot;&#x27; should not be declared by the user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SanCovLowestStack-&gt;<span class="built_in">setThreadLocalMode</span>(</span><br><span class="line">      GlobalValue::ThreadLocalMode::InitialExecTLSModel);</span><br><span class="line">  <span class="keyword">if</span> (Options.StackDepth &amp;&amp; !SanCovLowestStack-&gt;<span class="built_in">isDeclaration</span>())</span><br><span class="line">    SanCovLowestStack-&gt;<span class="built_in">setInitializer</span>(Constant::<span class="built_in">getAllOnesValue</span>(IntptrTy));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We insert an empty inline asm after cov callbacks to avoid callback merge.</span></span><br><span class="line">  EmptyAsm = InlineAsm::<span class="built_in">get</span>(FunctionType::<span class="built_in">get</span>(IRB.<span class="built_in">getVoidTy</span>(), <span class="literal">false</span>),</span><br><span class="line">                            <span class="built_in">StringRef</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">StringRef</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">                            <span class="comment">/*hasSideEffects=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  SanCovTracePC = M.<span class="built_in">getOrInsertFunction</span>(SanCovTracePCName, VoidTy);</span><br><span class="line">  SanCovTracePCGuard =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTracePCGuardName, VoidTy, Int32PtrTy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">    <span class="built_in">runOnFunction</span>(F);</span><br><span class="line"></span><br><span class="line">  Function *Ctor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FunctionGuardArray)</span><br><span class="line">    Ctor = <span class="built_in">CreateInitCallsForSections</span>(M, SanCovModuleCtorTracePcGuardName,</span><br><span class="line">                                      SanCovTracePCGuardInitName, Int32PtrTy,</span><br><span class="line">                                      SanCovGuardsSectionName);</span><br><span class="line">  <span class="keyword">if</span> (Function8bitCounterArray)</span><br><span class="line">    Ctor = <span class="built_in">CreateInitCallsForSections</span>(M, SanCovModuleCtor8bitCountersName,</span><br><span class="line">                                      SanCov8bitCountersInitName, Int8PtrTy,</span><br><span class="line">                                      SanCovCountersSectionName);</span><br><span class="line">  <span class="keyword">if</span> (Ctor &amp;&amp; Options.PCTable) &#123;</span><br><span class="line">    <span class="keyword">auto</span> SecStartEnd = <span class="built_in">CreateSecStartEnd</span>(M, SanCovPCsSectionName, IntptrPtrTy);</span><br><span class="line">    FunctionCallee InitFunction = <span class="built_in">declareSanitizerInitFunction</span>(</span><br><span class="line">        M, SanCovPCsInitName, &#123;IntptrPtrTy, IntptrPtrTy&#125;);</span><br><span class="line">    IRBuilder&lt;&gt; <span class="built_in">IRBCtor</span>(Ctor-&gt;<span class="built_in">getEntryBlock</span>().<span class="built_in">getTerminator</span>());</span><br><span class="line">    IRBCtor.<span class="built_in">CreateCall</span>(InitFunction, &#123;SecStartEnd.first, SecStartEnd.second&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We don&#x27;t reference these arrays directly in any of our runtime functions,</span></span><br><span class="line">  <span class="comment">// so we need to prevent them from being dead stripped.</span></span><br><span class="line">  <span class="keyword">if</span> (TargetTriple.<span class="built_in">isOSBinFormatMachO</span>())</span><br><span class="line">    <span class="built_in">appendToUsed</span>(M, GlobalsToAppendToUsed);</span><br><span class="line">  <span class="built_in">appendToCompilerUsed</span>(M, GlobalsToAppendToCompilerUsed);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上述代码的许多工作完成的是执行上下文的内容获取。有许多根据插桩点特征设置的内容，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SanCovTraceCmpFunction[<span class="number">0</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp1, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt8Ty</span>(), IRB.<span class="built_in">getInt8Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">1</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp2, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt16Ty</span>(), IRB.<span class="built_in">getInt16Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">2</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp4, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt32Ty</span>(), IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">3</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp8, VoidTy, Int64Ty, Int64Ty);</span><br></pre></td></tr></table></figure>

<p><code>8-16-32-64</code>，感觉像是做了cmp指令内容的相关部分长度做了区分而设置的，再比如下边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SanCovTraceDivFunction[<span class="number">1</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceDiv8, VoidTy, Int64Ty);</span><br><span class="line">SanCovTraceGepFunction =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceGep, VoidTy, IntptrTy);</span><br><span class="line">SanCovTraceSwitchFunction =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceSwitchName, VoidTy, Int64Ty, Int64PtrTy);</span><br></pre></td></tr></table></figure>

<p><code>div - Gep - switch</code>等都是根据指令进行区分做的相关列表内容插入。其中在文档阅读中有记得相关的内容，比如：</p>
<blockquote>
<p> <code>-fsanitize-coverage=trace-gep</code> – the <a target="_blank" rel="noopener" href="https://llvm.org/docs/GetElementPtr.html">LLVM GEP instructions</a> (to capture array indices)</p>
</blockquote>
<p>因此，我们应当知道，这里是根据代码覆盖率插桩的方式进行相应的处理，相关的的编译参数是<code>-fsanitize-coverage</code> 描述：Specify the type of coverage instrumentation for Sanitizers</p>
<br>



<h6 id="getOrInsertFunction"><a href="#getOrInsertFunction" class="headerlink" title="getOrInsertFunction"></a>getOrInsertFunction</h6><p>因此需要进一步查看API <code>getOrInsertFunction</code>的行为，LLVM根据参数的有无分为三个不同的版本，D:\workspace\source\llvm-project-llvmorg-9.0.1-rc1\llvm\include\llvm\IR\Module.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunctionCallee <span class="title">getOrInsertFunction</span><span class="params">(StringRef Name, FunctionType *T, AttributeList AttributeList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FunctionCallee <span class="title">getOrInsertFunction</span><span class="params">(StringRef Name, FunctionType *T)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同文件下的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Look up the specified function in the module symbol table. If it does not</span></span><br><span class="line"><span class="comment">/// exist, add a prototype for the function and return it. This function</span></span><br><span class="line"><span class="comment">/// guarantees to return a constant of pointer to the specified function type</span></span><br><span class="line"><span class="comment">/// or a ConstantExpr BitCast of that type if the named function has a</span></span><br><span class="line"><span class="comment">/// different type. This version of the method takes a list of</span></span><br><span class="line"><span class="comment">/// function arguments, which makes it easier for clients to use.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ArgsTy&gt;</span><br><span class="line"><span class="function">FunctionCallee <span class="title">getOrInsertFunction</span><span class="params">(StringRef Name, </span></span></span><br><span class="line"><span class="params"><span class="function">			AttributeList AttributeList, Type *RetTy, ArgsTy... Args)</span> </span>&#123;</span><br><span class="line">	SmallVector&lt;Type*, <span class="keyword">sizeof</span>...(ArgsTy)&gt; ArgTys&#123;Args...&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getOrInsertFunction</span>(Name,</span><br><span class="line">	FunctionType::<span class="built_in">get</span>(RetTy, ArgTys, <span class="literal">false</span>), AttributeList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Same as above, but without the attributes.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ArgsTy&gt;</span><br><span class="line"><span class="function">FunctionCallee <span class="title">getOrInsertFunction</span><span class="params">(StringRef Name, Type *RetTy, ArgsTy... Args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getOrInsertFunction</span>(Name, AttributeList&#123;&#125;, RetTy, Args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Avoid an incorrect ordering that&#x27;d otherwise compile incorrectly.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ArgsTy&gt;</span><br><span class="line"><span class="function">FunctionCallee <span class="title">getOrInsertFunction</span><span class="params">(StringRef Name, AttributeList AttributeList,</span></span></span><br><span class="line"><span class="params"><span class="function">                      FunctionType *Invalid, ArgsTy... Args)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Look up the specified function in the module symbol table. If it does not</span></span><br><span class="line"><span class="comment">/// exist, return null.</span></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(StringRef Name)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>D:\workspace\source\llvm-project-llvmorg-9.0.1-rc1\llvm\lib\IR\Module.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunctionCallee <span class="title">Module::getOrInsertFunction</span><span class="params">(StringRef Name, FunctionType *Ty,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           AttributeList AttributeList)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See if we have a definition for the specified function already.</span></span><br><span class="line">  GlobalValue *F = <span class="built_in">getNamedValue</span>(Name);</span><br><span class="line">  <span class="keyword">if</span> (!F) &#123;</span><br><span class="line">    <span class="comment">// Nope, add it</span></span><br><span class="line">    Function *New = Function::<span class="built_in">Create</span>(Ty, GlobalVariable::ExternalLinkage,</span><br><span class="line">                                     DL.<span class="built_in">getProgramAddressSpace</span>(), Name);</span><br><span class="line">    <span class="keyword">if</span> (!New-&gt;<span class="built_in">isIntrinsic</span>())       <span class="comment">// Intrinsics get attrs set on construction</span></span><br><span class="line">      New-&gt;<span class="built_in">setAttributes</span>(AttributeList);</span><br><span class="line">    FunctionList.<span class="built_in">push_back</span>(New);</span><br><span class="line">    <span class="keyword">return</span> &#123;Ty, New&#125;; <span class="comment">// Return the new prototype.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the function exists but has the wrong type, return a bitcast to the</span></span><br><span class="line">  <span class="comment">// right type.</span></span><br><span class="line">  <span class="keyword">auto</span> *PTy = PointerType::<span class="built_in">get</span>(Ty, F-&gt;<span class="built_in">getAddressSpace</span>());</span><br><span class="line">  <span class="keyword">if</span> (F-&gt;<span class="built_in">getType</span>() != PTy)</span><br><span class="line">    <span class="keyword">return</span> &#123;Ty, ConstantExpr::<span class="built_in">getBitCast</span>(F, PTy)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, we just found the existing function or a prototype.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;Ty, F&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>getOrInsertFunction</code>本体的第11行，当新的应插桩位置出现，则将至记录到相应的<code>FunctionList</code>，这个结构应该是记录插桩位置的。</p>
<p>也就是RunOnModule在执行类似如下的<code>getOrInsertFunction</code>的行为，以<code>SanCovTracePCIndir</code>为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SanCovTracePCIndir =</span><br><span class="line">      M.<span class="built_in">getOrInsertFunction</span>(SanCovTracePCIndirName, VoidTy, IntptrTy);</span><br></pre></td></tr></table></figure>

<p>其中<code>SanCovTracePCIndirName</code>的定义在D:\workspace\source\llvm-project-llvmorg-9.0.1-rc1\llvm\lib\Transforms\Instrumentation\SanitizerCoverage.cpp 的以下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> SanCovTracePCIndirName =</span><br><span class="line">    <span class="string">&quot;__sanitizer_cov_trace_pc_indir&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>应该是当<code>-fsanitize-coverage=indirec-calls</code>，记录每个间接call的位置，也就是应当插入<code>__sanitizer_cov_trace_pc_indir</code>插桩回调函数的位置，将至记录在相应的<code>FunctionList </code>里。</p>
<p>仔细发现，<code>RunOnModule</code>中有许多调用了<code>getOrInsertFunction</code>的地方，实际上都是根据-fsanitize-coverage的值完成需要进行插桩的位置的遍历将其记录到相应的<code>FunctionList</code>里的。</p>
<p>具体插桩的可选项在LLVM文档中有所描述：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow">Click Me</a></p>
<br>

<h6 id="runOnFunction"><a href="#runOnFunction" class="headerlink" title="runOnFunction"></a>runOnFunction</h6><p>遍历完所有需要插桩的位置并记录到相应的之后<code>FunctionList</code>之后，在<code>RunOnModule</code>还看到如下代码：</p>
<p>在上述<code>runOnModule</code>的代码中，获取LLVM中的一些变量并根据插桩方式将需要插桩的位置根据类别写入到传入的参数<code>Module &amp;M</code>，并且遍历完所有需要插桩的位置之后，看到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">	<span class="built_in">runOnFunction</span>(F);</span><br></pre></td></tr></table></figure>

<p>不难联想这是在遍历先前分类写到M中的需要进行插桩的function位置，估计是插桩的实施步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SanitizerCoverageModule::runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">getName</span>().<span class="built_in">find</span>(<span class="string">&quot;.module_ctor&quot;</span>) != std::string::npos)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Should not instrument sanitizer init functions.</span></span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">getName</span>().<span class="built_in">startswith</span>(<span class="string">&quot;__sanitizer_&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// Don&#x27;t instrument __sanitizer_* callbacks.</span></span><br><span class="line">  <span class="comment">// Don&#x27;t touch available_externally functions, their actual body is elewhere.</span></span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">getLinkage</span>() == GlobalValue::AvailableExternallyLinkage)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Don&#x27;t instrument MSVC CRT configuration helpers. They may run before normal</span></span><br><span class="line">  <span class="comment">// initialization.</span></span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">getName</span>() == <span class="string">&quot;__local_stdio_printf_options&quot;</span> ||</span><br><span class="line">      F.<span class="built_in">getName</span>() == <span class="string">&quot;__local_stdio_scanf_options&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;UnreachableInst&gt;(F.<span class="built_in">getEntryBlock</span>().<span class="built_in">getTerminator</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Don&#x27;t instrument functions using SEH for now. Splitting basic blocks like</span></span><br><span class="line">  <span class="comment">// we do for coverage breaks WinEHPrepare.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> Remove this when SEH no longer uses landingpad pattern matching.</span></span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">hasPersonalityFn</span>() &amp;&amp;</span><br><span class="line">      <span class="built_in">isAsynchronousEHPersonality</span>(<span class="built_in">classifyEHPersonality</span>(F.<span class="built_in">getPersonalityFn</span>())))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (Options.CoverageType &gt;= SanitizerCoverageOptions::SCK_Edge)</span><br><span class="line">    <span class="built_in">SplitAllCriticalEdges</span>(F, <span class="built_in">CriticalEdgeSplittingOptions</span>().<span class="built_in">setIgnoreUnreachableDests</span>());</span><br><span class="line">    <span class="comment">//以上的内容是避开许多不需要插桩的</span></span><br><span class="line">    </span><br><span class="line">  SmallVector&lt;Instruction *, <span class="number">8</span>&gt; IndirCalls;		</span><br><span class="line">  SmallVector&lt;BasicBlock *, <span class="number">16</span>&gt; BlocksToInstrument;		</span><br><span class="line">  SmallVector&lt;Instruction *, <span class="number">8</span>&gt; CmpTraceTargets;	<span class="comment">//</span></span><br><span class="line">  SmallVector&lt;Instruction *, <span class="number">8</span>&gt; SwitchTraceTargets;</span><br><span class="line">  SmallVector&lt;BinaryOperator *, <span class="number">8</span>&gt; DivTraceTargets;</span><br><span class="line">  SmallVector&lt;GetElementPtrInst *, <span class="number">8</span>&gt; GepTraceTargets;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> DominatorTree *DT =</span><br><span class="line">      &amp;<span class="built_in">getAnalysis</span>&lt;DominatorTreeWrapperPass&gt;(F).<span class="built_in">getDomTree</span>();</span><br><span class="line">  <span class="type">const</span> PostDominatorTree *PDT =</span><br><span class="line">      &amp;<span class="built_in">getAnalysis</span>&lt;PostDominatorTreeWrapperPass&gt;(F).<span class="built_in">getPostDomTree</span>();</span><br><span class="line">  <span class="type">bool</span> IsLeafFunc = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shouldInstrumentBlock</span>(F, &amp;BB, DT, PDT, Options))</span><br><span class="line">      BlocksToInstrument.<span class="built_in">push_back</span>(&amp;BB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Inst : BB) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Options.IndirectCalls) &#123;</span><br><span class="line">        <span class="function">CallSite <span class="title">CS</span><span class="params">(&amp;Inst)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (CS &amp;&amp; !CS.<span class="built_in">getCalledFunction</span>())</span><br><span class="line">          IndirCalls.<span class="built_in">push_back</span>(&amp;Inst);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Options.TraceCmp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ICmpInst *CMP = <span class="built_in">dyn_cast</span>&lt;ICmpInst&gt;(&amp;Inst))</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">IsInterestingCmp</span>(CMP, DT, Options))</span><br><span class="line">            CmpTraceTargets.<span class="built_in">push_back</span>(&amp;Inst);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;SwitchInst&gt;(&amp;Inst))</span><br><span class="line">          SwitchTraceTargets.<span class="built_in">push_back</span>(&amp;Inst);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Options.TraceDiv)</span><br><span class="line">        <span class="keyword">if</span> (BinaryOperator *BO = <span class="built_in">dyn_cast</span>&lt;BinaryOperator&gt;(&amp;Inst))</span><br><span class="line">          <span class="keyword">if</span> (BO-&gt;<span class="built_in">getOpcode</span>() == Instruction::SDiv ||</span><br><span class="line">              BO-&gt;<span class="built_in">getOpcode</span>() == Instruction::UDiv)</span><br><span class="line">            DivTraceTargets.<span class="built_in">push_back</span>(BO);</span><br><span class="line">      <span class="keyword">if</span> (Options.TraceGep)</span><br><span class="line">        <span class="keyword">if</span> (GetElementPtrInst *GEP = <span class="built_in">dyn_cast</span>&lt;GetElementPtrInst&gt;(&amp;Inst))</span><br><span class="line">          GepTraceTargets.<span class="built_in">push_back</span>(GEP);</span><br><span class="line">      <span class="keyword">if</span> (Options.StackDepth)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;InvokeInst&gt;(Inst) ||</span><br><span class="line">            (<span class="built_in">isa</span>&lt;CallInst&gt;(Inst) &amp;&amp; !<span class="built_in">isa</span>&lt;IntrinsicInst&gt;(Inst)))</span><br><span class="line">          IsLeafFunc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InjectCoverage</span>(F, BlocksToInstrument, IsLeafFunc);</span><br><span class="line">  <span class="built_in">InjectCoverageForIndirectCalls</span>(F, IndirCalls);</span><br><span class="line">  <span class="built_in">InjectTraceForCmp</span>(F, CmpTraceTargets);</span><br><span class="line">  <span class="built_in">InjectTraceForSwitch</span>(F, SwitchTraceTargets);</span><br><span class="line">  <span class="built_in">InjectTraceForDiv</span>(F, DivTraceTargets);</span><br><span class="line">  <span class="built_in">InjectTraceForGep</span>(F, GepTraceTargets);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第41-43行，遍历当前待插桩函数内的所有BasicBlock，记录应当插桩的BB</p>
</li>
<li><p>第44行，遍历所有BB，并根据指令的不同，进行不同的插桩行为</p>
</li>
<li><p>第45-49行，当<code>-fsanitize-coverage=indirect-calls</code>完成对indirect call的插桩</p>
</li>
<li><p>往后的内容，到第70行退出遍历，都是根据指令的不同，完成相应的插桩操作</p>
</li>
<li><p>第72-77行，根据指令执行相应的插桩代码，比如<code>InjectTraceForCmp</code>则是在<code>-fsanitize-coverage=trace-cmp</code>时会记录并完成插桩的，顺藤摸瓜，来到如下定义位置：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SanitizerCoverageModule::InjectTraceForCmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Function &amp;, ArrayRef&lt;Instruction *&gt; CmpTraceTargets)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> I : CmpTraceTargets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ICmpInst *ICMP = <span class="built_in">dyn_cast</span>&lt;ICmpInst&gt;(I)) &#123;</span><br><span class="line">      IRBuilder&lt;&gt; <span class="built_in">IRB</span>(ICMP);</span><br><span class="line">      Value *A0 = ICMP-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>);		<span class="comment">//比较指令的操作数1</span></span><br><span class="line">      Value *A1 = ICMP-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>);		<span class="comment">//比较指令的操作数2</span></span><br><span class="line">      <span class="keyword">if</span> (!A0-&gt;<span class="built_in">getType</span>()-&gt;<span class="built_in">isIntegerTy</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="type">uint64_t</span> TypeSize = DL-&gt;<span class="built_in">getTypeStoreSizeInBits</span>(A0-&gt;<span class="built_in">getType</span>());</span><br><span class="line">      <span class="type">int</span> CallbackIdx = TypeSize == <span class="number">8</span> ? <span class="number">0</span> :</span><br><span class="line">                        TypeSize == <span class="number">16</span> ? <span class="number">1</span> :</span><br><span class="line">                        TypeSize == <span class="number">32</span> ? <span class="number">2</span> :</span><br><span class="line">                        TypeSize == <span class="number">64</span> ? <span class="number">3</span> : <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (CallbackIdx &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// __sanitizer_cov_trace_cmp((type_size &lt;&lt; 32) | predicate, A0, A1);</span></span><br><span class="line">      <span class="keyword">auto</span> CallbackFunc = SanCovTraceCmpFunction[CallbackIdx];</span><br><span class="line">      <span class="type">bool</span> FirstIsConst = <span class="built_in">isa</span>&lt;ConstantInt&gt;(A0);</span><br><span class="line">      <span class="type">bool</span> SecondIsConst = <span class="built_in">isa</span>&lt;ConstantInt&gt;(A1);</span><br><span class="line">      <span class="comment">// If both are const, then we don&#x27;t need such a comparison.</span></span><br><span class="line">      <span class="keyword">if</span> (FirstIsConst &amp;&amp; SecondIsConst) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// If only one is const, then make it the first callback argument.</span></span><br><span class="line">      <span class="keyword">if</span> (FirstIsConst || SecondIsConst) &#123;</span><br><span class="line">        CallbackFunc = SanCovTraceConstCmpFunction[CallbackIdx];</span><br><span class="line">        <span class="keyword">if</span> (SecondIsConst)</span><br><span class="line">          std::<span class="built_in">swap</span>(A0, A1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> Ty = Type::<span class="built_in">getIntNTy</span>(*C, TypeSize);</span><br><span class="line">      IRB.<span class="built_in">CreateCall</span>(CallbackFunc, &#123;IRB.<span class="built_in">CreateIntCast</span>(A0, Ty, <span class="literal">true</span>),</span><br><span class="line">              IRB.<span class="built_in">CreateIntCast</span>(A1, Ty, <span class="literal">true</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第十行，说明即便是比较指令，内部还是有分类型进行插桩分类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp1(<span class="type">uint8_t</span> Arg1, <span class="type">uint8_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp2(<span class="type">uint16_t</span> Arg1, <span class="type">uint16_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp4(<span class="type">uint32_t</span> Arg1, <span class="type">uint32_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp8(<span class="type">uint64_t</span> Arg1, <span class="type">uint64_t</span> Arg2);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第17行，根据分类，调用相应的插桩回调函数，存放在<code>CallbackFunc</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SanCovTraceCmpFunction[<span class="number">0</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp1, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt8Ty</span>(), IRB.<span class="built_in">getInt8Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">1</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp2, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt16Ty</span>(), IRB.<span class="built_in">getInt16Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">2</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp4, SanCovTraceCmpZeroExtAL, VoidTy,</span><br><span class="line">                          IRB.<span class="built_in">getInt32Ty</span>(), IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line">SanCovTraceCmpFunction[<span class="number">3</span>] =</span><br><span class="line">    M.<span class="built_in">getOrInsertFunction</span>(SanCovTraceCmp8, VoidTy, Int64Ty, Int64Ty);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第30-31行，完成插桩，最后一步就是程序启动时插入对相应<code>__sanitizer_cov_trace_pc_guard_init</code>回调函数的调用</p>
</li>
</ul>
<p>大致示意图</p>
<img src="/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/10.png" class="">

<br>

<hr>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><ul>
<li>Function list</li>
<li>the module symbol table</li>
<li>…</li>
</ul>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>汤师兄的Github：<a target="_blank" rel="noopener" href="https://github.com/lcatro/Source-and-Fuzzing/blob/master/12.%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan.md">https://github.com/lcatro/Source-and-Fuzzing/blob/master/12.%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan.md</a></p>
<p>clang-doc：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">https://clang.llvm.org/docs/SanitizerCoverage.html</a></p>
<p>tracing data flow：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow">https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow</a></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Victory+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cvjark.github.io/2022/05/20/深入理解SanitizerCoverage实施/">https://cvjark.github.io/2022/05/20/深入理解SanitizerCoverage实施/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/libfuzzer%E7%B3%BB%E5%88%97/">libfuzzer系列</a><a class="post-meta__tags" href="/tags/fuzzing/">fuzzing</a><a class="post-meta__tags" href="/tags/LLVM/">LLVM</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-627db6d4a04365ef" async></script><nav id="pagination"></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://cvjark.github.io/2022/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SanitizerCoverage%E5%AE%9E%E6%96%BD/';
  this.page.identifier = '2022/05/20/深入理解SanitizerCoverage实施/';
  this.page.title = '深入理解SanitizerCoverage实施';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'https-cvjark-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://https-cvjark-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/mp/wallhaven-mpmoly.png)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Victory+</div><div class="framework-info"><span>Victory+</span><span class="footer-separator">❤</span><span>TBaozi</span></div><div class="footer_custom_text"><img src="https://ghchart.rshah.org/Cvjark" alt="Cvjark Github chart" /></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>