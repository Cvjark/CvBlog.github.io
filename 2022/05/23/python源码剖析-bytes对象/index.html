<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python源码剖析No.6--bytes对象"><meta name="keywords" content="Python源码剖析,源码"><meta name="author" content="Victory+"><meta name="copyright" content="Victory+"><title>python源码剖析No.6--bytes对象 | Victory+'s blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Victory+'s blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="当前文章概览">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">bytes对象定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.</span> <span class="toc-text">bytes对象行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">数值型操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">序列型操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">关联型操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">3.</span> <span class="toc-text">数据拷贝的陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8join%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">使用join方法实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">字符缓冲池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">疑问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%BD%A9%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">精彩面试题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Victory+</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链(欢迎扩列哟...)</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/lcatro">lcatro</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e71v2l.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Victory+'s blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a><a class="site-page" href="/todolist/">ToDoList</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">python源码剖析No.6--bytes对象</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/05/23/python源码剖析-bytes对象/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.8k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>不少编程语言中的<code>字符串</code>都是有<code>字符数组（又称字节序列）</code>来表示，比如C：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>由于<code>1 Byte</code> 占<code>8bit</code>空间，具有265种排列方式，因此单个字节的表现范围有限，对于英文字符以及常用的符号字符可能够，但为了兼容其他字符（伟大的汉字），计算机的先驱们发明了<code>多字节编码</code> – 通过多个字节来表示一个字符。</p>
<p>ps：这让我联想起python中实现大整数的方式了–串联多个C整型来表达。</p>
<p>Python提供的解决方案是<code>Unicode字符串（str）对象</code>，unicode 可以表示各种字符，无需关心编码。</p>
<p>然而，存储或者网络通讯时，字符串对象无法避免的需要<code>序列化</code>成字节序列进行传输。为此，python额外提供了<code>字节序列对象--bytes</code>。</p>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/1.png" class="">
<p>简单理解就是和用户做交互的是str对象，是所容易理解的。而和机器做交互则是越简单越好，因此是序列化后的字位码</p>
<p>本节所探讨的是python中的<code>bytes对象</code></p>
<h3 id="bytes对象定义">bytes对象定义</h3>
<p>python中的bytes对象定义在/Objects/bytesobject.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    Py_hash_t ob_shash;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyBytesObject;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Py_LIMITED_API</code>查到是和python版本挂钩的东西，这里不管。</p>
<p>可以看到<code>PyBytesObject</code>是变长对象，除了变长对象的共有头部<code>PyObject_VAR_HEAD</code>外，还提供了存放对象hash值结果的<code>ob_shash</code>字段，再就是存放bytes对象内容的<code>ob_sval</code>字符数组了。</p>
<p>从上述定义中相关的描述，我们还可以知道：</p>
<blockquote>
<ul>
<li>
<p><code>ob_sval</code>包含了<code>PyObject_VAR_HEAD.ob_size</code>长度+1个元素，且最后一个内容存放0，标志结束</p>
</li>
<li>
<p><code>ob_shash</code>使用来存放对象hash计算值的，当为-1时，说明尚未进行对象hash计算。之所以设置这个字段是由于python对象哈希值的应用范围很大，比如dict字典对象以来对象哈希值进行存储，由于便利计算bytes对象哈希值需要遍历其内部的字符数组，开销相对大，因此python选择将哈希值保存起来，以空间换时间，避免重复计算。（smart）</p>
</li>
</ul>
</blockquote>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/2.png" class="">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getsizeof(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#--------output-------#</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>从对象结构来回答这问题：</p>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/3.png" class="">
<p>python在分配bytes对象空间对于ob_sval的元素会多分配一个，用于存放<code>b'00'</code>，头部及ob_shash的每个字段占据8字节（64位系统下），因此大小为33</p>
<p>创建也是类似之前探讨过的对象：</p>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/4.png" class="">
<h3 id="bytes对象行为">bytes对象行为</h3>
<p>之前我们学习到探讨<strong>对象行为</strong>，需要从<strong>对象的类型</strong>出发，这里如出一辙，找到<code>PyBytes_Type</code>，定位到代码位置：/Objects/bytesobject.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBytes_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    PyBytesObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">    bytes_dealloc,                      <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)bytes_repr,                       <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;bytes_as_number,                           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;bytes_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;bytes_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)bytes_hash,                       <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    bytes_str,                                  <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    &amp;bytes_as_buffer,                           <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_BYTES_SUBCLASS,              <span class="comment">/* tp_flags */</span></span><br><span class="line">    bytes_doc,                                  <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    (richcmpfunc)bytes_richcompare,             <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    bytes_iter,                                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    bytes_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    &amp;PyBaseObject_Type,                         <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    bytes_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的<code>PyBytes_Type</code>构成，可以看出<code>PyBytesObject</code>支持的操作类型有数值型操作、序列型操作、关系型操作。</p>
<h4 id="数值型操作">数值型操作</h4>
<p>跟踪<code>bytes_as_number</code>字段，可以看到<code>bytes对象</code>支持的数值型操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods bytes_as_number = &#123;</span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_add*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">/*nb_multiply*/</span></span><br><span class="line">    bytes_mod,      <span class="comment">/*nb_remainder*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bytes对象</code>竟然可以进行数值型操作？！跟进查看：<code>bytes_mod</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_mod</span><span class="params">(PyObject *self, PyObject *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyBytes_Check(self)) &#123;		<span class="comment">//核实操作类型和方法是否配对</span></span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),</span><br><span class="line">                             arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键是<code>_PyBytes_FormatEx</code>，从名字上看，是做了类C的格式化输出。</p>
<h4 id="序列型操作">序列型操作</h4>
<p>跟踪<code>bytes_as_sequence</code>来到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PySequenceMethods bytes_as_sequence = &#123;</span><br><span class="line">    (lenfunc)bytes_length, <span class="comment">/*sq_length*/</span></span><br><span class="line">    (binaryfunc)bytes_concat, <span class="comment">/*sq_concat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_repeat, <span class="comment">/*sq_repeat*/</span></span><br><span class="line">    (ssizeargfunc)bytes_item, <span class="comment">/*sq_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_slice*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_item*/</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">/*sq_ass_slice*/</span></span><br><span class="line">    (objobjproc)bytes_contains <span class="comment">/*sq_contains*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相应字段不为空的则说明相应操作存在，比如<code>bytes_length</code>，跟进发现定义位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Py_ssize_t</span><br><span class="line"><span class="title function_">bytes_length</span><span class="params">(PyBytesObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_SIZE(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，是通过返回<code>PyVarObject.ob_size</code>来获取bytes对象的长度的.</p>
<p>再比如<code>bytes_concat</code>初看API名称，应该猜得出大概是bytes对象追加内容的功能，顺藤摸瓜</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is also used by PyBytes_Concat() */</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">bytes_concat</span><span class="params">(PyObject *a, PyObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_buffer va, vb;</span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    va.len = <span class="number">-1</span>;</span><br><span class="line">    vb.len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (PyObject_GetBuffer(a, &amp;va, PyBUF_SIMPLE) != <span class="number">0</span> ||</span><br><span class="line">        PyObject_GetBuffer(b, &amp;vb, PyBUF_SIMPLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError, <span class="string">&quot;can&#x27;t concat %.100s to %.100s&quot;</span>,</span><br><span class="line">                     Py_TYPE(b)-&gt;tp_name, Py_TYPE(a)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize end cases */</span></span><br><span class="line">    <span class="keyword">if</span> (va.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(b)) &#123;</span><br><span class="line">        result = b;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vb.len == <span class="number">0</span> &amp;&amp; PyBytes_CheckExact(a)) &#123;</span><br><span class="line">        result = a;</span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va.len &gt; PY_SSIZE_T_MAX - vb.len) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = PyBytes_FromStringAndSize(<span class="literal">NULL</span>, va.len + vb.len);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result), va.buf, va.len);</span><br><span class="line">        <span class="built_in">memcpy</span>(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">if</span> (va.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;va);</span><br><span class="line">    <span class="keyword">if</span> (vb.len != <span class="number">-1</span>)</span><br><span class="line">        PyBuffer_Release(&amp;vb);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第15行，之前完成的事两个临时对象的申请，规模同传递进来的两个操作对象，并填充进临时对象</li>
<li>第18-22行，当第一个操作对象va的长度为0，则函数执行结果为对象vb，进行返回</li>
<li>第23-27行，类似上面的过程。</li>
<li>第29-32行，判断va是否有充足的空间进行追加，不够则返回错误</li>
<li>第34-38行，重新申请足够大的bytes对象，逐一完成对象va vb内容的拷贝</li>
</ul>
<p>以上就是<code>bytes_concat</code>实现的细节了。至于bytes对象的其他序列型操作，读者可自行分析。</p>
<h4 id="关联型操作">关联型操作</h4>
<p>跟踪<code>bytes_as_mapping</code>字段，来到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyMappingMethods bytes_as_mapping = &#123;</span><br><span class="line">    (lenfunc)bytes_length,</span><br><span class="line">    (binaryfunc)bytes_subscript,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，支持的操作，第一个先前分析过的<code>bytes_length</code>还支持<code>bytes_subscript</code></p>
<h3 id="数据拷贝的陷阱">数据拷贝的陷阱</h3>
<p>考虑一下三个PyBytesObject的合并（concat）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a + b + c</span><br></pre></td></tr></table></figure>
<p>实际上在python内部运行如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = a + b</span><br><span class="line">result = tmp + c</span><br></pre></td></tr></table></figure>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/5.png" class="">
<p>类比的发现，随着待合并的内容越多，则开销会增大。（只有最后一个对象不会重复拷贝，其余对象会拷贝n-1次）</p>
<h4 id="使用join方法实现">使用join方法实现</h4>
<p>join方法对数据拷贝进行了优化：现遍历待合并对象，得到所有对象的<code>ob_size</code>，计算总长度。根据这个值创建长度合适的result对象存放结果，再遍历待合并对象，逐一拷贝数据。</p>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/6.png" class="">
<h3 id="字符缓冲池">字符缓冲池</h3>
<p>为了优化<code>单字节bytes对象</code>的创建效率，python内部维护了一个字符缓冲池，不同于小整数对象缓冲池的是字符缓冲池一开始为空的，随着运行逐渐添加，相关定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyBytesObject *characters[UCHAR_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>python内部创建单字节bytes对象时，先检查目标对象是否再缓冲池中。</p>
<p>根据注释内容，找得到相应的bytes对象创建方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   For PyBytes_FromString(), the parameter `str&#x27; points to a null-terminated</span></span><br><span class="line"><span class="comment">   string containing exactly `size&#x27; bytes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   For PyBytes_FromStringAndSize(), the parameter `str&#x27; is</span></span><br><span class="line"><span class="comment">   either NULL or else points to a string containing at least `size&#x27; bytes.</span></span><br><span class="line"><span class="comment">   For PyBytes_FromStringAndSize(), the string in the `str&#x27; parameter does</span></span><br><span class="line"><span class="comment">   not have to be null-terminated.  (Therefore it is safe to construct a</span></span><br><span class="line"><span class="comment">   substring by calling `PyBytes_FromStringAndSize(origstring, substrlen)&#x27;.)</span></span><br><span class="line"><span class="comment">   If `str&#x27; is NULL then PyBytes_FromStringAndSize() will allocate `size+1&#x27;</span></span><br><span class="line"><span class="comment">   bytes (setting the last byte to the null terminating character) and you can</span></span><br><span class="line"><span class="comment">   fill in the data yourself.  If `str&#x27; is non-NULL then the resulting</span></span><br><span class="line"><span class="comment">   PyBytes object must be treated as immutable and you must not fill in nor</span></span><br><span class="line"><span class="comment">   alter the data yourself, since the strings may be shared.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The PyObject member `op-&gt;ob_size&#x27;, which denotes the number of &quot;extra</span></span><br><span class="line"><span class="comment">   items&quot; in a variable-size object, will contain the number of bytes</span></span><br><span class="line"><span class="comment">   allocated for string data, not counting the null terminating character.</span></span><br><span class="line"><span class="comment">   It is therefore equal to the `size&#x27; parameter (for</span></span><br><span class="line"><span class="comment">   PyBytes_FromStringAndSize()) or the length of the string in the `str&#x27;</span></span><br><span class="line"><span class="comment">   parameter (for PyBytes_FromString()).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>python创建bytes对象使用的是<code>PyBytes_FromString</code>`PyBytes_FromStringAndSize`</p>
<p>先看第一个<code>PyBytes_FromString</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line"></span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX - PyBytesObject_SIZE) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            <span class="string">&quot;byte string is too long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; (op = nullstring) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        null_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;		<span class="comment">//PyBytesObject.ob_shash未计算</span></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        nullstring = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;			</span><br><span class="line">        <span class="comment">//执行到这里，说明单字节缓冲池中没有当前申请的单字节对象，因此放入单字节缓冲池中</span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到第21-27行，就是当创建的bytes对象是单字节，且在单字节缓冲池中，则直接添加缓冲池中目标的引用计数，随后返回。<code>one_strings</code>是用于计数当前单字节缓冲池的使用情况</p>
<p>在看第二个<code>PyBytes_FromStringAndSize</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyBytes_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyBytesObject *op;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">            <span class="string">&quot;Negative size passed to PyBytes_FromStringAndSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10-18行，对于单字节对象的创建类似。其中关键的语句是</p>
<p><code>if (size == 1 &amp;&amp; str != NULL &amp;&amp;(op = characters[*str &amp; UCHAR_MAX]) != NULL)</code>解释：当创建的是单字节对象 &amp;&amp; 内容是不为NULL &amp;&amp; 内容不在单字节缓冲池中。</p>
<h1>疑问</h1>
<p>但貌似没看到放入缓冲池的操作，先留个疑问吧。从代码上看貌似只是将缓冲池使用计数的<code>one_strings++</code>而已，后续在此分配怎么直接引用的？hash？</p>
<p>有没有老哥对于这点有思路的？</p>
<p>好吧，自己画了遍下边的示意图：</p>
<img src="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/7.png" class="">
<p>发现貌似自己能解答这个问题了（个人理解，可能存在错误），也不修改了，当作个纪念，告诉自己，勤动手才是正确的学习方法。</p>
<p>我们重新贴一遍单bytes对象创建的关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    one_strings++;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op = (PyBytesObject *)_PyBytes_FromSize(size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(op-&gt;ob_sval, str, size);</span><br><span class="line"><span class="comment">/* share short strings */</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>one_strings</code>是用于计数当前单字节缓冲池中的使用情况。python初始该值为0，随着运行的进行，每当单字节缓冲池中的内容被使用，则该计数+1，以上图为例，假设标记出的几个被使用了，且其他为NULL，则<code>one_strings = 1</code> ，<strong>为什么？</strong>，先留着疑问，我们往下看：</p>
<p><code>op = characters[*str &amp; UCHAR_MAX]) != NULL</code></p>
<p>由于单字节缓冲池中的数量是0-255（映射为ascii码）当创建的是单字节，就尝试进行与操作<code>characters[*str &amp; UCHAR_MAX]</code>，取出相应位置</p>
<ul>
<li>
<p>当为空，则说明缓冲池中该对象为NULL，则申请相应对象，并修改缓冲池中相应指向该对象</p>
</li>
<li>
<p>不为空，则说明缓冲池中有该对象则取出使用，<code>one_strings++</code></p>
</li>
</ul>
<hr>
<h3 id="精彩面试题">精彩面试题</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a1 = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; a2 = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; a1 is a2</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ab1 = b<span class="number">&#x27;</span>ab<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; ab2 = b<span class="number">&#x27;</span>ab<span class="number">&#x27;</span></span><br><span class="line">&gt;&gt;&gt; ab1 is ab2</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>导致上述现象存在的原因是由于python单字节缓冲池存在的原因</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Victory+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cvjark.github.io/2022/05/23/python源码剖析-bytes对象/">https://cvjark.github.io/2022/05/23/python源码剖析-bytes对象/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">Python源码剖析</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-627db6d4a04365ef" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/"><i class="fa fa-chevron-left">  </i><span>逆核系列No.18--TLS CallBackFunction</span></a></div><div class="next-post pull-right"><a href="/2022/05/17/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"><span>python源码剖析No.5--大整数运算</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://cvjark.github.io/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/';
  this.page.identifier = '2022/05/23/python源码剖析-bytes对象/';
  this.page.title = 'python源码剖析No.6--bytes对象';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'https-cvjark-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://https-cvjark-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e71v2l.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Victory+</div><div class="framework-info"><span>Victory+</span><span class="footer-separator">❤</span><span>TBaozi</span></div><div class="footer_custom_text"><img src="https://ghchart.rshah.org/Cvjark" alt="Cvjark Github chart" /></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>