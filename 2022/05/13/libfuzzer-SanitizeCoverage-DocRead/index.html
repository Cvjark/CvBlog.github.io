<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Clang-SanitizeCoverage-DocRead"><meta name="keywords" content="libfuzzer系列,Clang-Docs"><meta name="author" content="Victory+"><meta name="copyright" content="Victory+"><title>Clang-SanitizeCoverage-DocRead | Victory+'s blog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Victory+'s blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="当前文章概览">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage"><span class="toc-number">1.</span> <span class="toc-text">SanitizerCoverage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tracing-PCs-with-guards"><span class="toc-number">1.1.</span> <span class="toc-text">Tracing PCs with guards</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tracing-PCs"><span class="toc-number">1.2.</span> <span class="toc-text">Tracing PCs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E5%8D%95%E5%85%83"><span class="toc-number">1.3.</span> <span class="toc-text">插桩单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Edge-Coverage"><span class="toc-number">1.4.</span> <span class="toc-text">Edge Coverage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tracing-data-flow"><span class="toc-number">1.5.</span> <span class="toc-text">Tracing data flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disabling-instrumentation"><span class="toc-number">1.6.</span> <span class="toc-text">Disabling instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disabling-instrumentation-without-source-modification"><span class="toc-number">1.7.</span> <span class="toc-text">Disabling instrumentation without source modification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Default-implementation"><span class="toc-number">1.8.</span> <span class="toc-text">Default implementation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sancov-data-format"><span class="toc-number">1.9.</span> <span class="toc-text">Sancov data format</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sancov-Tool"><span class="toc-number">1.10.</span> <span class="toc-text">Sancov Tool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Coverage-Reports"><span class="toc-number">1.11.</span> <span class="toc-text">Coverage Reports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Output-directory"><span class="toc-number">1.12.</span> <span class="toc-text">Output directory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-number">2.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Victory+</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链(欢迎扩列哟...)</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/lcatro">lcatro</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/57/wallhaven-57oj29.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Victory+'s blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a><a class="site-page" href="/todolist/">ToDoList</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Clang-SanitizeCoverage-DocRead</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/fuzzer/">fuzzer</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/05/13/libfuzzer-SanitizeCoverage-DocRead/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.6k</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="SanitizerCoverage"><a href="#SanitizerCoverage" class="headerlink" title="SanitizerCoverage"></a>SanitizerCoverage</h3><blockquote>
<p>LLVM has a simple code coverage instrumentation built in (SanitizerCoverage). It inserts calls to user-defined functions on function-, basic-block-, and edge- levels. Default implementations of those callbacks are provided and implement simple coverage reporting and visualization, however if you need <em>just</em> coverage visualization you may want to use <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">SourceBasedCodeCoverage</a> instead.</p>
</blockquote>
<p>clang项目属于llvm的一部分。llvm内置相应的代码覆盖率检测机制（SanitizerCoverage），这个覆盖率检测机制在函数级、基本代码块（BasicBlock）以及边缘级（Edge）插入用户定义的函数调用，若不做定义，则使用llvm内置的默认版本。这些内置默认版本的插桩回调函数提供了代码覆盖率报告以及相应内容的可视化，如果只是为了可视化代码覆盖率，可以尝试使用 <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">SourceBasedCodeCoverage</a>替代。</p>
<p>llvm内建了几种策略来实现代码覆盖率检测。</p>
<br>

<h4 id="Tracing-PCs-with-guards"><a href="#Tracing-PCs-with-guards" class="headerlink" title="Tracing PCs with guards"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id2">Tracing PCs with guards</a></h4><p>使用<code>-fsanitize-coverage=trace-pc-gard</code>来启用，此时clang编译器在编译过程会将相应的插桩回调函数插入每一个CodeEdge</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</span><br></pre></td></tr></table></figure>

<p>每一个CodeEdge都有其相应的<code>guard_variable (uint32_t)</code></p>
<p>并且编译器会插入对相应模块构造函数的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The guards are [start, stop).</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure>

<p>另外，使用附加选项 <code>=trace-pc,indirecrt-calls</code>，会将回调函数<code>__sanitizer_cov_trace_pc_indirect</code>插入每一处间接调用的位置</p>
<p>函数<code>__sanitizer_cov_trace_pc_guard *</code>应由用户进行定义，文档给出了一个example：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace-pc-guard-cb.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start,</span><br><span class="line">                                                    <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint64_t</span> N;  </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)	</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="built_in">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id2">官方文档</a>，我们可以得知以下信息：</p>
<ul>
<li><code>__sanitizer_cov_trace_pc_guard_init</code>则是会统计所有标记过的edge，其中的start、stop参数指明了整个二进制文件中附加了guards的起始与结束位置，函数整体完成总代码分支的统计。上文提及每个插桩的CodeEdge有着其独特的guard值，字段N记录着guard的个数</li>
<li>在clang中附加<code>-fsanitize-coverage=trac-pc-guard</code>会在每个edge插入<code>__sanitizer_cov_trace_pc_guard</code>，用以标记代码是需要被记录的，这样当程序执行到相应的edge则会记录下这个被执行过，从而获得当前的代码量执行情况。</li>
<li>另外<code>__sanitizer_symbolize_pc</code>作为运行时的检测器的一部分，随着clang编译选项<code>-fsanitize=address</code>而启用。</li>
</ul>
<p>看下待测试的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace-pc-guard-example.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有过插桩的基本知识的话就应该知道，程序会在主干路径设置插桩回调函数，并且每个分支也会设置插桩回调函数，比如上述的代码，执行分支示意图大致如下：</p>
<img src="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/1.png" class="">



<p>编译上述的两个代码文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//-c选项，生成.o文件</span><br><span class="line">clang++ -g  -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c</span><br><span class="line">clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address</span><br><span class="line">ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out</span><br></pre></td></tr></table></figure>

<p><code>-fsanitize-coverage=trace-pc-guard</code>指明使用的代码插桩方式为<strong>trace-pc-guard</strong> 将a.out使用IDA载入，查看插桩后的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  __sanitizer_cov_trace_pc_guard(&amp;unk_1000081B4, argv, envp);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __sanitizer_cov_trace_pc_guard((<span class="type">char</span> *)&amp;unk_1000081B4 + <span class="number">8</span>, argv, v3);</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    __sanitizer_cov_trace_pc_guard((<span class="type">char</span> *)&amp;unk_1000081B4 + <span class="number">4</span>, argv, v3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，插桩情况如下：</p>
<img src="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/2.png" class="">





<p>看回这块代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="keyword">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译选项启用<code>-fsanitize=address</code>，则开启<code>__sanitizer_symbolize_pc</code>插桩动作，<code>__builtin_return_address</code>（这个是什么现在还不清楚，先留个坑）。在传入PeDescr用于存放当前的插桩位置的描述信息。由此可见，经过这一步，插桩算完成，相应的进行插桩结果的输出。输出example如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">插桩位置 | 插桩的代号 | 插桩描述</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Tracing-PCs"><a href="#Tracing-PCs" class="headerlink" title="Tracing PCs"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id6">Tracing PCs</a></h4><p>使用<code>-fsanitize-coverage=trace-pc</code>来启用，相应的编译器会将插桩回调函数<code>__sanitizer_cov_trace_pc</code>插入每一个code edge，使用附加选项<code>..=trace-pc,indirect-calls</code>，则编译器会将回调函数<code>__sanitizer_cov_trace_pc_indirect </code>插入每一处间接调用的位置。需要注意的是这里提到的回调函数并没有应用在运行监测工具中，需要用户自行完成定义。</p>
<br>

<h4 id="插桩单元"><a href="#插桩单元" class="headerlink" title="插桩单元"></a>插桩单元</h4><p>SanitizerCoverage提供了集中不同粒度的插桩单元</p>
<ul>
<li><code>edge</code> (default): edges are instrumented (see below).</li>
<li><code>bb</code>: basic blocks are instrumented.</li>
<li><code>func</code>: only the entry block of every function will be instrumented.</li>
</ul>
<p>结合<code>trace-pc-guard</code>或<code>trace-pc</code>使用上述的这些flags，比如：<code>-fsanitize-coverage=func,trace-pc-guard</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __sanitizer_cov_trace_pc_guard(&amp;unk_1000081B4, argv, envp);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">1</span> )</span><br><span class="line">    foo();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到插桩的行为不同于默认的edge（上文使用的）。</p>
<p>对于bb粒度下，IDA反编译失败，这里截下汇编图吧</p>
<img src="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/3.png" class="">



<br>

<h4 id="Edge-Coverage"><a href="#Edge-Coverage" class="headerlink" title="Edge Coverage"></a>Edge Coverage</h4><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> *a)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    *a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他包含三个basic block（bb），命名为A、B、C，我们都知道执行上下文是复杂的，A-&gt;C可能是多条路径执行导致，假如我们知道执行从状态1到状态2存在多条可能路径，路径串起一系列bb（这些路径被称为critical），这样，我们就不清楚到底哪些bb被执行了。以上面的代码为例，可能是如下</p>
<img src="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/4.png" class="">



<p>这样当我们知道程序执行上下文从state1 -&gt; state2。并且知道了三个bb都被覆盖到，那么就知道执行路径1是被执行了的，这样我们无从判断执行路径2是否被执行了，因此为了更好的考量覆盖率问题，需要做调整。clang中是这样解决–新增一个dummy bb</p>
<img src="/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/5.png" class="">

<br>

<h4 id="Tracing-data-flow"><a href="#Tracing-data-flow" class="headerlink" title="Tracing data flow"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id9">Tracing data flow</a></h4><p>这个是为了对那些<strong>基于数据流指导的fuzzing</strong>做出的支持。</p>
<ul>
<li><p>使用<code>-fsanitize-coverage=trace-cmp</code>选项，编译器会围绕<code>类comparison 指令</code>和<code>类switch指令</code>做额外地指令插桩。</p>
</li>
<li><p>另外<code>-fsanitize-coverage=trace-div</code>则是会再整数除法操作指令（右操作数-被除数）的位置做额外指令插桩。</p>
</li>
<li><p><code>-fsanitize-coverage=trace-gep</code>[LLVM下的GEP指令]会相应的关注数组索引的跟踪</p>
</li>
<li><p><code>-fsanitize-coverage=trace-loads</code>和<code>-fsanitize-coverage=trace-store</code>则是会插桩数据的存取操作</p>
</li>
</ul>
<p>当下，上述提及的选项不会单独工作，而是配合fsanitize-coverage&#x3D;{trace-pc, inline-8bit-counters, inline-bool}进行工作。下面是官方文档中的一些插桩相关的回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called before a comparison instruction.</span></span><br><span class="line"><span class="comment">// Arg1 and Arg2 are arguments of the comparison.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp1(<span class="type">uint8_t</span> Arg1, <span class="type">uint8_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp2(<span class="type">uint16_t</span> Arg1, <span class="type">uint16_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp4(<span class="type">uint32_t</span> Arg1, <span class="type">uint32_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_cmp8(<span class="type">uint64_t</span> Arg1, <span class="type">uint64_t</span> Arg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called before a comparison instruction if exactly one of the arguments is constant.</span></span><br><span class="line"><span class="comment">// Arg1 and Arg2 are arguments of the comparison, Arg1 is a compile-time constant.</span></span><br><span class="line"><span class="comment">// These callbacks are emitted by -fsanitize-coverage=trace-cmp since 2017-08-11</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_const_cmp1(<span class="type">uint8_t</span> Arg1, <span class="type">uint8_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_const_cmp2(<span class="type">uint16_t</span> Arg1, <span class="type">uint16_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_const_cmp4(<span class="type">uint32_t</span> Arg1, <span class="type">uint32_t</span> Arg2);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_const_cmp8(<span class="type">uint64_t</span> Arg1, <span class="type">uint64_t</span> Arg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called before a switch statement.</span></span><br><span class="line"><span class="comment">// Val is the switch operand.</span></span><br><span class="line"><span class="comment">// Cases[0] is the number of case constants.</span></span><br><span class="line"><span class="comment">// Cases[1] is the size of Val in bits.</span></span><br><span class="line"><span class="comment">// Cases[2:] are the case constants.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_switch(<span class="type">uint64_t</span> Val, <span class="type">uint64_t</span> *Cases);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called before a division statement.</span></span><br><span class="line"><span class="comment">// Val is the second argument of division.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_div4(<span class="type">uint32_t</span> Val);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_div8(<span class="type">uint64_t</span> Val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called before a GetElemementPtr (GEP) instruction</span></span><br><span class="line"><span class="comment">// for every non-constant array index.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_gep(<span class="type">uintptr_t</span> Idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called before a load of appropriate size. Addr is the address of the load.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_load1(<span class="type">uint8_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_load2(<span class="type">uint16_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_load4(<span class="type">uint32_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_load8(<span class="type">uint64_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_load16(__int128 *addr);</span><br><span class="line"><span class="comment">// Called before a store of appropriate size. Addr is the address of the store.</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_store1(<span class="type">uint8_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_store2(<span class="type">uint16_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_store4(<span class="type">uint32_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_store8(<span class="type">uint64_t</span> *addr);</span><br><span class="line"><span class="type">void</span> __sanitizer_cov_store16(__int128 *addr);</span><br></pre></td></tr></table></figure>

<br>

<h4 id="Disabling-instrumentation"><a href="#Disabling-instrumentation" class="headerlink" title="Disabling instrumentation"></a>Disabling instrumentation</h4><p>It is possible to disable coverage instrumentation for select functions via the function attribute <code>__attribute__((no_sanitize(&quot;coverage&quot;)))</code>. Because this attribute may not be supported by other compilers, it is recommended to use it together with <code>__has_feature(coverage_sanitizer)</code>.</p>
<br>

<h4 id="Disabling-instrumentation-without-source-modification"><a href="#Disabling-instrumentation-without-source-modification" class="headerlink" title="Disabling instrumentation without source modification"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id11">Disabling instrumentation without source modification</a></h4><p>指定列表对只对一些名单内的函数进行插桩操作，感兴趣的请读者也看看文档描述，还有例子嘞</p>
<br>



<h4 id="Default-implementation"><a href="#Default-implementation" class="headerlink" title="Default implementation"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id12">Default implementation</a></h4><p>clang支持一些运行时检测工具(，比如AddressSanitizer, MemorySanitizer, etc），这些检测工具提供了一些coverage callback函数，可用借此来检测一些程序异常退出时的执行情况。</p>
<p>Example</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">cat</span> -n cov.cc</span></span><br><span class="line">     1  #include &lt;stdio.h&gt;</span><br><span class="line">     2  __attribute__((noinline))</span><br><span class="line">     3  void foo() &#123; printf(&quot;foo\n&quot;); &#125;</span><br><span class="line">     4</span><br><span class="line">     5  int main(int argc, char **argv) &#123;</span><br><span class="line">     6    if (argc == 2)</span><br><span class="line">     7      foo();</span><br><span class="line">     8    printf(&quot;main\n&quot;);</span><br><span class="line">     9  &#125;</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">ASAN_OPTIONS=coverage=1 ./a.out; <span class="built_in">wc</span> -c *.sancov</span></span><br><span class="line">main</span><br><span class="line">SanitizerCoverage: ./a.out.7312.sancov 2 PCs written</span><br><span class="line">24 a.out.7312.sancov</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">ASAN_OPTIONS=coverage=1 ./a.out foo ; <span class="built_in">wc</span> -c *.sancov</span></span><br><span class="line">foo</span><br><span class="line">main</span><br><span class="line">SanitizerCoverage: ./a.out.7316.sancov 3 PCs written</span><br><span class="line">24 a.out.7312.sancov</span><br><span class="line">32 a.out.7316.sancov</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Every time you run an executable instrumented with SanitizerCoverage one <code>*.sancov</code> file is created during the process shutdown. If the executable is dynamically linked against instrumented DSOs, one <code>*.sancov</code> file will be also created for every DSO.</p>
</blockquote>
<p>编译加入了ASAN检测工具，并且设置的插桩的策略，如此编译出来的可执行程序每次运行到进程结束都会生成一个.sancov文件。</p>
<br>

<h4 id="Sancov-data-format"><a href="#Sancov-data-format" class="headerlink" title="Sancov data format"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id13">Sancov data format</a></h4><p>The format of <code>*.sancov</code> files is very simple: the first 8 bytes is the magic, one of <code>0xC0BFFFFFFFFFFF64</code> and <code>0xC0BFFFFFFFFFFF32</code>. The last byte of the magic defines the size of the following offsets. The rest of the data is the offsets in the corresponding binary&#x2F;DSO that were executed during the run.</p>
<br>

<h4 id="Sancov-Tool"><a href="#Sancov-Tool" class="headerlink" title="Sancov Tool"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id14">Sancov Tool</a></h4><p>An simple <code>sancov</code> tool is provided to process coverage files. The tool is part of LLVM project and is currently supported only on Linux. It can handle symbolization tasks autonomously without any extra support from the environment. You need to pass .sancov files (named <code>&lt;module_name&gt;.&lt;pid&gt;.sancov</code> and paths to all corresponding binary elf files. Sancov matches these files using module names and binaries file names.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">USAGE: sancov [options] &lt;action&gt; (&lt;binary file&gt;|&lt;.sancov file&gt;)...</span><br><span class="line"></span><br><span class="line">Action (required)</span><br><span class="line">  -print                    - Print coverage addresses</span><br><span class="line">  -covered-functions        - Print all covered functions.</span><br><span class="line">  -not-covered-functions    - Print all not covered functions.</span><br><span class="line">  -symbolize                - Symbolizes the report.</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">  -blocklist=&lt;string&gt;         - Blocklist file (sanitizer blocklist format).</span><br><span class="line">  -demangle                   - Print demangled function name.</span><br><span class="line">  -strip_path_prefix=&lt;string&gt; - Strip this prefix from file paths in reports</span><br></pre></td></tr></table></figure>

<br>



<h4 id="Coverage-Reports"><a href="#Coverage-Reports" class="headerlink" title="Coverage Reports"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id15">Coverage Reports</a></h4><p><code>.sancov</code> files do not contain enough information to generate a source-level coverage report. The missing information is contained in debug info of the binary. Thus the <code>.sancov</code> has to be symbolized to produce a <code>.symcov</code> file first:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sancov -symbolize my_program.123.sancov my_program &gt; my_program.123.symcov</span><br></pre></td></tr></table></figure>

<p>The <code>.symcov</code> file can be browsed overlaid over the source code by running <code>tools/sancov/coverage-report-server.py</code> script that will start an HTTP server.</p>
<br>

<h4 id="Output-directory"><a href="#Output-directory" class="headerlink" title="Output directory"></a><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#id16">Output directory</a></h4><p>By default, .sancov files are created in the current working directory. This can be changed with <code>ASAN_OPTIONS=coverage_dir=/path</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">ASAN_OPTIONS=<span class="string">&quot;coverage=1:coverage_dir=/tmp/cov&quot;</span> ./a.out foo</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">ls</span> -l /tmp/cov/*sancov</span></span><br><span class="line">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span><br><span class="line">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Clang-SanitizerCoverage-Doc：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">https://clang.llvm.org/docs/SanitizerCoverage.html</a></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Victory+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cvjark.github.io/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/">https://cvjark.github.io/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/libfuzzer%E7%B3%BB%E5%88%97/">libfuzzer系列</a><a class="post-meta__tags" href="/tags/Clang-Docs/">Clang-Docs</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-627db6d4a04365ef" async></script><nav id="pagination"></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://cvjark.github.io/2022/05/13/libfuzzer-SanitizeCoverage-DocRead/';
  this.page.identifier = '2022/05/13/libfuzzer-SanitizeCoverage-DocRead/';
  this.page.title = 'Clang-SanitizeCoverage-DocRead';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'https-cvjark-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://https-cvjark-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/57/wallhaven-57oj29.png)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Victory+</div><div class="framework-info"><span>Victory+</span><span class="footer-separator">❤</span><span>TBaozi</span></div><div class="footer_custom_text"><img src="https://ghchart.rshah.org/Cvjark" alt="Cvjark Github chart" /></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>