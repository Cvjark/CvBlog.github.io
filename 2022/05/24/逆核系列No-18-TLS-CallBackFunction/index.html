<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆核系列No.18--TLS CallBackFunction"><meta name="keywords" content="《逆向工程核心原理学习》,逆向"><meta name="author" content="Victory+"><meta name="copyright" content="Victory+"><title>逆核系列No.18--TLS CallBackFunction | Victory+'s blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Victory+'s blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="当前文章概览">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IMGAE-DATA-DURECTORY-9"><span class="toc-number">1.</span> <span class="toc-text">IMGAE_DATA_DURECTORY[9]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-callback%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">TLS callback函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">回调函数的调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9PE%E5%A4%B4%E6%B7%BB%E5%8A%A0TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">修改PE头添加TLS回调函数</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Victory+</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链(欢迎扩列哟...)</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/lcatro">lcatro</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e71v2l.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Victory+'s blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a><a class="site-page" href="/todolist/">ToDoList</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">逆核系列No.18--TLS CallBackFunction</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%80%86%E5%90%91/">-逆向</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/05/24/逆核系列No-18-TLS-CallBackFunction/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.7k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本节涉及PE头的相关知识，附上PE结构图：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/1.png" class="">
<p>参考书《逆向工程核心原理》，示例程序亦出自书本内容。有时间精力的建议买来读读。</p>
<blockquote>
<p>TLS是个线程的独立数据存储空间，使用TLS技术==可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样==。</p>
</blockquote>
<p>示例程序：HelloTls.exe（32bit）</p>
<p>作用是简单弹框</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/2.png" class="">
<p>OD载入程序，发现比EP代码执行更早的TLS代码：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/3.png" class="">
<p>检测当前进程是否处于调试状态，是则弹窗显示‘‘Debugger Detected！’‘随后终止程序运行。</p>
<p>由此可见TLS技术在逆向工程中可用作一种反调试技术使用。</p>
<hr>
<br>
<h3 id="IMGAE-DATA-DURECTORY-9">IMGAE_DATA_DURECTORY[9]</h3>
<p>若在编程中启用了TLS功能，PE头文件中会设置TLS表项（IMAGE_NT_HEADERS -&gt; IMAGE_OPTIONAL_HEADER -&gt; IMAGE_DATA_DIRECTORY[9]）</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/4.png" class="">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY64</span> &#123;</span></span><br><span class="line">    ULONGLONG   StartAddressOfRawData;</span><br><span class="line">    ULONGLONG   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> &#123;</span></span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>示例程序为32bit，PEview下的TLS结构体信息：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/5.png" class="">
<p>较为关键的是AddressOfCallbacks，其中记录着每个TLS函数的地址所构成的数组地址。这里是0x00408114（RVA）所在节区为.rdata，故转化后的RAW地址 = 0x6714，示例程序中只注册了一个TLS函数，0x00401000，可以通过修改PE文件头来增加TLS函数个数。</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/6.png" class="">
<hr>
<h3 id="TLS-callback函数原型">TLS callback函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line">    <span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,	<span class="comment">//模块句柄，标识唤醒该callback函数的单元</span></span></span><br><span class="line"><span class="params">    DWORD Reason,		<span class="comment">//唤醒callback的原因，有四种</span></span></span><br><span class="line"><span class="params">    PVOID Reserved		</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DLL_PROCESS_ATTACH1</td>
<td style="text-align:left">The DLL is being loaded into the virtual address space of the current process as a result of the process starting up or as a result of a call to <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>. DLLs can use this opportunity to initialize any instance data or to use the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> function to allocate a thread local storage (TLS) index. The <em>lpReserved</em> parameter indicates whether the DLL is being loaded statically or dynamically.</td>
</tr>
<tr>
<td style="text-align:left">DLL_PROCESS_DETACH0</td>
<td style="text-align:left">The DLL is being unloaded from the virtual address space of the calling process because it was loaded unsuccessfully or the reference count has reached zero (the processes has either terminated or called <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> one time for each time it called <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>). The <em>lpReserved</em> parameter indicates whether the DLL is being unloaded as a result of a <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> call, a failure to load, or process termination. The DLL can use this opportunity to call the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsfree"><strong>TlsFree</strong></a> function to free any TLS indices allocated by using <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><strong>TlsAlloc</strong></a> and to free any thread local data. Note that the thread that receives the <strong>DLL_PROCESS_DETACH</strong> notification is not necessarily the same thread that received the <strong>DLL_PROCESS_ATTACH</strong>notification.</td>
</tr>
<tr>
<td style="text-align:left">DLL_THREAD_ATTACH  2</td>
<td style="text-align:left">The current process is creating a new thread. When this occurs, the system calls the entry-point function of all DLLs currently attached to the process. The call is made in the context of the new thread. DLLs can use this opportunity to initialize a TLS slot for the thread. A thread calling the DLL entry-point function with <strong>DLL_PROCESS_ATTACH</strong> does not call the DLL entry-point function with <strong>DLL_THREAD_ATTACH</strong>.  Note that a DLL’s entry-point function is called with this value only by threads created after the DLL is loaded by the process. When a DLL is loaded using <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a>, existing threads do not call the entry-point function of the newly loaded DLL.</td>
</tr>
<tr>
<td style="text-align:left">DLL_THREAD_DETACH 3</td>
<td style="text-align:left">A thread is exiting cleanly. If the DLL has stored a pointer to allocated memory in a TLS slot, it should use this opportunity to free the memory. The system calls the entry-point function of all currently loaded DLLs with this value. The call is made in the context of the exiting thread.</td>
</tr>
</tbody>
</table>
<p>通过一个示例程序展示调用原因不同的TLS callback函数的调用顺序，TlsTest.exe（资料来源书中）</p>
<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_console</span><span class="params">(<span class="type">char</span>* szMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hStdout = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">	<span class="comment">//之所以不使用printf输出是由于开启特定编译选项编译源程序时，先于诸线程调用执行的TSL回调函数中可能发生Run-Time Error</span></span><br><span class="line">    <span class="built_in">WriteConsoleA</span>(hStdout, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="literal">NULL</span>, <span class="literal">NULL</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> szMsg[<span class="number">80</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);</span><br><span class="line">    <span class="built_in">print_console</span>(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">TLS_CALLBACK2</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> szMsg[<span class="number">80</span>] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="built_in">wsprintfA</span>(szMsg, <span class="string">&quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);</span><br><span class="line">    <span class="built_in">print_console</span>(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.CRT$XLX&quot;</span>)</span></span><br><span class="line">    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;ThreadProc() start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;ThreadProc() end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;main() start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_console</span>(<span class="string">&quot;main() end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故程序执行顺序如下：</p>
<ol>
<li>主线程开始运行，触发<strong>DLL_PROCESS_ATTACH</strong> 从而callback1、2函数被唤醒，进行内容输出</li>
<li>随后main函数内容开始执行，输出<code>main() start</code></li>
<li>main中调用CreateThread，触发DLL_THREAD_ATTACH  从而callback1、2函数被唤醒，进行内容输出（区别于之前的唤醒，这里的唤醒原因不同，第一个是1，这里是2（代号））</li>
<li>随后ThreadProc子线程执行本体内容，输出<code>ThreadProc() start\n ThreadProc() end\n</code>，</li>
<li>随后子线程return时，子线程消亡，触发DLL_THREAD_DETACH，代号3。callback1、2函数再次被唤醒</li>
<li>最后main再输出<code>main() end \n</code> 随后main进行return，触发DLL_PROCESS_DETACH 代号0，callback1、2函数再次被唤醒</li>
</ol>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/7.png" class="">
<hr>
<h3 id="回调函数的调试">回调函数的调试</h3>
<p>以HelloTls.exe为例：alt + o，打开调试选项，设置OD加载程序的暂停位置为 system breakpoint</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/8.png" class="">
<p>载入程序：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/9.png" class="">
<p>在先前查看到的TLS回调函数的位置设置断点：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/10.png" class="">
<p>执行程序，OD停在断点位置，就可以开始调试TLS函数了，对于多个TLS函数，可以分别查看，各自下断点：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/11.png" class="">
<hr>
<h3 id="修改PE头添加TLS回调函数">修改PE头添加TLS回调函数</h3>
<ul>
<li>为写入代码与数据准备空间（需要挪移原TLS的内容）
<ul>
<li>方案一：添加节区末尾的空白区域（由于节区对齐关系可能存在映射到内存中存在足够的空白空间供写入）</li>
<li>方案二：增加最后一个节区的大小（影响最后一个节区的节区头信息）</li>
<li>方案三：在最后添加新节区（影响NumberOfSection等PE字段）</li>
</ul>
</li>
</ul>
<p>采取方案二，先观察PE文件的对齐规则：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/12.png" class="">
<p>在PE文件的最后位置，插入200byte内容（最小对齐FileAlignment的大小）</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/13.png" class="">
<p>PE文件最后一个节区的节区头头信息：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/14.png" class="">
<p>将该节区的SizeOfRawData扩容200字节，因此PointerToRawData为0x00009000，SizeOfRawData为400，是符合文件对齐规则的。节区.rsrc的VirtualSize = 0x1B4扩容后VirtualSize = 0x3B4 &lt; SectionAlignment（0x1000），故不需要对节区的VirtualSize做修改。</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/15.png" class="">
<p>除了修改最后一个节区（.rsrc）的SizeOfRawData之外还需要修改该节区的Characteristic，往上附加写和执行的权限</p>
<table>
<thead>
<tr>
<th><strong>IMAGE_SCN_MEM_WRITE</strong>0x80000000</th>
<th>The section can be written to.</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IMAGE_SCN_MEM_EXECUTE</strong>0x20000000</td>
<td>The section can be executed as code.</td>
</tr>
</tbody>
</table>
<p>修改后的characteristic为：0xE0000040</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/16.png" class="">
<p>验证上述修改：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/17.png" class="">
<p>扩展出来的空间的RAW = 0x9200 Size = 0x200， RVA = 0xC200</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/18.png" class="">
<p>可以看出源程序时没有启用TLS机制的，故为空值（如果原来有数据，则复制一份到新开辟的空间中），这里写入TLS则需要进行设置，首先是TLS表的RAW = 0x9200 RVA = 0xC200， SIze则是写入的TLS结构体个数，这里写入一个则size = 0x18，这是由结构体IMAGE_TLS_DIRECTORY大小决定的，若原来就有数据，则size+18</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该结构体有x64版本，示例程序为32bit，占18字节空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY32</span> &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    PDWORD  AddressOfIndex;</span><br><span class="line">    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;</span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure>
<p>修改IMAGE_OPTIONAL_HEADER -&gt; DATA_DIRECTOR[9]</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/19.png" class="">
<p>验证修改：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/20.png" class="">
<p>最后就是写入TLS的表项内容到开辟出来的空间了</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/21.png" class="">
<p>AddressOfCallback = 0x0040C224（RVA） = 0x9224（RAW）对应写入的TLS函数地址构成的链表，以DWORD NULL结尾 0x0040C230，第一个TLS函数对应的RAW = 0x9230，这里是TLS函数的指令代码空间。C2 0C00 的指令码对应的汇编指令时<code>RETN 0C</code>命令，即不执行任何操作，直接返回。（PS：之所以不直接食用RETN是为了进行栈恢复，因为函数有三个参数，参考函数原型）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,</span></span><br><span class="line"><span class="params">    DWORD Reason,</span></span><br><span class="line"><span class="params">    PVOID Reserved</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>发现上图HxD中的修改无法让程序正常运行，应该是结构体_IMAGE_TLS_DIRECTORY32某些字段没有设置好导致的，搜索下其他字段的含义以及应该写入的值，找到了：（图片来源在图片下方）</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/22.png" class="">
<p>因此修改后：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/23.png" class="">
<p>程序可正常运行，使用OD载入程序，并且在写入的TLS的位置设置断点：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/24.png" class="">
<p>OD中运行程序，发现TLS函数被执行：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/25.png" class="">
<p>验证成功后需要修改TLS函数的本体内容即可，这里执行的是RETN 0xC，并没有执行实质性操作。</p>
<p>分析调用TLS函数前在栈中的参数情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span></span><br><span class="line"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    PVOID DllHandle,</span></span><br><span class="line"><span class="params">    DWORD Reason,</span></span><br><span class="line"><span class="params">    PVOID Reserved</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>
<p>用于判断TLS函数调用的理由是第二个参数，运行至此的 ss:[ebp+8]是第二个参数，<a target="_blank" rel="noopener" href="https://blog.csdn.net/boildoctor/article/details/121206955">不清楚的推荐阅读</a></p>
<p>编辑TLS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0040C230    837D 08 01      CMP DWORD PTR SS:[EBP+0x8], 0x1	;获取TLS调用的Reason参数，是否由主线程加载唤醒</span><br><span class="line">0040C234    75 29           JNZ SHORT Hello_Ex.0040C25F	;不是由主线程加载唤醒的则不作为进行return</span><br><span class="line">0040C236    64:A1 30000000  MOV EAX, DWORD PTR FS:[0x30]	;获取PEB信息</span><br><span class="line">0040C23C    8078 02 00      CMP BYTE PTR DS:[EAX+0x2], 0x0	;判断是否处于被调试状态</span><br><span class="line">0040C240    74 1D           JE SHORT Hello_Ex.0040C25F	;不是处于被调试状态则不做操作进行return</span><br><span class="line">0040C242    6A 00           PUSH 0x0		;进入这里说明程序处于被调试状态，接下来操作则是进行弹窗的调用准备</span><br><span class="line">0040C244    68 70C24000     PUSH Hello_Ex.0040C270	;入栈存放弹窗的标题字符串所在地址</span><br><span class="line">0040C249    68 80C24000     PUSH Hello_Ex.0040C280	;入栈存放弹窗内容字符串所在地址</span><br><span class="line">0040C24E    6A 00           PUSH 0x0	</span><br><span class="line">0040C250    FF15 E8804000   CALL DWORD PTR DS:[&lt;&amp;USER32.MessageB&gt;; user32.MessageBoxA</span><br><span class="line">0040C256    6A 01           PUSH 0x1</span><br><span class="line">0040C258    FF15 28804000   CALL DWORD PTR DS:[&lt;&amp;KERNEL32.ExitPr&gt;; kernel32.ExitProcess</span><br><span class="line">0040C25E    C2 0C00         RETN 0xC</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HWND   hWnd,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpText,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">  [in]           UINT   uType</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>保存汇编指令到可执行文件：Hello_Ex_modify.exe</p>
<p>汇编代码写出来了，接下来则是需要将几个提到的内容在16进制视图下写入：(注意字符串00结尾)</p>
<p>RVA  0x0040C270 -&gt;  RAW 0x9270，写入标题字符串：<code>Victory say：</code></p>
<p>RVA  0x0040C280 -&gt;  RAW 0x9280，写入标题字符串：<code>I found Debugger！</code></p>
<p>其他涉及的call API是通过IAT中获取的，若IAT中没有相应地API导入则会相对麻烦，例子中IAT是有对应的函数的，所以可以直接使用</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/26.png" class="">
<p>OD查看字符串写入情况：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/27.png" class="">
<p>查看汇编指令情况：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/28.png" class="">
<p>设置断点，并运行，发现并未如愿：</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/29.png" class="">
<p>发现读取参数的位置也不对，另外PEB记录的PEB.BeingDebugged的值为0（图中标错，应该往后一个字节的），本来是附加了调试器的，值应该为1的，感觉也不对。</p>
<p>期间也换了不同版本的OD，结果仍然一致，实验结果复刻不一致。</p>
<p>调试书的作者的版本依旧发现PEB.BeingDebugger的值依旧不正确，值表明程序并没有检测到由调试器的附加</p>
<img src="/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/30.png" class="">
<p>对于出现上述的状况是第三方OD相关插件自己做了规避，使用原版的OD即可正常查看字段</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Victory+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cvjark.github.io/2022/05/24/逆核系列No-18-TLS-CallBackFunction/">https://cvjark.github.io/2022/05/24/逆核系列No-18-TLS-CallBackFunction/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E3%80%8B/">《逆向工程核心原理学习》</a><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91/">逆向</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-627db6d4a04365ef" async></script><nav id="pagination"><div class="next-post pull-right"><a href="/2022/05/23/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-bytes%E5%AF%B9%E8%B1%A1/"><span>python源码剖析No.6--bytes对象</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://cvjark.github.io/2022/05/24/%E9%80%86%E6%A0%B8%E7%B3%BB%E5%88%97No-18-TLS-CallBackFunction/';
  this.page.identifier = '2022/05/24/逆核系列No-18-TLS-CallBackFunction/';
  this.page.title = '逆核系列No.18--TLS CallBackFunction';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'https-cvjark-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://https-cvjark-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e71v2l.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Victory+</div><div class="framework-info"><span>Victory+</span><span class="footer-separator">❤</span><span>TBaozi</span></div><div class="footer_custom_text"><img src="https://ghchart.rshah.org/Cvjark" alt="Cvjark Github chart" /></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>