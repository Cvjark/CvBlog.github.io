<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Libfuzzer workshop项目阅读"><meta name="keywords" content="libfuzzer系列,fuzzing,项目阅读"><meta name="author" content="Victory+"><meta name="copyright" content="Victory+"><title>Libfuzzer workshop项目阅读 | Victory+'s blog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Victory+'s blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="当前文章概览">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00"><span class="toc-number">1.</span> <span class="toc-text">0x00</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#about-fuzzing"><span class="toc-number">2.</span> <span class="toc-text">about fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">一些定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fuzzer-types"><span class="toc-number">2.2.</span> <span class="toc-text">Fuzzer types</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libfuzzer-usage"><span class="toc-number">3.</span> <span class="toc-text">libfuzzer usage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90testcase%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">生成testcase源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fuzzer%E6%BA%90%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">fuzzer源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cfuzzer"><span class="toc-number">3.3.</span> <span class="toc-text">运行fuzzer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%B0%8F%E8%8A%82%E5%9B%9E%E9%A1%BE"><span class="toc-number">3.4.</span> <span class="toc-text">本小节回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lesson-03"><span class="toc-number">4.</span> <span class="toc-text">Lesson 03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libfuzzer%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">libfuzzer示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#example4-1"><span class="toc-number">5.1.</span> <span class="toc-text">example4.1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#output%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="toc-number">5.1.1.</span> <span class="toc-text">output字段解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#example4-1-%E6%94%B6%E8%8E%B7"><span class="toc-number">5.1.2.</span> <span class="toc-text">example4.1 收获</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">编译过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5-E"><span class="toc-number">5.2.1.</span> <span class="toc-text">预处理阶段 -E</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5-S"><span class="toc-number">5.2.2.</span> <span class="toc-text">编译阶段 -S</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E9%98%B6%E6%AE%B5-c"><span class="toc-number">5.2.3.</span> <span class="toc-text">汇编阶段 -c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">5.2.4.</span> <span class="toc-text">链接阶段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example4-2"><span class="toc-number">5.3.</span> <span class="toc-text">example4.2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example4-3"><span class="toc-number">5.4.</span> <span class="toc-text">example4.3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example4-4"><span class="toc-number">5.5.</span> <span class="toc-text">example4.4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heartbleed"><span class="toc-number">6.</span> <span class="toc-text">Heartbleed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%BC%8F%E6%B4%9E%E7%89%88%E6%9C%ACopenssl"><span class="toc-number">6.1.</span> <span class="toc-text">编译漏洞版本openssl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fuzzer%E7%BC%96%E5%86%99"><span class="toc-number">6.2.</span> <span class="toc-text">fuzzer编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91fuzzer"><span class="toc-number">6.2.1.</span> <span class="toc-text">编译fuzzer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cfuzzer-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">运行fuzzer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90crash"><span class="toc-number">6.2.3.</span> <span class="toc-text">分析crash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-ares"><span class="toc-number">7.</span> <span class="toc-text">c-ares</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-vulnerable-c-ares-ver"><span class="toc-number">7.1.</span> <span class="toc-text">Build vulnerable c-ares ver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-and-run-Fuzzer"><span class="toc-number">7.2.</span> <span class="toc-text">Build and run Fuzzer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91Fuzzer"><span class="toc-number">7.2.1.</span> <span class="toc-text">编译Fuzzer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CFuzzer"><span class="toc-number">7.2.2.</span> <span class="toc-text">执行Fuzzer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lesson-07"><span class="toc-number">8.</span> <span class="toc-text">Lesson 07</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#measure"><span class="toc-number">8.1.</span> <span class="toc-text">measure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dictionaries"><span class="toc-number">8.2.</span> <span class="toc-text">Dictionaries</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8D%87Fuzzer%E6%95%88%E7%8E%87"><span class="toc-number">9.</span> <span class="toc-text">提升Fuzzer效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%BC%8F%E6%B4%9E%E7%89%88%E6%9C%AClibxml2"><span class="toc-number">9.1.</span> <span class="toc-text">编译漏洞版本libxml2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#First-Fuzzer"><span class="toc-number">9.2.</span> <span class="toc-text">First Fuzzer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Run-without-dict"><span class="toc-number">9.2.1.</span> <span class="toc-text">Run without dict</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Run-with-dict"><span class="toc-number">9.2.2.</span> <span class="toc-text">Run with dict</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#minimize-corpus"><span class="toc-number">9.2.3.</span> <span class="toc-text">minimize corpus</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#corpus1"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">corpus1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#corpus2"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">corpus2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">9.3.</span> <span class="toc-text">生成覆盖率报告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Second-fuzzer"><span class="toc-number">9.4.</span> <span class="toc-text">Second fuzzer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#build-fuzzer"><span class="toc-number">9.4.1.</span> <span class="toc-text">build fuzzer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#run-fuzzer"><span class="toc-number">9.4.2.</span> <span class="toc-text">run fuzzer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">9.5.</span> <span class="toc-text">回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Seed-corpus%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">Seed corpus的重要性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-libpng-vuln-ver"><span class="toc-number">10.1.</span> <span class="toc-text">Build libpng vuln-ver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-and-run-the-fuzzer"><span class="toc-number">10.2.</span> <span class="toc-text">Build and run the fuzzer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE"><span class="toc-number">10.2.1.</span> <span class="toc-text">从0开始生成数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%AD%97%E5%85%B8"><span class="toc-number">10.2.2.</span> <span class="toc-text">附加字典</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.3.</span> <span class="toc-text">附加种子文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.4.</span> <span class="toc-text">字典+种子文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-1"><span class="toc-number">10.3.</span> <span class="toc-text">回顾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5max-len"><span class="toc-number">11.</span> <span class="toc-text">字段max-len</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91target"><span class="toc-number">11.1.</span> <span class="toc-text">编译target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91fuzzer-1"><span class="toc-number">11.2.</span> <span class="toc-text">编译fuzzer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#max-len-not-set"><span class="toc-number">11.2.1.</span> <span class="toc-text">max_len not set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-len-x3D-5120"><span class="toc-number">11.2.2.</span> <span class="toc-text">max_len&#x3D;5120</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-len-x3D-6114-or-7168"><span class="toc-number">11.2.3.</span> <span class="toc-text">max_len&#x3D;6114 or 7168</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-len-x3D-10240"><span class="toc-number">11.2.4.</span> <span class="toc-text">max_len&#x3D;10240</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-len-x3D-30720"><span class="toc-number">11.2.5.</span> <span class="toc-text">max_len&#x3D;30720</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-number">12.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Victory+</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链(欢迎扩列哟...)</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/lcatro">lcatro</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e7lomr.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Victory+'s blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a><a class="site-page" href="/todolist/">ToDoList</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Libfuzzer workshop项目阅读</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/fuzzing/">fuzzing</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/05/19/libfuzzerNo-1-about-fuzzer/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/05/19/libfuzzerNo-1-about-fuzzer/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">11.9k</span><span class="post-meta__separator">|</span><span>Reading time: 52 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><p>这阵子想着重拾模糊测试fuzzing方面的学习，于是开这个系列记录记录，想着分享知识的，兴许自己某些地方理解有误也能让各位师傅们指出，自己也作相应的修正。</p>
<p>这个系列是根据libfuzzer的开源项目中的lesson走的，项目地址在这里：<a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop.git">Clinck</a></p>
<p>相应的，笔者在阅读libfuzzer-workshop过程中的一些读到的文章也会在<code>Reference</code>中指出，相信对大家有帮助的，那开始内容吧</p>
<br>



<h3 id="about-fuzzing"><a href="#about-fuzzing" class="headerlink" title="about fuzzing"></a>about fuzzing</h3><blockquote>
<p>对应着workshop Lesson 01</p>
</blockquote>
<br>

<p>fuzzing是一种软件测试技术，常用于自动化、半自动化测试，其中包含了一些非法、预期之外或者一些随机生成的输入传递给程序进行run，以期望程序出现安全违例事件发生（比如crash 、 leak）</p>
<br>

<h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><ol>
<li>target：作为target需要有如下特征：<ul>
<li>接受一系列字节内容作为输入</li>
<li>调用了我们想测试的代码块（函数…）</li>
</ul>
</li>
<li>Fuzzer：一个能将生成的输入“喂”给程序进行run的工具</li>
<li>Corpus：语料库<ul>
<li>一系列非法或者合法的输入，这类通常可以在项目中的测试用例集中收集，又或者是github开源项目的issue中别人提供的输入用例</li>
</ul>
</li>
</ol>
<br>

<h4 id="Fuzzer-types"><a href="#Fuzzer-types" class="headerlink" title="Fuzzer types"></a>Fuzzer types</h4><ul>
<li>Generation Based</li>
<li>Mutation Based</li>
<li>Evolutionary</li>
</ul>
<hr>
<br>

<h3 id="libfuzzer-usage"><a href="#libfuzzer-usage" class="headerlink" title="libfuzzer usage"></a>libfuzzer usage</h3><blockquote>
<p>对应workshop项目的lesson 02</p>
</blockquote>
<br>

<h4 id="生成testcase源码"><a href="#生成testcase源码" class="headerlink" title="生成testcase源码"></a>生成testcase源码</h4><p>生成测试用例的脚本generate_testcases.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">WORK_DIR = <span class="string">&#x27;work&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create work `directory` and `corpus` subdirectory.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(WORK_DIR):</span><br><span class="line">  os.mkdir(WORK_DIR)</span><br><span class="line"></span><br><span class="line">corpus_dir = os.path.join(WORK_DIR, <span class="string">&#x27;corpus&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(corpus_dir):</span><br><span class="line">  os.mkdir(corpus_dir)</span><br><span class="line"></span><br><span class="line">seed_corpus_filenames = os.listdir(<span class="string">&#x27;seed_corpus&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  random_seed_filename = random.choice(seed_corpus_filenames)</span><br><span class="line">  random_seed_filename = os.path.join(<span class="string">&#x27;seed_corpus&#x27;</span>, random_seed_filename)</span><br><span class="line">  output_filename = os.path.join(WORK_DIR, <span class="string">&#x27;corpus&#x27;</span>, <span class="string">&#x27;testcase-%06d&#x27;</span> % i)</span><br><span class="line">  cmd = <span class="string">&#x27;bin/radamsa &quot;%s&quot; &gt; &quot;%s&quot;&#x27;</span> % (random_seed_filename, output_filename)</span><br><span class="line">  os.popen(cmd)</span><br></pre></td></tr></table></figure>

<p>第15行及以前完成的都是对于目录的一些设定，假定当前目录是lessons&#x2F;02：</p>
<ul>
<li><p>当前目录下是否存在work目录，不存在则创建，lessons&#x2F;02&#x2F;work</p>
</li>
<li><p>corpus_dir目录为lessons&#x2F;02&#x2F;work&#x2F;corpus，没有则创建</p>
</li>
<li><p>列出用于生成测试用例目录中的种子文件，返回目录下的文件及目录的名字，列表形式返回</p>
</li>
<li><p>调用radamsa完成测试用例生成</p>
</li>
</ul>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/1.png" class="">



<p>可以看到，生成测试用例的方式是从seed_corpus中取出种子文件，利用radamsa生成测试用例，保存在lessons&#x2F;02&#x2F;work&#x2F;corpus中。</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/2.png" class="">



<p>成功生成利用radamsa+seed的方式生成测试用例</p>
<br>

<h4 id="fuzzer源码"><a href="#fuzzer源码" class="headerlink" title="fuzzer源码"></a>fuzzer源码</h4><p>fuzzer脚本同样有lesson2给出，位于run_fuzzing.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">WORK_DIR = <span class="string">&#x27;work&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkOutput</span>(<span class="params">s</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="string">&#x27;Segmentation fault&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;error&#x27;</span> <span class="keyword">in</span> s.lower():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">corpus_dir = os.path.join(WORK_DIR, <span class="string">&#x27;corpus&#x27;</span>)</span><br><span class="line">corpus_filenames = os.listdir(corpus_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> corpus_filenames:</span><br><span class="line">  testcase_path = os.path.join(corpus_dir, f)</span><br><span class="line">  cmd = [<span class="string">&#x27;bin/asan/pdfium_test&#x27;</span>, testcase_path]</span><br><span class="line">  process = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.STDOUT)</span><br><span class="line">  output = process.communicate()[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> checkOutput(output):</span><br><span class="line">    <span class="built_in">print</span> testcase_path</span><br><span class="line">    <span class="built_in">print</span> output</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>很简单，使用了<code>subprocess</code>用于启动一个新锦成并且与之通信。参数args可以使字符串或者序列类型（如list、元组…）</p>
<p>用于检测程序是否crash也很简单，只是检查输出内容是否有包含关键字<code>Segmentation fault</code></p>
<ul>
<li><p><code>subprocess.PIPE</code>: 在创建Popen对象时，subprocess.PIPE可以初始化<code>stdin</code>, <code>stdout</code>或<code>stderr</code>参数。表示与子进程通信的标准流。</p>
</li>
<li><p><code>subprocess.STDOUT</code>: 创建Popen对象时，用于初始化<code>stderr</code>参数，<strong>表示将错误通过标准输出流输出</strong></p>
</li>
<li><p><code>communicate(input=None)</code> : 与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。<code>Communicate()返回一个元组：(stdoutdata, stderrdata)</code>。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</p>
</li>
</ul>
<p>如果捕获到了异常，则输出相应的测试用例名称，用于后续的复现crash并分析crash原因，再输出错误信息和分隔符。</p>
<br>

<h4 id="运行fuzzer"><a href="#运行fuzzer" class="headerlink" title="运行fuzzer"></a>运行fuzzer</h4><p>首先需要将测试目标进行加压，项目中是压缩了的</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/3.png" class="">

<p>得到目标程序以及它所依赖的库文件。</p>
<br>

<p>在这个过程，可以看到python完成的是使用subprocess开启目标程序的进程，将测试用例递交给目标进程而已，再无其他。</p>
<p>另外，由于生成测试用例的随机性，不一定能够触发crash因此，在看到无crash，可以多生成几次测试用例，在run fuzzer，最终得到crash</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/4.png" class="">

<p>可以看到是由哪个测试用例触发的crash以及描述crash的一些信息</p>
<br>

<h4 id="本小节回顾"><a href="#本小节回顾" class="headerlink" title="本小节回顾"></a>本小节回顾</h4><ol>
<li>学习了libfuzzer的基本用法</li>
<li>利用radamsa+seed（种子文件）的方式生成测试用例</li>
</ol>
<hr>
<h3 id="Lesson-03"><a href="#Lesson-03" class="headerlink" title="Lesson 03"></a>Lesson 03</h3><p>理论课，查看项目中的PPT</p>
<hr>
<h3 id="libfuzzer示例"><a href="#libfuzzer示例" class="headerlink" title="libfuzzer示例"></a>libfuzzer示例</h3><blockquote>
<p>对应workshop项目的lesson 04</p>
</blockquote>
<br>

<h4 id="example4-1"><a href="#example4-1" class="headerlink" title="example4.1"></a>example4.1</h4><p>考虑下方的代码，你能否从中找到漏洞？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">VulnerableFunction1</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    result = data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码当<code>size &gt;= 3</code>时，我们尝试编写fuzzer去测试这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  VulnerableFunction1(data, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，项目组将待fuzz的函数写进一个头文件<code>vulnerable_functions.h</code>在将其包含进来，在调用Libfuzzer提供的接口<code>LLVMFuzzerTestOneInput</code>，传入待fuzzer需要的参数，在内部进行参数传递。</p>
<p>其中<code>LLVMFuzzerTestOneInput</code><strong>名称参数返回值类型都不能动</strong>，并且<strong>注意参数中传来的字节数组Data是通过底层const修饰了的，也就是不允许修改其中数据。</strong>fuzzer target（即<code>LLVMFuzzerTestOneInput</code>函数）目的是作为被测对象(<code>VulnerableFunction1</code>)与libFuzzer库之间的一个<strong>中转接口，其作用在于接受libFuzzer提供的输入数据<code>Data</code>字节串，（可能还需要进行数据格式转换，）然后传递给实际的被测函数</strong>（如上述示例中的<code>VulnerableFunction1</code>）。简言之，检测目标与libfuzzer的接口是固定的，名称和参数，导致如果我们的检测目标与接口传入的参数不一致，则需要在内部进行转换，在递交给我们的目标</p>
<br>

<p>将上述代码使用clang编译，编译命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g -std=c++11 -fsanitize=address,fuzzer first_fuzzer.cc -o first_fuzzer</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-fsanitize=\&lt;check&gt;,\&lt;arg2&gt;..., -fno-sanitize=\&lt;arg1&gt;\&lt;arg2&gt;...</code>开启运行时的检测，其中第一个address表明启用内存检测工具，接着fuzzer则表明启用libfuzzer</li>
<li><code>-g</code> 保留调试信息</li>
</ul>
<p>编译并运行，发现立马-fsanitize选项中附加的运行时检测的工具检测出crash了</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/5.png" class="">



<br>

<h5 id="output字段解释"><a href="#output字段解释" class="headerlink" title="output字段解释"></a>output字段解释</h5><ul>
<li><p><code>INITED</code> fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。</p>
</li>
<li><p><code>READ</code> fuzzer已从语料库目录中读取了所有提供的输入样本。</p>
</li>
<li><p><code>NEW</code> fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。</p>
</li>
<li><p><code>pulse</code> fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。</p>
</li>
<li><p><code>REDUCE</code> fuzzer发现了一个更好（更小）的输入，可以触发先前发现的特征（设置-reduce_inputs&#x3D;0以禁用）。</p>
</li>
<li><p><code>cov</code> 执行当前语料库所覆盖的代码块或边的总数。</p>
</li>
<li><p><code>ft</code> libFuzzer使用不同的信号来评估代码覆盖率：边缘覆盖率，边缘计数器，值配置文件，间接调用方&#x2F;被调用方对等。这些组合的信号称为功能（ft：）。</p>
</li>
<li><p><code>corp</code> 当前内存中测试语料库中的条目数及其大小（以字节为单位）。</p>
</li>
<li><p><code>exec/s</code> 每秒模糊器迭代的次数。</p>
</li>
<li><p><code>rss</code> 当前的内存消耗。</p>
</li>
<li><p><code>L</code> 新输入的大小（以字节为单位）。</p>
</li>
<li><p><code>MS：&lt;n&gt; &lt;操作&gt;</code> 计数和用于生成输入的变异操作列表</p>
</li>
<li><p><code>#1186	REDUCE cov: 5 ft: 5 corp: 3/7b lim: 11 exec/s: 0 rss: 31Mb L: 3/3 MS: 2 CrossOver-EraseBytes-</code>指尝试了<code>1186</code>个输入，成功发现了<code>3个样本（放入语料库）大小为7b</code>，共覆盖了<code>5</code>个代码块，占用内存<code>31mb</code>，变异操作为<code>CrossOver-EraseBytes-</code>。</p>
</li>
</ul>
<br>

<p>这里好奇怎么做到的，于是在了解到libfuzzer作为clang的一部分，从这里入手，想着进一步了解在编译过程中到底发生了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (Size == <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> *args = (<span class="type">const</span> <span class="type">uint64_t</span> *) Data;</span><br><span class="line">        <span class="keyword">if</span> (*args == *(args + <span class="number">1</span>)) &#123;</span><br><span class="line">            result = <span class="number">1997</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">06</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当libfuzzer生成的Data字节串长度为16byets 时，将args取出第一个长度8byte的内容，第二个则为余下8bytes内容。若二者相等，输出result &#x3D; 1997，否则result &#x3D; 06，当Data长度不为16时，则输出result &#x3D; 23.很简单的代码。</p>
<br>

<h5 id="example4-1-收获"><a href="#example4-1-收获" class="headerlink" title="example4.1 收获"></a>example4.1 收获</h5><p>example1，我们明白了需要根据target进行libfuzzer接口的编写，以及crash output的字段解读</p>
<br>

<p>从example1中，我们注意到程序文件中缺少了main这个不可缺少的部分。于是好奇clang都做了什么，本着不求甚解的目的，开启后文的学习。</p>
<br>

<h4 id="编译过程分析"><a href="#编译过程分析" class="headerlink" title="编译过程分析"></a>编译过程分析</h4><p>接下来以这段代码为例看下clang在编译阶段介入libfuzzer都做了些什么</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pitta@pitta-Ubuntu:~/Desktop/workspace/libfuzzer-workshop/mytest$ clang -ccc-print-phases code1.c </span><br><span class="line">            +- 0: input, &quot;code1.c&quot;, c</span><br><span class="line">         +- 1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">      +- 2: compiler, &#123;1&#125;, ir</span><br><span class="line">   +- 3: backend, &#123;2&#125;, assembler</span><br><span class="line">+- 4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用-ccc-print-phases查看clang编译的几个阶段：</p>
<ol>
<li>input，输入源码文件</li>
<li>preprocessor预处理，生成<code>code1.i</code>文件</li>
<li>compiler编译，生成<code>code1.bc</code>文件，.bc文件为llvm ir的bytecode文件，是中间语言形式描述源码，可读性差，但llvm为我们提供了另外一种表达形式<code>code1.ll</code>提升了中间代码的可读性，等价于.bc文件</li>
<li>backend 输出汇编结果文件<code>code1.s</code></li>
<li>assembler 生成<code>code1.o</code>文件</li>
<li>linker链接生成可执行文件<code>image</code></li>
</ol>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/6.png" class="">

<h5 id="预处理阶段-E"><a href="#预处理阶段-E" class="headerlink" title="预处理阶段 -E"></a>预处理阶段 -E</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -E code1.c</span><br><span class="line">clang -fsanitize=fuzzer -E code1.c</span><br></pre></td></tr></table></figure>

<p>输出两个预处理过程中产生的内容，比对是否存在差异：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -E code1.c  &gt; prep-no-fuzzer.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -E -fsanitize=fuzzer code1.c  &gt; prep-with-fuzzer.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff  prep-no-fuzzer.txt  prep-with-fuzzer.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br></pre></td></tr></table></figure>

<p>可以看到输出内容为空，说明预处理阶段-fsanitize&#x3D;fuzzer这个选项不作为。</p>
<br>

<h5 id="编译阶段-S"><a href="#编译阶段-S" class="headerlink" title="编译阶段 -S"></a>编译阶段 -S</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -S -fsanitize=fuzzer -o compiler-with-fuzzer.s code1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -S -o compiler-without-fuzzer.s code1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff compiler-with-fuzzer.s compiler-without-fuzzer.s -y -W 100 &gt; compiler-diff</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> compiler-diff</span></span><br></pre></td></tr></table></figure>

<p>可以看到类似如下的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">	.text												.text</span><br><span class="line">	.file	&quot;code1.c&quot;									.file	&quot;code1.c&quot;</span><br><span class="line">	.section	.text.LLVMFuzzerTestO &lt;</span><br><span class="line">	.globl	LLVMFuzzerTestOneInput       				.globl	LLVMFuzzerTestOneInput       </span><br><span class="line">	.p2align	4, 0x90									.p2align	4, 0x90</span><br><span class="line">	.type	LLVMFuzzerTestOneInput,@funct				.type	LLVMFuzzerTestOneInput,@funct</span><br><span class="line">LLVMFuzzerTestOneInput:                 				# @LL	LLVMFuzzerTestOneInput:                 				# @LL</span><br><span class="line">	.cfi_startproc										.cfi_startproc</span><br><span class="line"># %bb.0:												# %bb.0:</span><br><span class="line">	pushq	%rbp										pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16								.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16								.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp									movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp							.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$64, %rsp		      					&lt;</span><br><span class="line">	movb	.L__sancov_gen_(%rip), %al    			&lt;</span><br><span class="line">	addb	$1, %al			     	 				&lt;</span><br><span class="line">	movb	%al, .L__sancov_gen_(%rip)    			&lt;</span><br><span class="line">	movq	%rdi, -8(%rbp)								movq	%rdi, -8(%rbp)</span><br><span class="line">	movq	%rsi, -16(%rbp)								movq	%rsi, -16(%rbp)</span><br><span class="line">	movq	-16(%rbp), %rsi		      				|	cmpq	$16, -16(%rbp)</span><br><span class="line">	movq	%rsi, -40(%rbp)               			&lt;</span><br><span class="line">	movl	$16, %edi		     					&lt;</span><br><span class="line">	callq	__sanitizer_cov_trace_const_c 			&lt;</span><br><span class="line">	movq	-40(%rbp), %rax               			&lt;</span><br><span class="line">	cmpq	$16, %rax		      					&lt;</span><br><span class="line">	jne	.LBB0_5											jne	.LBB0_5</span><br><span class="line"># %bb.1:												# %bb.1:</span><br><span class="line">	movq	-8(%rbp), %rax								movq	-8(%rbp), %rax</span><br><span class="line">	movq	%rax, -32(%rbp)								movq	%rax, -32(%rbp)</span><br><span class="line">	movq	-32(%rbp), %rax								movq	-32(%rbp), %rax</span><br><span class="line">	movq	(%rax), %rdi		      				|	movq	(%rax), %rax</span><br><span class="line">	movq	%rdi, -48(%rbp)               			|	movq	-32(%rbp), %rcx</span><br><span class="line">	movq	-32(%rbp), %rax		      				|	cmpq	8(%rcx), %rax</span><br><span class="line">	movq	8(%rax), %rsi		      				&lt;</span><br><span class="line">	movq	%rsi, -56(%rbp)               			&lt;</span><br><span class="line">	callq	__sanitizer_cov_trace_cmp8@PL 			&lt;</span><br><span class="line">	movq	-56(%rbp), %rcx               			&lt;</span><br><span class="line">	movq	-48(%rbp), %rax               			&lt;</span><br><span class="line">	cmpq	%rcx, %rax		      					&lt;</span><br><span class="line">	jne	.LBB0_3											jne	.LBB0_3</span><br><span class="line">.Ltmp0:                                 # Blo 		&lt;</span><br><span class="line"># %bb.2:												# %bb.2:</span><br><span class="line">	movb	.L__sancov_gen_+1(%rip), %al  			&lt;</span><br><span class="line">	addb	$1, %al			      					&lt;</span><br><span class="line">	movb	%al, .L__sancov_gen_+1(%rip)  			&lt;</span><br><span class="line">	movq	$1997, -24(%rbp)             				movq	$1997, -24(%rbp)             </span><br><span class="line">	jmp	.LBB0_4											jmp	.LBB0_4</span><br><span class="line">.Ltmp1:                                 # Blo 		&lt;</span><br><span class="line">.LBB0_3:												.LBB0_3:</span><br><span class="line">	movb	.L__sancov_gen_+2(%rip), %al  			&lt;</span><br><span class="line">	addb	$1, %al			      					&lt;</span><br><span class="line">	movb	%al, .L__sancov_gen_+2(%rip)  			&lt;</span><br><span class="line">	movq	$6, -24(%rbp)								movq	$6, -24(%rbp)</span><br><span class="line">.LBB0_4:												.LBB0_4:</span><br><span class="line">	jmp	.LBB0_6											jmp	.LBB0_6</span><br><span class="line">.Ltmp2:                                 # Blo 		&lt;</span><br><span class="line">.LBB0_5:												.LBB0_5:</span><br><span class="line">	movb	.L__sancov_gen_+3(%rip), %al  			&lt;</span><br><span class="line">	addb	$1, %al			      					&lt;</span><br><span class="line">	movb	%al, .L__sancov_gen_+3(%rip)  			&lt;</span><br><span class="line">	movq	$23, -24(%rbp)								movq	$23, -24(%rbp)</span><br><span class="line">.LBB0_6:												.LBB0_6:</span><br><span class="line">	xorl	%eax, %eax									xorl	%eax, %eax</span><br><span class="line">	addq	$64, %rsp		      					&lt;</span><br><span class="line">	popq	%rbp										popq	%rbp</span><br><span class="line">	.cfi_def_cfa %rsp, 8								.cfi_def_cfa %rsp, 8</span><br><span class="line">	retq												retq</span><br><span class="line">.Lfunc_end0:											.Lfunc_end0:</span><br><span class="line">	.size	LLVMFuzzerTestOneInput, .Lfun	.size	LLVMFuzzerTestOneInput, .Lfun</span><br><span class="line">	.cfi_endproc										.cfi_endproc</span><br><span class="line">                                        # -- 	                                        # -- </span><br><span class="line">	.section	.text.sancov.module_c 				&lt;</span><br><span class="line">	.p2align	4, 0x90               				&lt;</span><br><span class="line">	.type	sancov.module_ctor_8bit_count 			&lt;</span><br><span class="line">sancov.module_ctor_8bit_counters:       # @sa 		&lt;</span><br><span class="line">	.cfi_startproc			      					&lt;</span><br><span class="line"># %bb.0:				      						&lt;</span><br><span class="line">	pushq	%rbp			      					&lt;</span><br><span class="line">	.cfi_def_cfa_offset 16		      				&lt;</span><br><span class="line">	.cfi_offset %rbp, -16		      				&lt;</span><br><span class="line">	movq	%rsp, %rbp		      					&lt;</span><br><span class="line">	.cfi_def_cfa_register %rbp	      				&lt;</span><br><span class="line">	movq	__start___sancov_cntrs@GOTPCR 			&lt;</span><br><span class="line">	movq	__stop___sancov_cntrs@GOTPCRE 			&lt;</span><br><span class="line">	callq	__sanitizer_cov_8bit_counters 			&lt;</span><br><span class="line">	movq	__start___sancov_pcs@GOTPCREL 			&lt;</span><br><span class="line">	movq	__stop___sancov_pcs@GOTPCREL( 			&lt;</span><br><span class="line">	callq	__sanitizer_cov_pcs_init@PLT  			&lt;</span><br><span class="line">	popq	%rbp			      					&lt;</span><br><span class="line">	.cfi_def_cfa %rsp, 8		      				&lt;</span><br><span class="line">	retq				      						&lt;</span><br><span class="line">.Lfunc_end1:				      					&lt;</span><br><span class="line">	.size	sancov.module_ctor_8bit_count 			&lt;</span><br><span class="line">	.cfi_endproc			      					&lt;</span><br><span class="line">                                        # --  		&lt;</span><br><span class="line">	.type	.L__sancov_gen_,@object       			&lt;</span><br><span class="line">	.section	__sancov_cntrs,&quot;aGw&quot;, 				&lt;</span><br><span class="line">.L__sancov_gen_:			      					&lt;</span><br><span class="line">	.zero	4			      						&lt;</span><br><span class="line">	.size	.L__sancov_gen_, 4	      				&lt;</span><br><span class="line">					      							&lt;</span><br><span class="line">	.type	.L__sancov_gen_.1,@object     			&lt;</span><br><span class="line">	.section	__sancov_pcs,&quot;aGw&quot;,@p 				&lt;</span><br><span class="line">	.p2align	3		      						&lt;</span><br><span class="line">.L__sancov_gen_.1:			      					&lt;</span><br><span class="line">	.quad	LLVMFuzzerTestOneInput	      			&lt;</span><br><span class="line">	.quad	1			      						&lt;</span><br><span class="line">	.quad	.Ltmp0			      					&lt;</span><br><span class="line">	.quad	0			      						&lt;</span><br><span class="line">	.quad	.Ltmp1			      					&lt;</span><br><span class="line">	.quad	0			      						&lt;</span><br><span class="line">	.quad	.Ltmp2			      					&lt;</span><br><span class="line">	.quad	0			      						&lt;</span><br><span class="line">	.size	.L__sancov_gen_.1, 64	      			&lt;</span><br><span class="line">					      							&lt;</span><br><span class="line">	.hidden	__start___sancov_cntrs	      			&lt;		</span><br><span class="line">	.hidden	__stop___sancov_cntrs	      			&lt;</span><br><span class="line">	.section	.init_array.2,&quot;aGw&quot;,@ 				&lt;</span><br><span class="line">	.p2align	3		      						&lt;</span><br><span class="line">	.quad	sancov.module_ctor_8bit_count 			&lt;</span><br><span class="line">	.hidden	__start___sancov_pcs	      			&lt;</span><br><span class="line">	.hidden	__stop___sancov_pcs	      				&lt;</span><br><span class="line">	.weak	__start___sancov_cntrs	      			&lt;</span><br><span class="line">	.weak	__stop___sancov_cntrs	      			&lt;</span><br><span class="line">	.weak	__start___sancov_pcs	      			&lt;</span><br><span class="line">	.weak	__stop___sancov_pcs	      				&lt;</span><br><span class="line">	.ident	&quot;Ubuntu clang version 14.0.0-			.ident	&quot;Ubuntu clang version 14.0.0-</span><br><span class="line">	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,				.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,</span><br><span class="line">	.addrsig					.addrsig</span><br><span class="line">	.addrsig_sym LLVMFuzzerTestOneInput   			&lt;</span><br><span class="line">	.addrsig_sym __sanitizer_cov_trace_cm 			&lt;</span><br><span class="line">	.addrsig_sym __sanitizer_cov_trace_co 			&lt;</span><br><span class="line">	.addrsig_sym __sanitizer_cov_8bit_cou 			&lt;</span><br><span class="line">	.addrsig_sym sancov.module_ctor_8bit_ 			&lt;</span><br><span class="line">	.addrsig_sym __sanitizer_cov_pcs_init 			&lt;</span><br><span class="line">	.addrsig_sym .L__sancov_gen_	      			&lt;</span><br><span class="line">	.addrsig_sym .L__sancov_gen_.1	      			&lt;</span><br><span class="line">	.addrsig_sym __start___sancov_cntrs   			&lt;</span><br><span class="line">	.addrsig_sym __stop___sancov_cntrs    			&lt;</span><br><span class="line">	.addrsig_sym __start___sancov_pcs     			&lt;</span><br><span class="line">	.addrsig_sym __stop___sancov_pcs      			&lt;</span><br></pre></td></tr></table></figure>

<p>第21-26行，第一条cmp指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movq	-16(%rbp), %rsi		      				|	cmpq	$16, -16(%rbp)</span><br><span class="line">movq	%rsi, -40(%rbp)               			&lt;</span><br><span class="line">movl	$16, %edi		     					&lt;</span><br><span class="line">callq	__sanitizer_cov_trace_const_c 			&lt;</span><br><span class="line">movq	-40(%rbp), %rax               			&lt;</span><br><span class="line">cmpq	$16, %rax		      					&lt;</span><br></pre></td></tr></table></figure>

<p>原指令<code>cmpq	$16, -16(%rbp)</code>经过选项<code>-fsanitizefuzzer</code>后被替换为上述左侧的一系列代码，其中注意到<code>callq	__sanitizer_cov_trace_const_c</code></p>
<p>第34-41行，第二条cmp指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movq	-32(%rbp), %rax		      				|	cmpq	8(%rcx), %rax</span><br><span class="line">movq	8(%rax), %rsi		      				&lt;</span><br><span class="line">movq	%rsi, -56(%rbp)               			&lt;</span><br><span class="line">callq	__sanitizer_cov_trace_cmp8@PL 			&lt;</span><br><span class="line">movq	-56(%rbp), %rcx               			&lt;</span><br><span class="line">movq	-48(%rbp), %rax               			&lt;</span><br><span class="line">cmpq	%rcx, %rax		      					&lt;</span><br><span class="line">jne	.LBB0_3											jne	.LBB0_3</span><br></pre></td></tr></table></figure>

<p>这里的cmp指令也是类似的，由此可见，-fsanitize&#x3D;fuzzer会对cmp指令进行类似插桩处理。</p>
<p>另外在每个程序的执行分支可以看到类似的计数变量</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/7.png" class="">

<p>从上图中可以得知在主干以及各个执行分支设置了该分支的执行次数。libfuzzer通过迭代不断循环执行，每次执行到相应的执行分支则会相应的增加分支的执行计数，借此来判断代码覆盖率。</p>
<br>

<h5 id="汇编阶段-c"><a href="#汇编阶段-c" class="headerlink" title="汇编阶段 -c"></a>汇编阶段 -c</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -c -o without-fuzzer2.o compiler-with-fuzzer.s</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -c -fsanitize=fuzzer -o with-fuzzer.o compiler-with-fuzzer.s</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sha1sum</span> with-fuzzer.o without-fuzzer.o</span></span><br><span class="line">7eae5d86e15d4f3c8c813cd4812616fd67fbd262  with-fuzzer.o</span><br><span class="line">7eae5d86e15d4f3c8c813cd4812616fd67fbd262  without-fuzzer.o</span><br></pre></td></tr></table></figure>

<p>可以看到sha1sum出来两个文件的值一样说明汇编阶段在加入选项-fsanitize&#x3D;fuzzer不起作用了，做下对照另外</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -c -o without-fuzzer.o compiler-without-fuzzer.s</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm with-fuzzer.o without-fuzzer.o</span></span><br><span class="line"></span><br><span class="line">with-fuzzer.o:</span><br><span class="line">0000000000000000 T LLVMFuzzerTestOneInput</span><br><span class="line">0000000000000000 t sancov.module_ctor_8bit_counters</span><br><span class="line">                 U __sanitizer_cov_8bit_counters_init</span><br><span class="line">                 U __sanitizer_cov_pcs_init</span><br><span class="line">                 U __sanitizer_cov_trace_cmp8</span><br><span class="line">                 U __sanitizer_cov_trace_const_cmp8</span><br><span class="line">                 w __start___sancov_cntrs</span><br><span class="line">                 w __start___sancov_pcs</span><br><span class="line">                 w __stop___sancov_cntrs</span><br><span class="line">                 w __stop___sancov_pcs</span><br><span class="line"></span><br><span class="line">without-fuzzer.o:</span><br><span class="line">0000000000000000 T LLVMFuzzerTestOneInput</span><br></pre></td></tr></table></figure>

<p>查看到-fsanitize&#x3D;fuzzer 会再编译阶段 添加一些外部符号</p>
<br>

<h5 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h5><p>由于变异的是C语言，很容易发现源文件中缺乏main函数，显然这部分是在libfuzzer补齐结构的，再加上添加了-fsanitize&#x3D;fuzzer会引入外部的一些符号，这都使得为什么只有</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang <span class="attr">-fsanitize=fuzzer</span> -o <span class="keyword">with</span>-fuzzer <span class="keyword">with</span>-fuzzer.o</span><br></pre></td></tr></table></figure>

<p>可以编译成功。随后即可利用编译出来的可执行程序执行fuzz。这里由于源码中没有配置crash捕获的选项，也没有添加运行时的检测工具，因此也只是会一直跑</p>
<br>

<h4 id="example4-2"><a href="#example4-2" class="headerlink" title="example4.2"></a>example4.2</h4><p>target function源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="keyword">auto</span> kMagicHeader = <span class="string">&quot;ZN_2016&quot;</span>;</span><br><span class="line">constexpr <span class="built_in">std</span>::<span class="type">size_t</span> kMaxPacketLen = <span class="number">1024</span>;</span><br><span class="line">constexpr <span class="built_in">std</span>::<span class="type">size_t</span> kMaxBodyLength = <span class="number">1024</span> - <span class="keyword">sizeof</span>(kMagicHeader);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">VulnerableFunction2</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, <span class="type">bool</span> verify_hash)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(kMagicHeader))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">header</span><span class="params">(reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), <span class="keyword">sizeof</span>(kMagicHeader))</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">uint8_t</span>, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kMagicHeader, header.c_str()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; kMaxPacketLen)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!verify_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::copy(data, data + size, body.data());</span><br><span class="line">  <span class="keyword">auto</span> real_hash = DummyHash(body);</span><br><span class="line">  <span class="keyword">return</span> real_hash == target_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到漏洞函数<code>VulnerableFunction2</code>比接口函数<code>LLVMFuzzerTestOneInput</code>多了一个参数<code>bool verify_hash</code>仅从字面上看，该参数用于指示是否开启<code>verify_hash</code></p>
<br>

<p>了解了目标函数的参数之后，我们可以暂时不关系内部的函数细节，专注于编写fuzzer接口将数据从libfuzzer的库中传递到目标函数，这里看下workshop&#x2F;04&#x2F;second_fuzz.cc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  VulnerableFunction2(data, size, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在关键的第7行位置，写死了第三个参数为false，这样会导致什么 ？—fuzzer<code>先天不足</code>只会测试<code>verify_hash = false</code>的一些分支，对于代码中需要<code>verify_hash</code>为true的分支为先决条件的代码块无法进行测试，先编译执行second_fuzzer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -fsanitize=fuzzer,address -g -o second_fuzzer second_fuzzer.cc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./second_fuzzer  ./corpus2</span></span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 300059996</span><br><span class="line">INFO: Loaded 1 modules   (37 inline 8-bit counters): 37 [0x55b036df6f48, 0x55b036df6f6d), </span><br><span class="line">INFO: Loaded 1 PC tables (37 PCs): 37 [0x55b036df6f70,0x55b036df71c0), </span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2	INITED cov: 3 ft: 4 corp: 1/1b <span class="built_in">exec</span>/s: 0 rss: 30Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">459	NEW    cov: 4 ft: 5 corp: 2/9b lim: 8 <span class="built_in">exec</span>/s: 0 rss: 30Mb L: 8/8 MS: 2 InsertRepeatedBytes-CopyPart-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1294	NEW    cov: 5 ft: 6 corp: 3/18b lim: 14 <span class="built_in">exec</span>/s: 0 rss: 31Mb L: 9/9 MS: 5 ChangeBit-CrossOver-InsertByte-CopyPart-CMP- DE: <span class="string">&quot;ZN_2016&quot;</span>-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3155	REDUCE cov: 5 ft: 6 corp: 3/17b lim: 29 <span class="built_in">exec</span>/s: 0 rss: 31Mb L: 8/8 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2097152	pulse  cov: 5 ft: 6 corp: 3/17b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 182Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4194304	pulse  cov: 5 ft: 6 corp: 3/17b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 330Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8388608	pulse  cov: 5 ft: 6 corp: 3/17b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 540Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16777216	pulse  cov: 5 ft: 6 corp: 3/17b lim: 4096 <span class="built_in">exec</span>/s: 1118481 rss: 541Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">33554432	pulse  cov: 5 ft: 6 corp: 3/17b lim: 4096 <span class="built_in">exec</span>/s: 1157049 rss: 543Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure>

<p>我们可以从上边的输出中发现，fuzzer状态处于<code>pulse</code>，并且在编号<code>#3115</code>的输入时达到了<code>覆盖率5</code>，随后不管怎么，甚至到了<code>#33554432</code>，也没能产生有效的触发新代码块的输入，也就是说投入产出很低很低..显然这是不对劲的。那么相应的修改思路有了，且看example4.3</p>
<br>

<h4 id="example4-3"><a href="#example4-3" class="headerlink" title="example4.3"></a>example4.3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> verify_hash_flags[] = &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> flag : verify_hash_flags)</span><br><span class="line">    VulnerableFunction2(data, size, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到做出的修正是使得目标函数<code>VulnerableFunction2</code>的第三个参数<code>flag</code>可变动，由于只有两个取值，因此可以使用bool类型即可，(更多就使用数组？ –个人理解)，编译，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./third_fuzzer ./corpus2/</span> </span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 532650920</span><br><span class="line">INFO: Loaded 1 modules   (39 inline 8-bit counters): 39 [0x5581bcedcf88, 0x5581bcedcfaf), </span><br><span class="line">INFO: Loaded 1 PC tables (39 PCs): 39 [0x5581bcedcfb0,0x5581bcedd220), </span><br><span class="line">INFO:        0 files found in ./corpus2/</span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2	INITED cov: 5 ft: 6 corp: 1/1b <span class="built_in">exec</span>/s: 0 rss: 30Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3	NEW    cov: 5 ft: 7 corp: 2/2b lim: 4 <span class="built_in">exec</span>/s: 0 rss: 31Mb L: 1/1 MS: 1 ShuffleBytes-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">445	NEW    cov: 6 ft: 8 corp: 3/10b lim: 8 <span class="built_in">exec</span>/s: 0 rss: 31Mb L: 8/8 MS: 2 CrossOver-InsertRepeatedBytes-</span></span><br><span class="line">	NEW_FUNC[1/15]: 0x5581bce995b0 in unsigned char* std::copy&lt;unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_algobase.h:612</span><br><span class="line">	NEW_FUNC[2/15]: 0x5581bce99640 in std::array&lt;unsigned char, 1016ul&gt;::data() /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/array:258</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13124	NEW    cov: 26 ft: 29 corp: 4/19b lim: 128 <span class="built_in">exec</span>/s: 0 rss: 32Mb L: 9/9 MS: 4 ChangeBinInt-InsertByte-CMP-CMP- DE: <span class="string">&quot;\000\000\000\000\000\000\000\010&quot;</span>-<span class="string">&quot;ZN_2016&quot;</span>-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15535	REDUCE cov: 26 ft: 29 corp: 4/18b lim: 149 <span class="built_in">exec</span>/s: 0 rss: 32Mb L: 8/8 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2097152	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 184Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4194304	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 336Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8388608	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 1048576 rss: 569Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16777216	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 986895 rss: 571Mb</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13124	NEW    cov: 26 ft: 29 corp: 4/19b lim: 128 <span class="built_in">exec</span>/s: 0 rss: 32Mb L: 9/9 MS: 4 ChangeBinInt-InsertByte-CMP-CMP-</span></span><br></pre></td></tr></table></figure>

<p>仅到<code>#13124</code>个样本达到了从语料库采集的<code>4个样本，大小占19b</code>却覆盖到了<code>26个代码块</code>的程度，占用内存<code>仅32Mb</code>，这个表现比先前限制了第三个参数优秀很多,可见，接口的合理编写对于fuzzer有多么重要！。</p>
<p>随着fuzzer的运行，后续输出都没有出想要的新进展，比如新路径，crash etc..</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2097152	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 699050 rss: 183Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4194304	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 699050 rss: 335Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8388608	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 699050 rss: 567Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16777216	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 838860 rss: 569Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">33554432	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 906876 rss: 569Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">67108864	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 945195 rss: 569Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">134217728	pulse  cov: 26 ft: 29 corp: 4/18b lim: 4096 <span class="built_in">exec</span>/s: 965595 rss: 569Mb</span></span><br></pre></td></tr></table></figure>

<p>其中，在项目的README.md文档中，找到需要进一步改进的位置，就是上述直接启动fuzzer的如下的提示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br></pre></td></tr></table></figure>

<p>大致是<code>-max_len</code>字段为提供，libfuzzer均衡考虑之下不会生成大于4096bytes的样本</p>
<p>由于项目运维者提供的示例是fuzzer的target是叫<code>ZN_2016</code>的协议（具体也不知道是啥），项目组经过分析，知道了这个协议的可能包长度最大可达1024bytes，因此可以在执行fuzzer中指明这个<code>-max_len</code>从而更加高效的执行我们的fuzzer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./third_fuzzer ./corpus2 -max_len=1024</span></span><br></pre></td></tr></table></figure>

<p>后续出现</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/8.png" class="">

<br>

<h4 id="example4-4"><a href="#example4-4" class="headerlink" title="example4.4"></a>example4.4</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> kZn2016VerifyHashFlag = <span class="number">0x0001000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VulnerableFunction3</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size, std::<span class="type">size_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">VulnerableFunction2</span>(data, size, verify_hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实相较example4.2中，target先是对第三个参数做了 &amp; 运算，处理完再传递给我们的target-function</p>
<p>面对这种情况，可以利用libfuzzer生成的data + size 制造这个第三参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::string <span class="title">data_string</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), size)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> data_hash = std::<span class="built_in">hash</span>&lt;std::string&gt;()(data_string);</span><br><span class="line"></span><br><span class="line">  std::<span class="type">size_t</span> flags = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(data_hash);</span><br><span class="line">  <span class="built_in">VulnerableFunction3</span>(data, size, flags);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口将libfuzzer生成的size长度的data字节串进行强制转换，并使用hash运算模拟<code>bool verify_hash = flags &amp; kZn2016VerifyHashFlag</code>随机地制造<code>五五开bool值</code> <strong>可以看到好的fuzzer是需要模仿target的行为构造数据传递</strong></p>
<br>



<h3 id="Heartbleed"><a href="#Heartbleed" class="headerlink" title="Heartbleed"></a>Heartbleed</h3><blockquote>
<p>对应workshop项目的lesson 05</p>
</blockquote>
<p>项目中举出这个被google&#x2F;fuzzer-stest-suite项目收录的演示漏洞：<a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite.git">项目地址</a></p>
<p>前边的学习，我们知道了需要在编译过程中接入Libfuzzer，因此这里需要找到Heartbleed的漏洞版本源码自行编译出可执行文件。</p>
<br>

<h4 id="编译漏洞版本openssl"><a href="#编译漏洞版本openssl" class="headerlink" title="编译漏洞版本openssl"></a>编译漏洞版本openssl</h4><p>libfuzzer-workshop中自带了漏洞版本的源码包。这里找了openssl官网的对应版本：<a target="_blank" rel="noopener" href="https://www.openssl.org/source/old/1.0.1/">链接点我</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">libfuzzer-workshop/lessons/05$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">openssl1.0.1f.tgz  openssl_fuzzer.cc  README.md  server.key  server.pem</span><br><span class="line"><span class="meta prompt_">libfuzzer-workshop/lessons/05$ </span><span class="language-bash">tar xzf openssl1.0.1f.tgz</span> </span><br><span class="line"><span class="meta prompt_">libfuzzer-workshop/lessons/05$ </span><span class="language-bash"><span class="built_in">cd</span> openssl1.0.1f/</span></span><br></pre></td></tr></table></figure>

<p>查看源码里的东西</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/9.png" class="">

<p>可以看到，项目使用了config来生成makefile，执行.&#x2F;config即可完成makefile生成</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/10.png" class="">

<p>有了makefile等文件，可以使用make命令完成项目编译，在make的选项中加入编译参数，使得编译出的来的可执行文件可以接入Libfuzzer</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/11.png" class="">

<p>发现该项目是用的是gcc编译器，实际上在进行make编译的时候，可以进行指定的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer-no-link -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot; -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>上述指令，指明了即将使用的clang编译器以及clang将要使用的一系列参数，最后<code>-j$(nproc)</code>这里是指定当前系统下用户可以执行的线程数，这是为了快速完成编译而设置的。</p>
<ul>
<li>-<code>fsanitize</code>：指定内存检测工具以及告诉clang编译器，编译时接入libfuzzer</li>
<li><code>-fsanitize-coverage</code>：指定检测代码覆盖率的策略</li>
<li><code>-fno-omit-frame-pointer</code>： 对于不需要栈指针的函数就不在寄存器中保存指针，因此可以忽略存储和检索地址的代码，同时对许多函数提供一个额外的寄存器。所有”-O”级别都打开它，但仅在调试器可以不依靠栈指针运行时才有效。在AMD64平台上此选项默认打开，但是在x86平台上则默认关闭。<strong>建议显式的设置它。</strong></li>
<li><code>-O</code>：编译时的优化级别，这里是2</li>
<li><code>-g</code> ：保留编译过程中的调试符号</li>
</ul>
<p>执行，等待程序编译完成。</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/12.png" class="">

<br>

<h4 id="fuzzer编写"><a href="#fuzzer编写" class="headerlink" title="fuzzer编写"></a>fuzzer编写</h4><p>编译出附加了运行监测工具以及对接libfuzzer的可执行程序之后，我们需要开始编写fuzzer脚本了，项目中提供了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CERT_PATH</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CERT_PATH</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SSL_CTX *<span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SSL_library_init</span>();</span><br><span class="line">  <span class="built_in">SSL_load_error_strings</span>();</span><br><span class="line">  <span class="built_in">ERR_load_BIO_strings</span>();</span><br><span class="line">  <span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  <span class="built_in">assert</span> (sctx = <span class="built_in">SSL_CTX_new</span>(<span class="built_in">TLSv1_method</span>()));</span><br><span class="line">  <span class="comment">/* These two file were created with this command:</span></span><br><span class="line"><span class="comment">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span></span><br><span class="line"><span class="comment">     -out server.pem -days 9999 -nodes -subj /CN=a/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_certificate_file</span>(sctx, CERT_PATH <span class="string">&quot;server.pem&quot;</span>,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">SSL_CTX_use_PrivateKey_file</span>(sctx, CERT_PATH <span class="string">&quot;server.key&quot;</span>,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="keyword">return</span> sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> SSL_CTX *sctx = <span class="built_in">Init</span>();</span><br><span class="line">  SSL *server = <span class="built_in">SSL_new</span>(sctx);</span><br><span class="line">  BIO *sinbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  BIO *soutbio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">  <span class="built_in">SSL_set_bio</span>(server, sinbio, soutbio);</span><br><span class="line">  <span class="built_in">SSL_set_accept_state</span>(server);</span><br><span class="line">  <span class="built_in">BIO_write</span>(sinbio, data, size);</span><br><span class="line">  <span class="built_in">SSL_do_handshake</span>(server);</span><br><span class="line">  <span class="built_in">SSL_free</span>(server);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于脚本的编写是针对target的运行细节的，这里不深究，只是讨论libfuzzer 的用法，只需要大概知道openssl的功能</p>
<ul>
<li>初始化SSL_CTX</li>
<li>SSL_new创建会话</li>
<li>设置好管道后SSL_set_accept_state接入</li>
<li>BIO_write往管道写入libfuzzer生成的内容，尝试fuzzer这里</li>
<li>传输完内容，则断开连接</li>
</ul>
<p>大致功能如上</p>
<br>

<h5 id="编译fuzzer"><a href="#编译fuzzer" class="headerlink" title="编译fuzzer"></a>编译fuzzer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer \</span><br><span class="line">    -fsanitize-coverage=trace-cmp,trace-gep,trace-div \</span><br><span class="line">    -I openssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \</span><br><span class="line">    -o openssl_fuzzer</span><br></pre></td></tr></table></figure>

<ul>
<li>-I 指定需要的头文件</li>
</ul>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/13.png" class="">

<h5 id="运行fuzzer-1"><a href="#运行fuzzer-1" class="headerlink" title="运行fuzzer"></a>运行fuzzer</h5><img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/14.png" class="">

<p>原来是trace-pc-guard不再支持了，重新编译，不加入trace-pc-guard</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/15.png" class="">

<p>再次运行，很快就出crash了：</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/16.png" class="">

<br>

<h5 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h5><p>根据crash的信息，我们知道了出问题的位置是在\openssl1.0.1f\ssl\t1_lib.c文件中的第2586行的位置</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/17.png" class="">

<p>定位到这个位置，这里直接贴一下当前的函数，方便后续说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">tls1_process_heartbeat</span><span class="params">(SSL *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;s-&gt;s3-&gt;rrec.data[<span class="number">0</span>], *pl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hbtype;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> payload;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> padding = <span class="number">16</span>; <span class="comment">/* Use minimum padding */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read type and payload length first */</span></span><br><span class="line">    hbtype = *p++;</span><br><span class="line">    n2s(p, payload);</span><br><span class="line">    pl = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;msg_callback)</span><br><span class="line">        s-&gt;msg_callback(<span class="number">0</span>, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">                        &amp;s-&gt;s3-&gt;rrec.data[<span class="number">0</span>], s-&gt;s3-&gt;rrec.length,</span><br><span class="line">                        s, s-&gt;msg_callback_arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hbtype == TLS1_HB_REQUEST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buffer, *bp;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate memory for the response, size is 1 bytes</span></span><br><span class="line"><span class="comment">		 * message type, plus 2 bytes payload length, plus</span></span><br><span class="line"><span class="comment">		 * payload, plus padding</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        buffer = OPENSSL_malloc(<span class="number">1</span> + <span class="number">2</span> + payload + padding);</span><br><span class="line">        bp = buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enter response type, length and copy payload */</span></span><br><span class="line">        *bp++ = TLS1_HB_RESPONSE;</span><br><span class="line">        s2n(payload, bp);</span><br><span class="line">        <span class="built_in">memcpy</span>(bp, pl, payload);</span><br><span class="line">        bp += payload;</span><br><span class="line">        <span class="comment">/* Random padding */</span></span><br><span class="line">        RAND_pseudo_bytes(bp, padding);</span><br><span class="line"></span><br><span class="line">        r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, <span class="number">3</span> + payload + padding);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; s-&gt;msg_callback)</span><br><span class="line">            s-&gt;msg_callback(<span class="number">1</span>, s-&gt;version, TLS1_RT_HEARTBEAT,</span><br><span class="line">                            buffer, <span class="number">3</span> + payload + padding,</span><br><span class="line">                            s, s-&gt;msg_callback_arg);</span><br><span class="line"></span><br><span class="line">        OPENSSL_free(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hbtype == TLS1_HB_RESPONSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We only send sequence numbers (2 bytes unsigned int),</span></span><br><span class="line"><span class="comment">		 * and 16 random bytes, so we just try to read the</span></span><br><span class="line"><span class="comment">		 * sequence number */</span></span><br><span class="line">        n2s(pl, seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (payload == <span class="number">18</span> &amp;&amp; seq == s-&gt;tlsext_hb_seq)</span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;tlsext_hb_seq++;</span><br><span class="line">            s-&gt;tlsext_hb_pending = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于漏洞类型是overfload，并且是由memcpy引起的，很容易就知道往memcpy的第三个参数payload入手，并且这个值得是我们可控的（和libfuzzer传入的data 或 size有关联）才行，因此在函数内定位paylaod的传递过程，这里定位到第11行位置的<code> n2s(p, payload);</code>因为他和当前的函数的输入有关联。看下传递过程中的关键语句：<code>unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0]</code>可以看到p是引用了传入参数的<code>SSL s</code>的内容。</p>
<p>跟踪SSL，来到openssl1.0.1f\crypto\ossl_typ.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl_st</span> <span class="title">SSL</span>;</span></span><br></pre></td></tr></table></figure>

<p>顺藤摸瓜ssl_st，来到\openssl1.0.1f\ssl\ssl.h，内容有点多，只截取相关部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ssl_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ssl3_state_st</span> *<span class="title">s3</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续，来到\openssl1.0.1f\ssl\ssl3.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl3_state_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    SSL3_RECORD rrec;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来到同文件下的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ssl3_record_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*r */</span>	<span class="type">int</span> type;               <span class="comment">/* type of record */</span></span><br><span class="line">    <span class="comment">/*rw*/</span>	<span class="type">unsigned</span> <span class="type">int</span> length;    <span class="comment">/* How many bytes available */</span></span><br><span class="line">    <span class="comment">/*r */</span>	<span class="type">unsigned</span> <span class="type">int</span> off;       <span class="comment">/* read/write offset into &#x27;buf&#x27; */</span></span><br><span class="line">    <span class="comment">/*rw*/</span>	<span class="type">unsigned</span> <span class="type">char</span> *data;    <span class="comment">/* pointer to the record data */</span></span><br><span class="line">    <span class="comment">/*rw*/</span>	<span class="type">unsigned</span> <span class="type">char</span> *input;   <span class="comment">/* where the decode bytes are */</span></span><br><span class="line">    <span class="comment">/*r */</span>	<span class="type">unsigned</span> <span class="type">char</span> *comp;    <span class="comment">/* only used with decompression - malloc()ed */</span></span><br><span class="line">    <span class="comment">/*r */</span>  <span class="type">unsigned</span> <span class="type">long</span> epoch;    <span class="comment">/* epoch number, needed by DTLS1 */</span></span><br><span class="line">    <span class="comment">/*r */</span>  <span class="type">unsigned</span> <span class="type">char</span> seq_num[<span class="number">8</span>]; <span class="comment">/* sequence number, needed by DTLS1 */</span></span><br><span class="line">&#125; SSL3_RECORD;</span><br></pre></td></tr></table></figure>

<p>根据异常时的调用链：LLVMFuzzerTestOneInput -&gt; ssl3_accept -&gt; ssl3_get_client_hello -&gt; ssl3_get_message -&gt; ssl3_read_bytes -&gt; tls1_process_heartbeat  -&gt;__asan_memcpy</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/18.png" class="">

<br>



<h3 id="c-ares"><a href="#c-ares" class="headerlink" title="c-ares"></a>c-ares</h3><blockquote>
<p>对应workshop项目的lesson 06</p>
</blockquote>
<p>Libfuzzer-Workshop第6节的内容是复现一个已公布漏洞[c-ares] vulnerability (CVE-2016-5180) ，可以达到特权执行命令。例子同样收录在github项目google&#x2F;fuzzer-stest-suite</p>
<br>

<p>和No5的内容一样，我们需要下载漏洞版本，进行插桩版本的编译，在针对的去编写fuzzer脚本。</p>
<br>

<h4 id="Build-vulnerable-c-ares-ver"><a href="#Build-vulnerable-c-ares-ver" class="headerlink" title="Build vulnerable c-ares ver"></a>Build vulnerable c-ares ver</h4><p>进入06目录，解压压缩包后，执行.&#x2F;buildconf，生成configure文件</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/19.png" class="">

<p>缺失了文件，执行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt install libtool</span></span><br></pre></td></tr></table></figure>

<p>找不到对应的包，找了下解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt install aptitube</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo aptitube install libtool</span></span><br></pre></td></tr></table></figure>

<p>再次buildconf</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/20.png" class="">

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt install automake</span></span><br></pre></td></tr></table></figure>

<p>成功生成configure文件，执行，生成Makefile</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/21.png" class="">

<p>编译插桩版本的c-ares</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make CC=<span class="string">&quot;clang -O2 -g -fsanitize=address -fno-omit-frame-pointer -fsanitize-coverage=trace-gep,trace-div,trace-cmp&quot;</span></span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Build-and-run-Fuzzer"><a href="#Build-and-run-Fuzzer" class="headerlink" title="Build and run Fuzzer"></a>Build and run Fuzzer</h4><p>首先看下fuzzer的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2016 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/nameser.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ares.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">int</span> buflen;</span><br><span class="line">  <span class="function">std::string <span class="title">s</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data), size)</span></span>;</span><br><span class="line">  <span class="built_in">ares_create_query</span>(s.<span class="built_in">c_str</span>(), ns_c_in, ns_t_a, <span class="number">0x1234</span>, <span class="number">0</span>, &amp;buf, &amp;buflen, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">ares_free_string</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Fuzzer的源码上看，可以知道Fuzzer针对的是<code>ares_create_query</code>函数，在头文件中还包含运行需要的头文件。由此可见，编写相应的Fuzzer得知道target的行为，其次Fuzzer还根据target function的参数类型将Libfuzzer生成的模糊数据进行类型强制转换，接着传递给Target function。</p>
<ul>
<li>应当清楚的是Fuzzer递交数据的关键在于第13行，这里执行了强制转换，将libfuzzer生成的<strong>长度为size的data数据强制转化为string类型</strong></li>
</ul>
<br>

<h5 id="编译Fuzzer"><a href="#编译Fuzzer" class="headerlink" title="编译Fuzzer"></a>编译Fuzzer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g c_ares_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer </span><br><span class="line">    -fsanitize-coverage=trace-cmp,trace-gep,trace-div </span><br><span class="line">    -I c-ares c-ares/.libs/libcares.a -o c_ares_fuzzer</span><br></pre></td></tr></table></figure>

<h5 id="执行Fuzzer"><a href="#执行Fuzzer" class="headerlink" title="执行Fuzzer"></a>执行Fuzzer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir corpus</span><br><span class="line">./c_ares_fuzzer ./corpus</span><br></pre></td></tr></table></figure>

<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/22.png" class="">

<p>可以看到出问题的是<code>ares_create_query</code>函数， 类型为<code>heap-buffer-overflow</code></p>
<p>这边我的输出有些奇怪，不像项目组人员的<code>README.md</code>中描述的一致（以下为项目组的<code>README.md</code>内容）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==15515==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6030000470f5 at pc 0x0000004f1acf bp 0x7fff4e5b1310 sp 0x7fff4e5b1308</span><br><span class="line">WRITE of size 1 at 0x6030000470f5 thread T0</span><br><span class="line">    #0 0x4f1ace in ares_create_query /home/mmoroz/projects/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:196:3</span><br><span class="line">    #1 0x4f0684 in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/06/c_ares_fuzzer.cc:16:3</span><br></pre></td></tr></table></figure>

<p><code>#0</code>的位置会直接指出目标的函数的位置，这是在链接fuzzer的<code>-I</code>选项中指出的。直接从项目组提供的内容中，我们知道脆弱点在源文件<code>ares_create_query.c</code>中，但笔者的输出有些奇怪，libfuzzer没有给我定位到脆弱点，目前暂时不知道（留个坑吧）。</p>
<p>于是笔者只能从源码文件中尝试找到漏洞的触发点，实际上这部分也是在编写Fuzzer前我们需要了解的，有了相应的了解才能写出对应的Fuzzer，只不过出于学习的目的讲这个过程逆过来了。那怎么个逆法呢？，首先在源码中查找目标函数，在从参数定位到相应的位置</p>
<p>首先在源码目录中找出所有<code>ares_create_query</code>相关的位置</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/23.png" class="">

<p>上述省略了许多搜索到的结果，需要在这个基础上进一步缩小检索范围，于是定位到<code>ares_create_query.c</code>文件</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/24.png" class="">

<p>接着看到Fuzzer中生成的数据的流向，关键传参的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ares_create_query</span>(s.<span class="built_in">c_str</span>(), ns_c_in, ns_t_a, <span class="number">0x1234</span>, <span class="number">0</span>, &amp;buf, &amp;buflen, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>第1个参数，对应到函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ares_create_query</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> dnsclass, <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">short</span> id, 							<span class="type">int</span> rd, <span class="type">unsigned</span> <span class="type">char</span> **buf, <span class="type">int</span> *buflen, <span class="type">int</span> max_udp_size)</span></span></span><br></pre></td></tr></table></figure>

<p>是<code>const char *name</code>。那么在Fuzzer中对data进行强制转换后得到的string在传参过程中调用<code>s.c_str()</code>的行为就好理解了，这是为了契合函数原型的参数类型需要而进行的转换。</p>
<blockquote>
<p>const * char c_str() –  一个将string转换为 const* char的函数。</p>
</blockquote>
<hr>
<br>

<h3 id="Lesson-07"><a href="#Lesson-07" class="headerlink" title="Lesson 07"></a>Lesson 07</h3><blockquote>
<p>PPT-Reading ,关于提升libfuzzer的执行效率</p>
</blockquote>
<p>想想以下的使用场景，libfuzzer经常对一些模块功能进行测试，通常这些模块都是处理特定模块化信息的，例如会检测提交进来的数据是否符合某种结构，不符合则会终止程序的运行，当然fuzzer 测试到检测文件合法性的后续处理逻辑。举例子吧，比如要测试一个图片的查看器，虽然libfuzzer会生成一些随机数据进行fuzz，但这样总的来说效率很低，图片文件一般都有头部信息的标志位</p>
<ul>
<li>JPEG&#x2F;JPG - 文件头标识 (2 bytes): $ff, $d8 (SOI) (JPEG 文件标识) - 文件结束标识 (2 bytes): $ff, $d9 (EOI)</li>
<li>TGA - 未压缩的前5字节  00 00 02 00 00 - RLE压缩的前5字节  00 00 10 00 00</li>
<li>PNG - 文件头标识 (8 bytes)  89 50 4E 47 0D 0A 1A 0A   – （PNG对应十六进制串 50 4E 47）</li>
<li>GIF - 文件头标识 (6 bytes)  47 49 46 38 39(37) 61             G I F 8 9 (7) a</li>
<li>BMP - 文件头标识 (2 bytes)  42 4D             B M</li>
<li>PCX - 文件头标识 (1 bytes)  0A</li>
<li>TIFF - 文件头标识 (2 bytes) 4D 4D 或 49 49</li>
<li>ICO - 文件头标识 (8 bytes)  00 00 01 00 01 00 20 20</li>
<li>CUR - 文件头标识 (8 bytes)  00 00 02 00 01 00 20 20</li>
<li>IFF - 文件头标识 (4 bytes)  46 4F 52 4D             F O R M</li>
<li>ANI - 文件头标识 (4 bytes)  52 49 46 46             R I F F</li>
</ul>
<p>又比如在某些解析PE文件的库中，如python的pefile库，如果想要fuzz这个库，则需要相应的构造合理的数据进行传入。</p>
<p>再比如在fuzz一些协议时，往往需要构造对应协议可识别并处理的数据包，因此都需要构造相应合理的目标可接受的数据进行fuzz。</p>
<br>

<br>

<h4 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h4><ul>
<li>Dictionaries</li>
<li>Seed Corpus</li>
<li>Custom options</li>
<li>Fuzzing of non-raw data arguments</li>
<li>Optimization</li>
</ul>
<br>

<h4 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h4><p>lesson 7 中有个项目为libfuzzer 提供了生成测试用例的一部分可用字典（项目地址：<a target="_blank" rel="noopener" href="https://gitlab.com/AngleDeps/testing/-/tree/master/">click me</a>）</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/25.png" class="">

<p>也可以利用google&#x2F;fuzzing下的一些dictionaries，例如MP4的格式字典：</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/26.png" class="">

<p>libfuzzer的字典引入使用的是<code>-dict=PATH 2 DICT FILE</code></p>
<p>上述提到了，后续都会介绍</p>
<br>

<h3 id="提升Fuzzer效率"><a href="#提升Fuzzer效率" class="headerlink" title="提升Fuzzer效率"></a>提升Fuzzer效率</h3><blockquote>
<p>对应workshop Lesson 08</p>
</blockquote>
<ul>
<li>比对添加字典对Fuzzer 的效率的提升</li>
<li>语料库corpus的精简</li>
<li>生成覆盖率的report</li>
<li>检测Out-of-Memory错误以及内存泄漏</li>
</ul>
<p>测试的是target是<code>libxml2</code></p>
<br>

<h4 id="编译漏洞版本libxml2"><a href="#编译漏洞版本libxml2" class="headerlink" title="编译漏洞版本libxml2"></a>编译漏洞版本libxml2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xzf libxml2.tgz</span><br><span class="line">cd libxml2</span><br><span class="line"></span><br><span class="line">./autogen.sh</span><br></pre></td></tr></table></figure>

<p>这里采取的是将编译需要的clang参数写入临时的环境变量，并在之后.&#x2F;configure生成Makefile时将编译参数顺便设置好。</p>
<p>这里需要注意到是编译这个库是需要后续接入fuzzer脚本的，因此采取的是<code>fuzzer-no-link</code>（个人理解）</p>
<p>另外笔者在执行.&#x2F;autogen.sh生成configure文件是碰到了一下问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">checking whether to build static libraries... yes</span><br><span class="line">Checking zlib</span><br><span class="line">./configure: line 13070: syntax error near unexpected token `Z,zlib,&#x27;</span><br><span class="line">./configure: line 13070: `    PKG_CHECK_MODULES(Z,zlib,&#x27;</span><br><span class="line"></span><br><span class="line">Now type &#x27;make&#x27; to compile libxml2.</span><br></pre></td></tr></table></figure>

<p>可以看到生成configure失败，缺少了一部分文件，查询之下，发现缺少了pkg-config，安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt install pkg-config</span></span><br></pre></td></tr></table></figure>

<p>再次执行<code>./autogen.sh</code>，Successful</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FUZZ_CXXFLAGS=&quot;-O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer-no-link  -fsanitize-coverage=edge,indirect-calls,trace-cmp,trace-div,trace-gep&quot;</span><br><span class="line"></span><br><span class="line">CXX=&quot;clang++ $FUZZ_CXXFLAGS&quot; CC=&quot;clang $FUZZ_CXXFLAGS&quot;  CCLD=&quot;clang++ $FUZZ_CXXFLAGS&quot;  ./configure</span><br></pre></td></tr></table></figure>

<p>生成Makefile文件</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/27.png" class="">

<p>验证参数是否成功写入Makefile文件</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/28.png" class="">

<p>确实写入了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make -j$(<span class="built_in">nproc</span>)</span></span><br></pre></td></tr></table></figure>

<p>尽可能调用资源进行make编译</p>
<br>

<h4 id="First-Fuzzer"><a href="#First-Fuzzer" class="headerlink" title="First Fuzzer"></a>First Fuzzer</h4><p>target function: <code>xmlReadMemory</code></p>
<p>这个部分是最重要的其实，当前笔者处于学习阶段，想着分析别人是怎么写的，形成自己的思路在开发自己的fuzzer。</p>
<p>这里lesson 08中有fuzzer的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015 The Chromium Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/parser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ignore</span> <span class="params">(<span class="type">void</span>* ctx, <span class="type">const</span> <span class="type">char</span>* msg, ...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Error handler to avoid spam of error messages from libxml parser.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">xmlSetGenericErrorFunc</span>(<span class="literal">NULL</span>, &amp;ignore);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> doc = <span class="built_in">xmlReadMemory</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt; (data),  <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(size), <span class="string">&quot;noname.xml&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">xmlFreeDoc</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xmlSetGenericErrorFunc</code>被call是由于fuzzer必然会产生许多无效数据，这些数据进入target库处理会被进行错误捕获，为了精简输出内容，因此引入。</p>
<p>编译fuzzer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -std=c++11 xml_read_memory_fuzzer.cc -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer -fsanitize-coverage=edge,indirect-calls,trace-cmp,trace-div,trace-gep -I libxml2/include libxml2/.libs/libxml2.a -lz -llzma  -o xml_read_memory_fuzzer</span></span><br></pre></td></tr></table></figure>

<p>载入了编译出来的漏洞版本<code>libxml2</code> </p>
<blockquote>
<p>另外，由于需要引入依赖库的名字和地址，需要进行制定(这些库必须是由lib 字符做前缀的,然后在引入的时候需要-lxxx 导入库名字,小心注意这个坑），来自汤师兄的文章</p>
</blockquote>
<p>因此，这里引入的外部依赖库是libz liblzma，不引入则会报相应的错误</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/29.png" class="">

<p>相关依赖库在项目描述中一般会指出</p>
<br>

<h5 id="Run-without-dict"><a href="#Run-without-dict" class="headerlink" title="Run without dict"></a>Run without dict</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">mkdir</span> corpus1</span></span><br></pre></td></tr></table></figure>

<p>建立语料库，语料库的作用是fuzzer进行模糊数据的变异的，当一个测试用例相比先前的表现优秀（可能是体量更小，触发的代码覆盖率一致；又或者可以触发新的代码块…）会被放入语料库，用于作为之后变异测试用例生成的蓝本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./xml_read_memory_fuzzer -max_total_time=300 -print_final_stats=1 corpus1 -<span class="built_in">jobs</span>=2 -workers=2</span></span><br></pre></td></tr></table></figure>

<p>设置单个样本测试的时间为300，并且在fuzz退出时打印运行统计信息，使用语料库的目录为corpus1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1503340	DONE   cov: 2107 ft: 9967 corp: 3429/575Kb lim: 1110 <span class="built_in">exec</span>/s: 4994 rss: 558Mb</span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/30.png" class="">

<br>

<h5 id="Run-with-dict"><a href="#Run-with-dict" class="headerlink" title="Run with dict"></a>Run with dict</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./xml_read_memory_fuzzer -max_total_time=300 -dict=./xml.dict -print_final_stats=1 corpus2 -<span class="built_in">jobs</span>=2 -workers=2</span></span><br></pre></td></tr></table></figure>

<p><code>-dict=./xml.dict</code> 指定使用的字典</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1883423	DONE   cov: 3252 ft: 14437 corp: 5463/790Kb lim: 1070 <span class="built_in">exec</span>/s: 6257 rss: 574Mb</span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/31.png" class="">

<p>对比之下，发现载入字典的更容易构造出有效的测试用例，使得覆盖率存在差异2107(without dict) &gt; 3252(with dict)</p>
<p>因此字典的构造与选择可能有效提升fuzzer的效率。</p>
<br>

<h5 id="minimize-corpus"><a href="#minimize-corpus" class="headerlink" title="minimize corpus"></a>minimize corpus</h5><h6 id="corpus1"><a href="#corpus1" class="headerlink" title="corpus1"></a>corpus1</h6><p>此举将语料库中的测试用例喂给fuzzer，同时剔除覆盖相同路径的测试用例，比对，进行精简测试用例，结果是使得语料库体量变小，可用性不降低。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./xml_read_memory_fuzzer -merge=1 ./corpus1_min/ ./corpus1</span></span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 1378792090</span><br><span class="line">INFO: Loaded 1 modules   (53679 inline 8-bit counters): 53679 [0xd9b020, 0xda81cf), </span><br><span class="line">INFO: Loaded 1 PC tables (53679 PCs): 53679 [0xa1d6d0,0xaef1c0), </span><br><span class="line">MERGE-OUTER: 9223 files, 0 in the initial corpus, 0 processed earlier</span><br><span class="line">MERGE-OUTER: attempt 1</span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 1378859477</span><br><span class="line">INFO: Loaded 1 modules   (53679 inline 8-bit counters): 53679 [0xd9b020, 0xda81cf), </span><br><span class="line">INFO: Loaded 1 PC tables (53679 PCs): 53679 [0xa1d6d0,0xaef1c0), </span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes</span><br><span class="line">MERGE-INNER: using the control file &#x27;/tmp/libFuzzerTemp.Merge71764.txt&#x27;</span><br><span class="line">MERGE-INNER: 9223 total files; 0 processed earlier; will process 9223 files now</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1	pulse  cov: 464 ft: 465 <span class="built_in">exec</span>/s: 0 rss: 36Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2	pulse  cov: 474 ft: 528 <span class="built_in">exec</span>/s: 0 rss: 38Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4	pulse  cov: 505 ft: 565 <span class="built_in">exec</span>/s: 0 rss: 39Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8	pulse  cov: 520 ft: 666 <span class="built_in">exec</span>/s: 0 rss: 39Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16	pulse  cov: 634 ft: 818 <span class="built_in">exec</span>/s: 0 rss: 39Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">32	pulse  cov: 661 ft: 857 <span class="built_in">exec</span>/s: 0 rss: 40Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">64	pulse  cov: 739 ft: 1114 <span class="built_in">exec</span>/s: 0 rss: 41Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">128	pulse  cov: 843 ft: 1283 <span class="built_in">exec</span>/s: 0 rss: 44Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">256	pulse  cov: 1109 ft: 1753 <span class="built_in">exec</span>/s: 0 rss: 49Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">512	pulse  cov: 1379 ft: 2357 <span class="built_in">exec</span>/s: 0 rss: 59Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1024	pulse  cov: 1589 ft: 3072 <span class="built_in">exec</span>/s: 0 rss: 79Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2048	pulse  cov: 1784 ft: 4189 <span class="built_in">exec</span>/s: 0 rss: 118Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4096	pulse  cov: 1927 ft: 5891 <span class="built_in">exec</span>/s: 4096 rss: 200Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8192	pulse  cov: 2114 ft: 8896 <span class="built_in">exec</span>/s: 2730 rss: 438Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9223	DONE   cov: 2157 ft: 9995 <span class="built_in">exec</span>/s: 1537 rss: 514Mb</span></span><br><span class="line">MERGE-OUTER: succesfull in 1 attempt(s)</span><br><span class="line">MERGE-OUTER: the control file has 845677 bytes</span><br><span class="line">MERGE-OUTER: consumed 0Mb (49Mb rss) to parse the control file</span><br><span class="line">MERGE-OUTER: 3167 new files with 9995 new features added; 2157 new coverage edges</span><br></pre></td></tr></table></figure>

<p>文件个数从9223 缩减到 3167个，以达到同样的覆盖率2157</p>
<br>

<h6 id="corpus2"><a href="#corpus2" class="headerlink" title="corpus2"></a>corpus2</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./xml_read_memory_fuzzer -merge=1 ./corpus2_min/ ./corpus2</span></span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 1659055772</span><br><span class="line">INFO: Loaded 1 modules   (53679 inline 8-bit counters): 53679 [0xd9b020, 0xda81cf), </span><br><span class="line">INFO: Loaded 1 PC tables (53679 PCs): 53679 [0xa1d6d0,0xaef1c0), </span><br><span class="line">MERGE-OUTER: 13161 files, 0 in the initial corpus, 0 processed earlier</span><br><span class="line">MERGE-OUTER: attempt 1</span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 1659139381</span><br><span class="line">INFO: Loaded 1 modules   (53679 inline 8-bit counters): 53679 [0xd9b020, 0xda81cf), </span><br><span class="line">INFO: Loaded 1 PC tables (53679 PCs): 53679 [0xa1d6d0,0xaef1c0), </span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes</span><br><span class="line">MERGE-INNER: using the control file &#x27;/tmp/libFuzzerTemp.Merge71780.txt&#x27;</span><br><span class="line">MERGE-INNER: 13161 total files; 0 processed earlier; will process 13161 files now</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1	pulse  cov: 450 ft: 451 <span class="built_in">exec</span>/s: 0 rss: 38Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2	pulse  cov: 460 ft: 512 <span class="built_in">exec</span>/s: 0 rss: 39Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4	pulse  cov: 474 ft: 562 <span class="built_in">exec</span>/s: 0 rss: 39Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8	pulse  cov: 521 ft: 668 <span class="built_in">exec</span>/s: 0 rss: 40Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16	pulse  cov: 540 ft: 697 <span class="built_in">exec</span>/s: 0 rss: 40Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">32	pulse  cov: 648 ft: 842 <span class="built_in">exec</span>/s: 0 rss: 41Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">64	pulse  cov: 753 ft: 1139 <span class="built_in">exec</span>/s: 0 rss: 42Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">128	pulse  cov: 820 ft: 1256 <span class="built_in">exec</span>/s: 0 rss: 45Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">256	pulse  cov: 1116 ft: 1733 <span class="built_in">exec</span>/s: 0 rss: 50Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">512	pulse  cov: 1368 ft: 2296 <span class="built_in">exec</span>/s: 0 rss: 60Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1024	pulse  cov: 1714 ft: 3149 <span class="built_in">exec</span>/s: 0 rss: 80Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2048	pulse  cov: 2342 ft: 4767 <span class="built_in">exec</span>/s: 0 rss: 118Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4096	pulse  cov: 2835 ft: 6702 <span class="built_in">exec</span>/s: 4096 rss: 194Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8192	pulse  cov: 3104 ft: 9709 <span class="built_in">exec</span>/s: 2730 rss: 359Mb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13161	DONE   cov: 3295 ft: 14468 <span class="built_in">exec</span>/s: 1880 rss: 514Mb</span></span><br><span class="line">MERGE-OUTER: succesfull in 1 attempt(s)</span><br><span class="line">MERGE-OUTER: the control file has 1221537 bytes</span><br><span class="line">MERGE-OUTER: consumed 1Mb (54Mb rss) to parse the control file</span><br><span class="line">MERGE-OUTER: 4993 new files with 14468 new features added; 3295 new coverage edges</span><br></pre></td></tr></table></figure>

<br>

<h4 id="生成覆盖率报告"><a href="#生成覆盖率报告" class="headerlink" title="生成覆盖率报告"></a>生成覆盖率报告</h4><p>这部分在clang-Sanitize-Coverage的文档部分有相关描述</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xml_read_memory_fuzzer corpus1_min -runs=0 -dump_coverage=1</span><br></pre></td></tr></table></figure>

<p>该行命令的期望是在libfuzzer工作目录生成.sancov文件，笔者这边没有生成，尚不确定是什么原因。</p>
<hr>
<br>

<h4 id="Second-fuzzer"><a href="#Second-fuzzer" class="headerlink" title="Second fuzzer"></a>Second fuzzer</h4><p>第二个fuzzer的target是libxml2的<code>xmlRegexpCompile</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libxml/xmlversion.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ignore</span> <span class="params">(<span class="type">void</span> * ctx, <span class="type">const</span> <span class="type">char</span> * msg, ...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Error handler to avoid spam of error messages from libxml parser.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry point for LibFuzzer.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">xmlSetGenericErrorFunc</span>(<span class="literal">NULL</span>, &amp;ignore);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">buffer</span><span class="params">(size + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  std::<span class="built_in">copy</span>(data, data + size, buffer.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">  xmlRegexpPtr x = <span class="built_in">xmlRegexpCompile</span>(buffer.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">if</span> (x)</span><br><span class="line">    <span class="built_in">xmlRegFreeRegexp</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第13-14行，开辟同libfuzzer生成的数据长度size大小的缓冲区，写入libfuzzer生成的数据</li>
<li>第16行，传递给target function</li>
</ul>
<br>

<h5 id="build-fuzzer"><a href="#build-fuzzer" class="headerlink" title="build fuzzer"></a>build fuzzer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -std=c++11 xml_compile_regexp_fuzzer.cc -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer  -fsanitize-coverage=edge,indirect-calls,trace-cmp,trace-div,trace-gep  -I libxml2/include libxml2/.libs/libxml2.a -lz -llzma -o xml_compile_regexp_fuzzer</span></span><br></pre></td></tr></table></figure>

<br>

<h5 id="run-fuzzer"><a href="#run-fuzzer" class="headerlink" title="run fuzzer"></a>run fuzzer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./xml_compile_regexp_fuzzer -dict=./xml.dict ./corpus4</span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/32.png" class="">

<p>报告的内容是OOM，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==72165== ERROR: libFuzzer: out-of-memory (used: 2132Mb; limit: 2048Mb)</span><br><span class="line">   To change the out-of-memory limit use -rss_limit_mb=&lt;N&gt;</span><br></pre></td></tr></table></figure>

<p>这可能是内存泄漏的漏洞，需要附加LeakSanitizer来进一步确认，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ASAN_OPTIONS=detect_leaks=1 ./xml_compile_regexp_fuzzer -dict=./xml.dict ./corpus4</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><ol>
<li>本节学到的是configure文件过程中加入编译参数，将编译参数写入即将生成的Makefile文件。</li>
<li>ASAN_OPTIONS的使用</li>
<li>提升libfuzzer的效率<ul>
<li>附加字典 -dict</li>
<li>精简语料库</li>
</ul>
</li>
</ol>
<br>

<hr>
<h3 id="Seed-corpus的重要性"><a href="#Seed-corpus的重要性" class="headerlink" title="Seed corpus的重要性"></a>Seed corpus的重要性</h3><blockquote>
<p>本节内容对应workshop lesson 09</p>
</blockquote>
<h4 id="Build-libpng-vuln-ver"><a href="#Build-libpng-vuln-ver" class="headerlink" title="Build libpng vuln-ver"></a>Build libpng vuln-ver</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar xzf libpng.tgz</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> libpng/</span></span><br></pre></td></tr></table></figure>

<p>查看，发现项目同样使用autogen.sh脚本来构造configure文件，运行<code>autogen.sh</code>生成configure文件</p>
<p>设置编译参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> FUZZ_CXXFLAGS=<span class="string">&quot;-O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer-no-link   -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>设置configure的参数，并运行，生成Makefile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure CC=<span class="string">&quot;clang&quot;</span> CFLAGS=<span class="string">&quot;<span class="variable">$FUZZ_CXXFLAGS</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/33.png" class="">

<p>make完成编译</p>
<br>

<h4 id="Build-and-run-the-fuzzer"><a href="#Build-and-run-the-fuzzer" class="headerlink" title="Build and run the fuzzer"></a>Build and run the fuzzer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -std=c++11 libpng_read_fuzzer.cc -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer -fsanitize-coverage=trace-cmp,trace-gep,trace-div -I libpng  libpng/.libs/libpng16.a -lz  -o  libpng_read_fuzzer</span><br></pre></td></tr></table></figure>

<p>通过libfuzzer的参数-print_final_stats&#x3D;1来比对附加了额外数据(dict &amp; seed file)来指导测试用例生成对libfuzzer的运行的影响</p>
<br>

<h5 id="从0开始生成数据"><a href="#从0开始生成数据" class="headerlink" title="从0开始生成数据"></a>从0开始生成数据</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libpng_read_fuzzer -max_len=2048 -max_total_time=300  -print_final_stats=1 corpus1</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 2007079 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 2007079</span><br><span class="line">stat::average_exec_per_sec:     6668</span><br><span class="line">stat::new_units_added:          1405</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              585</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>max_total_time</code>规定的300秒内 执行了2007079次运行，关键指标<code>new_units_added</code>有1405</p>
<br>

<h5 id="附加字典"><a href="#附加字典" class="headerlink" title="附加字典"></a>附加字典</h5><p>附加字典指导测试数据生成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -dict=png.dict -print_final_stats=1 corpus2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 13768165 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 13768165</span><br><span class="line">stat::average_exec_per_sec:     45741</span><br><span class="line">stat::new_units_added:          764</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              664</span><br></pre></td></tr></table></figure>

<p>可以看到，附加字典后，在<code>max_total_time</code>规定的300秒内 执行了13768165次运行，关键指标<code>new_units_added</code>有764，虽然在规定时间内执行的效率变高（体现在执行次数上），可指标<code>new_units_added</code>有所下降</p>
<br>

<h5 id="附加种子文件"><a href="#附加种子文件" class="headerlink" title="附加种子文件"></a>附加种子文件</h5><p>利用种子文件（合法格式）来生成测试数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -print_final_stats=1  -timeout=5 corpus3 seed_corpus</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 2016235 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 2016235</span><br><span class="line">stat::average_exec_per_sec:     6698</span><br><span class="line">stat::new_units_added:          3407</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              504</span><br></pre></td></tr></table></figure>

<p>附加种子数据后，在<code>max_total_time</code>规定的300秒内 <strong>只</strong>执行了2016235次运行，关键指标<code>new_units_added</code>有3407，虽然在规定时间内执行的次数少了，但取而代之高效的fuzzer体现在指标<code>new_units_added</code>上</p>
<br>

<h5 id="字典-种子文件"><a href="#字典-种子文件" class="headerlink" title="字典+种子文件"></a>字典+种子文件</h5><p>生成测试用例的可参考规则增多，更容易生成合法的有效输入给测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -dict=png.dict  -print_final_stats=1 -timeout=5 corpus4 seed_corpus</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 1697945 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 1697945</span><br><span class="line">stat::average_exec_per_sec:     5641</span><br><span class="line">stat::new_units_added:          3362</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              596</span><br></pre></td></tr></table></figure>

<p>附加字典以及种子数据后，在<code>max_total_time</code>规定的300秒内 <strong>只</strong>执行了1697945次运行，关键指标<code>new_units_added</code>有3362，感觉像是二者联合作用，并没有在只附加种子数据提升很大。</p>
<hr>
<p>PS：</p>
<p>一开始不知道编译漏洞版本libpng的下面命令的作用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disable logging via library build configuration control.</span></span><br><span class="line">cat scripts/pnglibconf.dfa | sed -e &quot;s/option STDIO/option STDIO disabled/&quot; \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">scripts/pnglibconf.dfa.temp</span></span><br><span class="line">mv scripts/pnglibconf.dfa.temp scripts/pnglibconf.dfa</span><br></pre></td></tr></table></figure>

<p>观察fuzzer的行为之后感觉像是屏蔽掉无效的输出内容（libpng的不合法文件格式）</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/34.png" class="">

<br>

<h4 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h4><p>通过对比规定时间内fuzzer的运行情况，发现种子数据（Seed Corpus）对fuzzer运行比字典–dict的方式提升更大。</p>
<hr>
<h3 id="字段max-len"><a href="#字段max-len" class="headerlink" title="字段max-len"></a>字段max-len</h3><blockquote>
<p>本节对应workshop的 lesson 10，了解字段max-len对运行效率的影响</p>
</blockquote>
<br>

<h4 id="编译target"><a href="#编译target" class="headerlink" title="编译target"></a>编译target</h4><p>项目使用Makefile来编译的，解压后就有Makefile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">export</span> FUZZ_CXXFLAGS=<span class="string">&quot;-O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer-no-link  -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make clean</span></span><br><span class="line">CXX=clang++ CXXFLAGS=&quot;$FUZZ_CXXFLAGS&quot; make -j4</span><br></pre></td></tr></table></figure>

<ul>
<li>设置编译参数</li>
<li>清除可能残留的make痕迹</li>
<li>设置参数，make编译</li>
</ul>
<br>

<h4 id="编译fuzzer-1"><a href="#编译fuzzer-1" class="headerlink" title="编译fuzzer"></a>编译fuzzer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">clang++ -std=c++11 re2_fuzzer.cc -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer -fsanitize-coverage=trace-cmp,trace-gep,trace-div -I re2   re2/obj/libre2.a  -lz -o re2_fuzzer</span></span><br></pre></td></tr></table></figure>

<br>

<p>设置不同的max_len执行fuzzer</p>
<h5 id="max-len-not-set"><a href="#max-len-not-set" class="headerlink" title="max_len not set"></a>max_len not set</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">mkdir</span> corpus1</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./re2_fuzzer ./corpus1 -print_final_stats=1 -max_total_time=300</span></span><br></pre></td></tr></table></figure>

<p>fuzzer提示：<code>INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</code>，不会超过4096bytes</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 591390 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 591390</span><br><span class="line">stat::average_exec_per_sec:     1964</span><br><span class="line">stat::new_units_added:          3465</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              978</span><br></pre></td></tr></table></figure>

<p>这里探讨的是<code>-max_len</code>字段对fuzzer执行速度的影响</p>
<p>可以看到在这个项目中，<code>Done 591390 runs in 301 second(s)</code></p>
<br>

<h5 id="max-len-x3D-5120"><a href="#max-len-x3D-5120" class="headerlink" title="max_len&#x3D;5120"></a>max_len&#x3D;5120</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./re2_fuzzer ./corpus2 -max_len=5120 -print_final_stats=1 -max_total_time=300</span></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Done</span> <span class="number">627412</span> runs in <span class="number">301</span> second(s)</span><br><span class="line"><span class="attribute">stat</span>::number_of_executed_units: <span class="number">627412</span></span><br><span class="line"><span class="attribute">stat</span>::average_exec_per_sec:     <span class="number">2084</span></span><br><span class="line"><span class="attribute">stat</span>::new_units_added:          <span class="number">4591</span></span><br><span class="line"><span class="attribute">stat</span>::slowest_unit_time_sec:    <span class="number">0</span></span><br><span class="line"><span class="attribute">stat</span>::peak_rss_mb:              <span class="number">960</span></span><br></pre></td></tr></table></figure>

<p><code>Done 627412 runs in 301 second(s)</code>稍微高了一丢丢</p>
<br>

<h5 id="max-len-x3D-6114-or-7168"><a href="#max-len-x3D-6114-or-7168" class="headerlink" title="max_len&#x3D;6114 or 7168"></a>max_len&#x3D;6114 or 7168</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./re2_fuzzer ./corpus3 -max_len=6144 -print_final_stats=1 -max_total_time=300</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 627254 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 627254</span><br><span class="line">stat::average_exec_per_sec:     2083</span><br><span class="line">stat::new_units_added:          4648</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              991</span><br></pre></td></tr></table></figure>

<p>变化不大</p>
<br>

<h5 id="max-len-x3D-10240"><a href="#max-len-x3D-10240" class="headerlink" title="max_len&#x3D;10240"></a>max_len&#x3D;10240</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./re2_fuzzer ./corpus5 -max_len=10240 -print_final_stats=1 -max_total_time=300</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Done 663656 runs in 301 second(s)</span><br><span class="line">stat::number_of_executed_units: 663656</span><br><span class="line">stat::average_exec_per_sec:     2204</span><br><span class="line">stat::new_units_added:          4610</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              1025</span><br></pre></td></tr></table></figure>

<p><code>Done 663656 runs in 301 second(s)</code>规定时间内执行次数有所提升</p>
<br>

<h5 id="max-len-x3D-30720"><a href="#max-len-x3D-30720" class="headerlink" title="max_len&#x3D;30720"></a>max_len&#x3D;30720</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./re2_fuzzer ./corpus12 -max_len=30720 -print_final_stats=1 -max_total_time=300</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stat::number_of_executed_units: 654261</span><br><span class="line">stat::average_exec_per_sec:     2173</span><br><span class="line">stat::new_units_added:          4568</span><br><span class="line">stat::slowest_unit_time_sec:    0</span><br><span class="line">stat::peak_rss_mb:              995</span><br></pre></td></tr></table></figure>

<p>显然-max_len也不是越大越好，而是要根据具体fuzz的target来适配的</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>libfuzzer-workshop：<a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop.git">https://github.com/Dor1s/libfuzzer-workshop.git</a></p>
<p>google&#x2F;fuzzing : <a target="_blank" rel="noopener" href="https://github.com/google/fuzzing.git">https://github.com/google/fuzzing.git</a></p>
<p>libfuzzer-intro : <a target="_blank" rel="noopener" href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a></p>
<p>clang文档：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangCommandLineReference.html">https://clang.llvm.org/docs/ClangCommandLineReference.html</a></p>
<p>clang-LeakSanitizer-docs： <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/LeakSanitizer.html?highlight=asan_options">https://clang.llvm.org/docs/LeakSanitizer.html?highlight=asan_options</a></p>
<p>汤师兄的项目：<a target="_blank" rel="noopener" href="https://github.com/lcatro/Source-and-Fuzzing">https://github.com/lcatro/Source-and-Fuzzing</a></p>
<p>汤师兄的文章–编译过程：<a target="_blank" rel="noopener" href="https://github.com/lcatro/Source-and-Fuzzing/blob/master/5.%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.md">https://github.com/lcatro/Source-and-Fuzzing/blob/master/5.%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.md</a></p>
<p>Dev老哥的文章编译&amp;链接：<a target="_blank" rel="noopener" href="https://i-m.dev/posts/20190831-143715.html">https://i-m.dev/posts/20190831-143715.html</a></p>
<p>dev老哥的libfuzzer入门：<a target="_blank" rel="noopener" href="https://i-m.dev/posts/20190831-143715.html">https://i-m.dev/posts/20190831-143715.html</a></p>
<p>安全客-An9Ela老哥的文章：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/224823">https://www.anquanke.com/post/id/224823</a></p>
<br>

<p>other:</p>
<img src="/2022/05/19/libfuzzerNo-1-about-fuzzer/35.png" class="">

<p>…</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Victory+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cvjark.github.io/2022/05/19/libfuzzerNo-1-about-fuzzer/">https://cvjark.github.io/2022/05/19/libfuzzerNo-1-about-fuzzer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/libfuzzer%E7%B3%BB%E5%88%97/">libfuzzer系列</a><a class="post-meta__tags" href="/tags/fuzzing/">fuzzing</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E9%98%85%E8%AF%BB/">项目阅读</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-627db6d4a04365ef" async></script><nav id="pagination"></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://cvjark.github.io/2022/05/19/libfuzzerNo-1-about-fuzzer/';
  this.page.identifier = '2022/05/19/libfuzzerNo-1-about-fuzzer/';
  this.page.title = 'Libfuzzer workshop项目阅读';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'https-cvjark-github-io' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://https-cvjark-github-io.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/e7/wallhaven-e7lomr.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Victory+</div><div class="framework-info"><span>Victory+</span><span class="footer-separator">❤</span><span>TBaozi</span></div><div class="footer_custom_text"><img src="https://ghchart.rshah.org/Cvjark" alt="Cvjark Github chart" /></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>